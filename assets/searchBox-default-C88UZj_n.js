const t='{"documentCount":588,"nextId":588,"documentIds":{"0":"/archive/#安装","1":"/archive/#配置","2":"/article/4x6pihii/#原因","3":"/archive/#更新记录","4":"/article/5qq2kq2d/#下载安装程序","5":"/archive/#贡献者","6":"/article/wyj6yhxt/#背景","7":"/article/wyj6yhxt/#redis对象系统介绍","8":"/article/wyj6yhxt/#redis主要数据结构一览","9":"/notes/algo/9o690kze/#第二题是特别简单的-dynamic-programming。-1-4-33-67-34-数字不记得了-乱写的。-然后相邻两个数只能选一个-求能返回最大数。我觉得-leetcode-easy-都比这个难。","10":"/notes/algo/1n061ygg/#描述一下迪杰斯特拉-最短路径-算法","11":"/article/wyj6yhxt/#数据结构具体实现","12":"/notes/algo/9o690kze/#跳台阶。先递归-然后让优化-改成了-dp-如果数特别大怎么办","13":"/notes/algo/7n3yv62q/#两个线程交替打印","14":"/notes/algo/g7iq3601/#大数相加-代码题","15":"/notes/algo/e14qki0l/#面试题-手写代码-最长回文子串","16":"/notes/algo/1n061ygg/#算法题-最小通路","17":"/notes/algo/8jvj32w0/#面试题-各种排序算法及其效率","18":"/notes/algo/czwgqioi/#lru设计与实现","19":"/notes/algo/9o690kze/#机器人走路-有多少种做法-做完又加难度-然后在每个方格加一个权值-求最小成本是-多少-然后又加难度-如果不限方向怎么做","20":"/notes/algo/7n3yv62q/#三个线程交替输出123","21":"/notes/algo/t36oj766/#数组基本概念","22":"/notes/algo/g7iq3601/#布隆过滤器讲一下","23":"/notes/algo/e14qki0l/#面试题-字符串数组的公共最长前缀","24":"/notes/algo/8jvj32w0/#说下常见的排序稳定性和复杂度-堆排序是怎么样的","25":"/notes/algo/czwgqioi/#lfu设计与实现","26":"/notes/algo/9o690kze/#算法是给一个很大的数字-怎么返回固定长度的-substring-so-that-他的数值最-大-很简单的-dp。-而且不要求写题-只要讲思路","27":"/notes/algo/7n3yv62q/#写爬虫系统时-如何判定该-url-已经爬过了。这个问题很开-放-而且也挺有意思。","28":"/notes/algo/t36oj766/#特点","29":"/notes/algo/9b5j5se0/#面试题-找虫子","30":"/notes/algo/g7iq3601/#海量数据处理-1t大文件-每一行是一个单词-请在4g内存条件下-统计出频次最高的10个单词","31":"/notes/algo/e14qki0l/#面试题-字符串匹配算法-了解原理吗-其实就是想问下面的kmp懂吗-描述一下-不懂细节-大概讲了讲","32":"/notes/algo/8jvj32w0/#面试题-堆排序实现","33":"/notes/algo/czwgqioi/#设计题-设计一个任务定时器-给定时间和任务-到时间了自动执行对应的任务。","34":"/notes/algo/7n3yv62q/#点分十进制-ip-地址转为-32-位整数","35":"/notes/algo/t36oj766/#数组插入和删除技巧","36":"/notes/algo/9b5j5se0/#面试题-25-匹马五条赛道怎么最快选出前三个","37":"/notes/algo/89orgtxn/#面试题-两个栈实现一个队列。","38":"/notes/algo/g7iq3601/#海量日志查询某一段时间内的记录","39":"/notes/algo/e14qki0l/#面试题-检验字符串是一个回文字符串","40":"/notes/algo/s7ejjdt2/#dfs和bfs的区别","41":"/notes/algo/8jvj32w0/#面试题-口述快排并实现、手写快排","42":"/notes/algo/czwgqioi/#如何设计一个-hashmap-考虑线程安全","43":"/notes/algo/3f0vpugu/#面试题-o-1-的单链表元素删除","44":"/notes/algo/7n3yv62q/#给定-ip-和命中概率-写一个接口来获取-ip-要求获取-ip-的概率和给定的相同","45":"/notes/algo/t36oj766/#注意事项","46":"/notes/algo/9b5j5se0/#面试题-36匹马-6个跑道-最少跑多少趟就可以筛选出前三匹最快的马-六路归并排序。","47":"/notes/algo/89orgtxn/#面试题-给一个出栈序列长度为-n-有多少种入栈的可能。","48":"/notes/archive/#中间件","49":"/notes/algo/g7iq3601/#算法-口述-一千万个0-100之间的浮点数-找出前100个最大的-不考虑空间复杂度","50":"/notes/algo/e14qki0l/#面试题-给定一个字符串s-找到s中最长的回文子串","51":"/notes/algo/s7ejjdt2/#面试题-判断是否为完美二叉树","52":"/notes/algo/8jvj32w0/#面试题-说一下归并排序和复杂度","53":"/notes/algo/czwgqioi/#通过内存的计数器-实现一个限流器。限制请求在每秒-1000-次以下","54":"/notes/algo/3f0vpugu/#面试题-获得单链表的最后-n-个元素","55":"/notes/algo/7n3yv62q/#代码-随机播放-100-首歌-洗牌算法-这个我把自己绕进去了-洗一次直接输出就完了-我当时脑子短路了-洗一次播一首非要再洗一次来手动提升复杂度-最后没绕出去-然后-换题了","56":"/notes/algo/t36oj766/#一些疑问","57":"/notes/algo/9b5j5se0/#两个人抛硬币-抛到正面为止-抛到正面的人赢-问第一个抛的人赢的概率。","58":"/notes/algo/89orgtxn/#把数组元素按照正负序重排列","59":"/notes/archive/#cdn","60":"/notes/design/#设计","61":"/notes/algo/g7iq3601/#算法题-一千万条数据找最大的前-100-个数据-每个数据都是-0-100-的浮点数-最差时间复杂度以及优化","62":"/notes/algo/e14qki0l/#两个字符串求相似度-说了力扣编辑距离-问还有吗-然后就扯到-nlp-了","63":"/notes/algo/s7ejjdt2/#面试题-如何判断一棵树是否为bst","64":"/notes/algo/8jvj32w0/#面试题-手撕堆排","65":"/notes/distributed/#分布式","66":"/notes/algo/czwgqioi/#hash表是如何实现的-hash表的扩容","67":"/notes/algo/3f0vpugu/#面试题-删除有序链表中重复元素","68":"/notes/algo/7n3yv62q/#你用了贪心法-贪心可能会存在什么问题","69":"/notes/algo/t36oj766/#总结","70":"/notes/algo/9b5j5se0/#_8-个跑道-64-匹马要决出最快的-8-匹马要怎么做呢-只记得决出最快-4-匹马-当场算没算-出来","71":"/notes/design/#系统设计","72":"/notes/go/#go语言相关","73":"/notes/algo/g7iq3601/#海量数字-范围都是-1-10000-怎么排序","74":"/notes/algo/e14qki0l/#不区分大小写的-c-字符串比较","75":"/notes/algo/s7ejjdt2/#面试题-求树的最大高度","76":"/notes/algo/8jvj32w0/#面试题-多路归并-用了堆-在细节上有一些问题","77":"/notes/distributed/#cap","78":"/notes/algo/czwgqioi/#map-如何实现的-map-的如何查找-unordered-map-呢","79":"/notes/algo/3f0vpugu/#面试题-反转一个单链表第i到j的部分","80":"/notes/algo/7n3yv62q/#堆里面如何控制并发安全","81":"/notes/algo/t36oj766/#面试题-手撕顺时针打印二维矩阵","82":"/notes/algo/9b5j5se0/#判断一个点是否在封闭图形里边-封闭图形所有点坐标都给出-说思路-这个查了下有个专门的算法-https-www-zhihu-com-question-26551754-任一射线穿过多边形-奇数个交点则位于多边形之内-偶数个交点则位于多边形之外","83":"/notes/design/#面试题-设计一个加密算法","84":"/notes/go/#基本数据结构","85":"/notes/kafka/#kafka","86":"/notes/algo/g7iq3601/#算法题-千万级别的数据量-实现队列-fifo-如何设计数据结构节省内存空间-数据-链表","87":"/notes/algo/e14qki0l/#给定一个字符串-字符串中只有-abc-三种字符-求出其含有-a-b-c-字符的子串数","88":"/notes/algo/s7ejjdt2/#面试题-判断二叉树是否对称-迭代","89":"/notes/algo/8jvj32w0/#_2-求快速排序的算法复杂度的那个递推关系式-t-n-2t-n-2-n-这个简单","90":"/notes/distributed/#分布式算法知道哪些","91":"/notes/algo/czwgqioi/#实现一个位图-包含-constructor-int-size-、check-int-val-、put-int-val-三个方法","92":"/notes/algo/3f0vpugu/#面试题-链表是否有环","93":"/notes/algo/t36oj766/#面试题-两个有序数组合成一个有序数组-不允许有重复数据","94":"/notes/algo/9b5j5se0/#轮流取石头-范围-1-6-先后手策略","95":"/notes/design/#面试题-设计一个哈希函数","96":"/notes/go/#数组未初始化能不能求len","97":"/notes/linux/#linux","98":"/notes/algo/g7iq3601/#提取两个海量-url-数据中的相同值-不准用-hash-分治。","99":"/notes/algo/e14qki0l/#字符串逆置-输入-abc-输出-cba-我万万没想到会出这个-感觉出这个简单题可能是-面试官怕我挂了伤心-安慰我的","100":"/notes/algo/s7ejjdt2/#面试题-给定一个二叉树-从根节点出发-按照前序遍历的顺序打印每个节点-最后回到根节点-比如","101":"/notes/algo/8jvj32w0/#归并排序算法的细节","102":"/notes/distributed/#了解pasox算法吗","103":"/notes/mysql/#mysql","104":"/notes/network/#计算机网络","105":"/notes/algo/3f0vpugu/#面试题-链表合并去重","106":"/notes/algo/t36oj766/#面试题-找出一个数组中长度等于k且阈值大于等于threshold的所有连续的子数组-遍历一遍就完事了","107":"/notes/design/#面试题-手写代码-实现无锁同步-×-我写成了-cas-操作-被打断-说特定的-arm-处理器没有-这个同步原语-不能依赖相关指令。包括信号量等也不行。","108":"/notes/go/#未初始化的slice能不能append","109":"/notes/linux/#操作命令","110":"/notes/nginx/#nginx","111":"/notes/algo/g7iq3601/#一个上-t-的文本文件-里面很多字符串并且用空格分隔-找到不同的字符串数量","112":"/notes/algo/e14qki0l/#算法题-最长不重复子串-返回这个子串","113":"/notes/algo/s7ejjdt2/#面试题-根据这个打印结果-把树给建立起来","114":"/notes/algo/8jvj32w0/#对一个二维数组按照成绩实现快排-里面存的是学生姓名-学生分数","115":"/notes/mysql/#事务","116":"/notes/network/#osi-7层协议-与-五层协议-与4层协议","117":"/notes/algo/3f0vpugu/#k-个一组反转链表","118":"/notes/algo/t36oj766/#两个有序数组的中位数","119":"/notes/design/#面试题-手写代码-自定场景-实现一个满足需求的内存池-×-晕乎乎写出了几个-bug-面试官-眼尖-而且自我感觉回收算法不够好-感谢放过","120":"/notes/go/#go数组和slice的区别","121":"/notes/linux/#面试题-一行命令将大文件切成小文件","122":"/notes/nginx/#负载均衡原理","123":"/notes/os/#操作系统","124":"/notes/algo/g7iq3601/#_100m-的内存-100g-的文件-每行只有一个单词-统计频率最高的-20-个单","125":"/notes/algo/e14qki0l/#有两个字符串-x1-和-x2-写一个函数判断-x2-是否包含-x1-的排列。","126":"/notes/algo/s7ejjdt2/#面试题-二叉树中任意-3-个节点的最近公共祖先","127":"/notes/pattern/#设计模式","128":"/notes/mysql/#隔离级别","129":"/notes/network/#osi-7层协议","130":"/notes/projects/#项目","131":"/notes/algo/3f0vpugu/#算法题-定义链表结构-链表合并","132":"/notes/algo/t36oj766/#搜索旋转数组最小值","133":"/notes/design/#面试题-我现在要做一个限流功能-怎么做","134":"/notes/go/#nil-slice-和-empty-slice区别","135":"/notes/linux/#面试题-如何实时查看日志","136":"/notes/nginx/#面试题-负载均衡怎么实现","137":"/notes/os/#进程-线程-协程","138":"/notes/redis/#redis面试题整理","139":"/notes/algo/g7iq3601/#假如有一个文件-文件里有100万条url-请给出方法统计出现次数最高的前100条-思路-100组-每组前100条拿出来-归并","140":"/notes/algo/e14qki0l/#正则表达式匹配","141":"/notes/tricks/#面试技巧","142":"/notes/algo/s7ejjdt2/#面试题-avl树或者红黑树-插入和查找的细节","143":"/notes/pattern/#说说你用过的设计模式","144":"/notes/mysql/#锁","145":"/notes/network/#链路层-物理层作用","146":"/notes/projects/#挑选一个自己做的最好的项目介绍一下","147":"/notes/algo/3f0vpugu/#面试题-一个链表-奇数位升序-偶数位降序-如何整体排成升序","148":"/notes/algo/t36oj766/#两个有序数组怎么求交集","149":"/notes/design/#面试题-某一个业务中现在需要生成全局唯一的递增-id-并发量非常大-怎么做","150":"/notes/go/#slice底层实现","151":"/notes/linux/#面试题-常用的shell命令","152":"/notes/nginx/#项目","153":"/notes/os/#进程-线程-协程以及他们的区别","154":"/notes/redis/#数据结构系列","155":"/notes/tricks/#邓大总结的面试技巧与话术","156":"/notes/algo/s7ejjdt2/#面试题-红黑树与avl差别","157":"/notes/pattern/#单例模式写一下-是并发安全的吗-如何并发安全-加锁-锁加的区域能不能更小点-临界区控制","158":"/notes/mysql/#索引","159":"/notes/network/#_5层协议","160":"/notes/projects/#cookie-和-session的关系","161":"/notes/algo/3f0vpugu/#面试题-链表相加-代码题-这里我理解了合并有序链表-写错代码题-当场翻车-场面一度十分尴-尬","162":"/notes/algo/t36oj766/#一个数组-每个位置的值对应下标。重新排列-要求对应位置上不能有同下标相同的-值-即原先-a-0-0-重排后-a-0-不可以等于-0。输出总共有多少种重新排列的方法。","163":"/notes/design/#面试题","164":"/notes/go/#map的底层原理","165":"/notes/linux/#面试题-你在-linux-使用经常哪些指令","166":"/notes/nginx/#项目中nginx用来干什么","167":"/notes/os/#进程与线程区别","168":"/notes/redis/#内存系列","169":"/notes/tricks/#为什么使用a","170":"/notes/algo/s7ejjdt2/#面试题-二叉树从根到叶子的路径总和是否存在指定的值","171":"/notes/mysql/#存储引擎","172":"/notes/network/#_4层协议","173":"/notes/projects/#单点登录原理","174":"/notes/algo/3f0vpugu/#单向链表的复制。单项链表还有个random域指针这个有可能指向了前后的结点。完成这个链表的深复制。包括random域也要复制新的链新的。","175":"/notes/algo/t36oj766/#求数组的中位数。数组由一个升序数组翻转形成-如-1-2-3-4-5-6-7-可以从-5-处翻转-形成-5-6-7-1-2-3-4-求-5-6-7-1-2-3-4-的中位数。要求时间复杂度低于-o-n-。","176":"/notes/go/#map是线程安全的吗-怎么解决并发安全问题","177":"/notes/linux/#面试题-如何查看cpu负载情况","178":"/notes/nginx/#nginx的master-worker-和-php-fpm的master-worker有什么区别","179":"/notes/os/#进程之间如何通信","180":"/notes/redis/#面试题-redis内存满了怎么办","181":"/notes/tricks/#你如何解决了x","182":"/notes/algo/s7ejjdt2/#算法题-给定一个仅包含数字-0−9-的二叉树-每一条从根节点到叶子节点的路径都可以-用一个数字表示。","183":"/notes/mysql/#日志","184":"/notes/network/#路由器、防火墙、交换机处于哪一层","185":"/notes/projects/#项目问题","186":"/notes/algo/3f0vpugu/#算法-有一个单链表-奇数位是升序的-偶数位是降序的-要求进行给它进行排序。-我用一个栈来装入偶数位-然后遍历奇数位与这个栈进行-循环比较链表结点与栈顶的大-小-并进行合并就行了","187":"/notes/algo/t36oj766/#给一个数组-定义-x-为某个区间的最小值乘上这个区间内所有元素的和-求最大的-x。如数组为-3-1-6-4-5-则最大的-x-4-6-4-5-60","188":"/notes/go/#go-常见数据结构","189":"/notes/linux/#面试题-linux-的-top命令了解么","190":"/notes/os/#进程的生命周期","191":"/notes/redis/#面试题-redis未设置过期时间会怎么样","192":"/notes/tricks/#究竟和面试官聊什么","193":"/notes/algo/s7ejjdt2/#z-字型打印二叉树","194":"/notes/mysql/#性能优化","195":"/notes/network/#计网转发分组的详细过程","196":"/notes/projects/#项目问题-1","197":"/notes/algo/3f0vpugu/#一个单链表-奇数位置升序-偶数位置降序-将这个链表调整为整体升序-写出代-码。","198":"/notes/algo/t36oj766/#面试题-无序数组中找出连续的数中第一个缺失的数字","199":"/notes/go/#slice、map都是安全的吗","200":"/notes/linux/#面试题-一些-linux-语句的作用-less-more-sed-awk-du-df-dd-at-tee-crotab-xargs","201":"/notes/os/#进程调度","202":"/notes/redis/#面试题-redis内存淘汰机制","203":"/notes/tricks/#小技巧-如果面试官问到-你了解xxxx么","204":"/notes/algo/s7ejjdt2/#给定一个值-找出二叉树中从根节点到叶子节点的路径和等于那个值的路径","205":"/notes/mysql/#sql语句","206":"/notes/network/#问了网络的协议栈-为什么要分层","207":"/notes/projects/#撕项目-扯到文件断点上传-怎么上传的-怎么判断上传完成。","208":"/notes/algo/3f0vpugu/#单链表实现奇数升序-偶数降序-转化到一个完全升序的-list","209":"/notes/algo/t36oj766/#两个倒序数组找最第-k-大的-框架差不多-最后发现漏了一种情况-感觉还在想洗牌的事-情","210":"/notes/go/#golang中的-map-以及-slice-的源码分析以及slice内存泄漏-需要了解什么是内存泄漏","211":"/notes/linux/#面试题-在linux下怎么查找一个日志文件一个方法返回的不同code码的个数","212":"/notes/os/#并发与并行","213":"/notes/redis/#面试题-redis过期处理方式","214":"/notes/tricks/#小技巧-准备案例","215":"/notes/algo/s7ejjdt2/#二叉树的右视图。","216":"/notes/mysql/#数据库语句-工人打工工资日结-一周一根金条-金条只可以被切分两次-怎么做","217":"/notes/network/#osi-和-tcp-ip-协议之间的对应关系","218":"/notes/algo/t36oj766/#算法题-找出数组b里面比数组a大的所有数","219":"/notes/go/#线程安全的map锁分段的细节","220":"/notes/linux/#面试题-如何查看某个进程占用的内存大小","221":"/notes/os/#线程共享的有什么-不共享的有什么","222":"/notes/redis/#线程模型","223":"/notes/algo/s7ejjdt2/#算法-用栈先序遍历二叉树","224":"/notes/mysql/#高可靠","225":"/notes/network/#网络连接的各层的状态","226":"/notes/algo/t36oj766/#算法题-偏转顺序数组-二分","227":"/notes/go/#channel-管道","228":"/notes/linux/#面试题-一个文件中去重后的ip地址数目","229":"/notes/os/#孤儿进程的区别-如何解决孤儿进程的出现","230":"/notes/redis/#redis的io模型","231":"/notes/algo/s7ejjdt2/#二叉树的左视图打印","232":"/notes/mysql/#数据库设计","233":"/notes/network/#tcp和udp","234":"/notes/algo/t36oj766/#算法-两个区间数组-求彼此区间的交集","235":"/notes/go/#channel-有缓冲-无缓冲","236":"/notes/linux/#linux-系统","237":"/notes/os/#了解锁么-如何实现一个锁","238":"/notes/redis/#持久化","239":"/notes/algo/s7ejjdt2/#面试题-红黑树-旋转","240":"/notes/mysql/#参考","241":"/notes/network/#udp和tcp-区别","242":"/notes/algo/t36oj766/#谈谈二分查找-讲解并手写","243":"/notes/go/#关闭channel读取后会怎样","244":"/notes/linux/#面试题-linux内核了解多少","245":"/notes/os/#上层协程结束了-如果通知到子协程也结束","246":"/notes/redis/#面试题-redis-持久化有哪几种-主要用来存什么数据-redis-崩了怎么办-持久化没答上来-说这是运维的工作-崩了说的哨兵-顺带说了下集群","247":"/notes/algo/s7ejjdt2/#第一题-求二叉树的最长路径-路径指任意结点到结点之间的最短距离","248":"/notes/mysql/#事务-1","249":"/notes/network/#tcp可靠性的实现方式","250":"/notes/algo/t36oj766/#算法-数组内打印三个数-加起来等于指定的值","251":"/notes/go/#golang中channel调用问题","252":"/notes/os/#用户态和内核态","253":"/notes/redis/#面试题-redis-怎么做持久化","254":"/notes/algo/s7ejjdt2/#求二叉树是否存在和为-n-的路径","255":"/notes/mysql/#什么是事务","256":"/notes/network/#tcp三次握手-四次挥手","257":"/notes/algo/t36oj766/#第一道原题-数据流的中位数。这道题有点吃亏-虽然见过原题-但是没有去网上找过最-优的解法。然后现场面-面试官就硬要让优化-最后才想出来用两个堆实现。","258":"/notes/go/#go-同步-channel的实现","259":"/notes/os/#线程的上下文切换","260":"/notes/redis/#面试题-bgsave-讲一下-为什么要-fork-一个进程来做","261":"/notes/mysql/#事务的特点或特性","262":"/notes/network/#关于很多tcp面试题的总结","263":"/notes/algo/t36oj766/#面试题-无序中位数找第-k-大的数字-内存是只能存-1-3-的数据怎么办","264":"/notes/go/#内存泄漏","265":"/notes/os/#内核态线程和用户态线程的区别如何切换","266":"/notes/redis/#面试题-写时修改","267":"/notes/mysql/#mysql事务隔离级别对应的问题","268":"/notes/network/#拥塞控制","269":"/notes/algo/t36oj766/#三数之和","270":"/notes/go/#goroutine内存泄漏场景","271":"/notes/os/#上下文切换的细节","272":"/notes/redis/#高可用","273":"/notes/mysql/#事务隔离级别-对应的问题","274":"/notes/network/#请详细介绍一下tcp的三次握手机制-为什么需要三次握手","275":"/notes/algo/t36oj766/#x-2-n-怎么求-x","276":"/notes/go/#go中导致内存泄漏的原因","277":"/notes/os/#fork之后的父子进程虚拟内存空间的相同与不同","278":"/notes/redis/#面试题-redis-集群搭建","279":"/notes/mysql/#mysql事务的隔离级别以及分别如何实现","280":"/notes/network/#tcp访问一个主机如果主机端口不存在返回什么信息-我说应该是time-out吧","281":"/notes/algo/t36oj766/#股票买入时机-限制最多两次。","282":"/notes/go/#了解内存泄漏吗-有什么危害","283":"/notes/os/#多线程中会对全局变量进行pad操作-请问是为啥","284":"/notes/redis/#面试题-redis-哨兵什么作用-怎么实现的-怎么保证可用的","285":"/notes/mysql/#事务的隔离有哪些-说一下每个隔离的区别-mysql默认使用哪个隔离-日常应用中应该使用已提交读还是可重复读","286":"/notes/network/#一个tcp程序的具体步骤","287":"/notes/algo/t36oj766/#random-n-可以生成-0-到-n-1-的数-用-random-n-实现-random-m-m-为任意值","288":"/notes/go/#go-内存分配","289":"/notes/os/#一个线程是如何被挂起的","290":"/notes/redis/#面试题-添加一个节点如何分配槽-说详细具体过程","291":"/notes/mysql/#提交读和可重复读的实现原理","292":"/notes/network/#time-wait-有什么方法可以避免-time-wait-time-wait-是主动断开连接的一方还是被动断开的一方","293":"/notes/algo/t36oj766/#求分位数-相当于手撕快排","294":"/notes/go/#协程与并发","295":"/notes/os/#一个进程是如何被挂起的","296":"/notes/redis/#面试题-迁移-slot-的过程中-get-或者-set-怎么办","297":"/notes/mysql/#事务的实现","298":"/notes/network/#tcp相关的关闭连接","299":"/notes/algo/t36oj766/#_01-矩阵求最大正方形","300":"/notes/go/#golang中哪些方式可以安全读写共享变量","301":"/notes/os/#线程之间的通信方式","302":"/notes/redis/#面试题-如何保证多个服务器的数据一致性","303":"/notes/mysql/#事务的几个特性-2次-事务的特性以及对应的问题-如何保证的","304":"/notes/network/#tcp最多有几个连接-fd限制-四元组ip、port限制","305":"/notes/algo/t36oj766/#fib数列","306":"/notes/go/#go并发为什么快","307":"/notes/os/#进程池-线程池","308":"/notes/redis/#缓存应用","309":"/notes/mysql/#mysql-的事务锁了解吗","310":"/notes/network/#服务端出现大量close-wait原因-主子进程共享socket-close不能完全关闭","311":"/notes/algo/t36oj766/#有一个序列-知道-a-1-a-0-a-n-1-a-n-求在小于-o-n-的复杂度下-求这个序列的波峰。卡了很久-然后面试官稍微提醒了下-代码写出来了","312":"/notes/go/#go协程-java线程区别","313":"/notes/os/#上下文切换的细节-1","314":"/notes/redis/#面试题-微博刷新选取所有关注人的最新-n-条记录如何取","315":"/notes/mysql/#那每一个事务隔离级别分别解决了什么问题呢","316":"/notes/network/#那为什么它们的-seq-需要不同的-seq-呢-我可以直接在-seq-上加个-1-把收到的-seq-置为相同的不久行了吗-为什么我服务器端要单独发送自己的-seq-呢","317":"/notes/algo/t36oj766/#手写代码-从长序列中找出前-k-大的数字-堆排序","318":"/notes/go/#sync-once的实现原理","319":"/notes/os/#内核态线程和用户态线程的区别如何切换-1","320":"/notes/redis/#缓存雪崩怎么解决","321":"/notes/mysql/#讲讲可重复读隔离级别","322":"/notes/network/#为什么建立连接需要三次握手-断开连接需要四次挥手","323":"/notes/algo/t36oj766/#算法-12322121343434-1232212134343-4-数字必须在-0-600-之间-有几种插入方法","324":"/notes/go/#context包有没有用过-我说没用过","325":"/notes/os/#多线程线程的弊端","326":"/notes/redis/#扩展","327":"/notes/mysql/#事务相关-例如事务的隔离是如何实现的-事务是如何保证原子性-不同的事务看到的数据怎么就不一样了-难道每个事务都拷贝一份视图-mvcc-的实现原理-重要-等等。","328":"/notes/network/#为什么会有一个半关闭的状态-明明客户端已经要求断开连接了呀-你还向客户端发送报-不知道-瞎猜数据没传输完","329":"/notes/algo/t36oj766/#给两个数组-长度可能不等-要求循环输出","330":"/notes/go/#sync-map-怎么解决线程安全问题-看过源码吗","331":"/notes/os/#线程的上下文切换-1","332":"/notes/redis/#面试题-你对-redis-怎么理解的","333":"/notes/mysql/#索引-1","334":"/notes/network/#这个数据没传输完指的什么-客户端请求断开连接的时候数据没有传输完吗-谁的数据没有传输完-尴尬了-2-分多钟","335":"/notes/algo/t36oj766/#找名人","336":"/notes/go/#golang-的-waitgroup-用法","337":"/notes/os/#用户态和内核态-1","338":"/notes/redis/#面试题-redis-的总体结构","339":"/notes/mysql/#索引的结构以及概念","340":"/notes/network/#tcp-连接他有一个四元组知道吧","341":"/notes/algo/t36oj766/#代码是一个-1-13-张牌分牌-队列","342":"/notes/go/#go的协程可以不可以自己让出cpu","343":"/notes/os/#什么是线程安全","344":"/notes/redis/#面试题-client-功能是怎么实现的","345":"/notes/mysql/#mysql索引的数据结构以及分类-b-树以及和b-树-红黑树-二叉树的优缺点-聚簇索引-非聚簇索引-hash索引的优缺点以及实现","346":"/notes/network/#tcp-三次握手可以携带数据吗-为什么","347":"/notes/algo/t36oj766/#零钱问题-有零钱1-3-5-求有多少种可能性","348":"/notes/go/#go的协程可以只挂在一个线程上面吗","349":"/notes/os/#进程、线程究竟是由什么组成的-有哪些数据","350":"/notes/redis/#面试题-redis的事件分发","351":"/notes/mysql/#数据库中数据很多的时候如何处理-面试官提示了索引","352":"/notes/network/#tcp-和-udp-稳定性方面的差别","353":"/notes/algo/t36oj766/#算法题-一堆纸牌-哥哥和妹妹都按照最优策略轮流随机抽取一张-最后返回哥哥手中牌的分数之和与妹妹手中牌的总和的差","354":"/notes/go/#一个协程挂起换入另外一个协程是什么过程","355":"/notes/os/#进程调度算法","356":"/notes/redis/#面试题-讲一下文件事件有哪些","357":"/notes/mysql/#索引越多越好么","358":"/notes/network/#tcp-为什么要四次挥手","359":"/notes/algo/t36oj766/#一个环上有-10-个点-编号为-0-9-从-0-点出发-每步可以顺时针到下一个点-也可-以逆时针到上一个点-求-经过-n-步又回到-0-点有多少种不同的走法","360":"/notes/go/#有一个高并发的场景该怎么处理","361":"/notes/os/#io模型","362":"/notes/redis/#面试题-redis-和数据库一致性怎么实现","363":"/notes/mysql/#b-树有什么好处","364":"/notes/network/#视频面用的是tcp还是udp-为什么","365":"/notes/algo/t36oj766/#给你一个数字-n-n-1e9-再给你一个数字-k-k-n-要求你找到-1-2-3-n-按照字典序排序后-第-k-小的数字","366":"/notes/go/#golang-协程机制","367":"/notes/os/#io和多路复用","368":"/notes/redis/#面试题-时间事件-servercron-函数","369":"/notes/mysql/#那么对于mysql来说为什么采用b-树而不采用b树","370":"/notes/network/#后面的问题-udp有什么缺点-如何解决","371":"/notes/algo/t36oj766/#算法题-m-n-横向纵向均递增的矩阵找指定数","372":"/notes/go/#协程的栈空间大小有限制吗-会主动扩展吗","373":"/notes/os/#epoll的底层实现","374":"/notes/redis/#面试题-servercron-做了什么","375":"/notes/mysql/#二叉树-b-树-b-树的区别","376":"/notes/network/#http和https","377":"/notes/algo/t36oj766/#算法题-n-场演唱会-以-starttime-endtime-的形式给出-计算出最多能听几-场演唱会。用你最熟悉的语言把这个算法实现","378":"/notes/go/#golang-context-应用场景","379":"/notes/os/#io多路复用的类别","380":"/notes/redis/#面试题-redis-10w-的-qps-瓶颈点在哪里","381":"/notes/mysql/#innodb二级索引流程","382":"/notes/network/#http状态码","383":"/notes/go/#context-的数据结构-树","384":"/notes/os/#io模型-1","385":"/notes/redis/#参考资料","386":"/notes/mysql/#主键和索引的区别","387":"/notes/network/#http常见字段有哪些","388":"/notes/go/#go-协程","389":"/notes/os/#select、epoll","390":"/notes/mysql/#mysql索引类型有哪些","391":"/notes/network/#http中的请求方法有哪些","392":"/notes/go/#go-协程怎么切换的","393":"/notes/os/#epoll","394":"/notes/mysql/#如何提高索引的速度","395":"/notes/network/#http请求报文格式-响应报文格式","396":"/notes/go/#golang-的协程与-java-线程的区别","397":"/notes/os/#死锁","398":"/notes/mysql/#innodb的索引有哪些","399":"/notes/network/#http1-0-http1-1-http2-0-http3-0各自的优缺点","400":"/notes/go/#golang-的协程间通讯方式有哪些","401":"/notes/os/#死锁产生的四个必要条件","402":"/notes/mysql/#联合索引的使用原则","403":"/notes/network/#http1-0","404":"/notes/go/#go里面一个协程能保证绑定在一个内核线程上面的。","405":"/notes/os/#四种处理死锁的策略","406":"/notes/mysql/#联合索引在b树-b-树的结构是怎么样的-查找过程你了解过么","407":"/notes/network/#http1-1","408":"/notes/go/#go多线程","409":"/notes/os/#操作系统死锁的问题","410":"/notes/mysql/#如何创建索引","411":"/notes/network/#http2-0","412":"/notes/go/#golang协程i-o多路复用机制","413":"/notes/os/#死锁以及怎样避免","414":"/notes/mysql/#数据库的索引","415":"/notes/network/#http3-0","416":"/notes/go/#gmp与垃圾回收","417":"/notes/os/#死锁的必要条件","418":"/notes/mysql/#mysql索引","419":"/notes/network/#了解-https-吗","420":"/notes/go/#go垃圾回收","421":"/notes/os/#死锁的预防","422":"/notes/mysql/#mysql-索引慢分析-线上开启slowlog-提取慢查询-然后仔细分析explain-中-tye字段以及extra字段-发生的具体场景及mysql是怎么做的-被表扬回答的不错","423":"/notes/network/#ssl-的具体流程","424":"/notes/go/#go-gmp-调度-4次","425":"/notes/os/#死锁的处理策略-死锁预防、死锁检测与恢复、死锁避免","426":"/notes/mysql/#了解mysql中的索引-涉3树是这样的一颗多路查找树-其中每一个节点都具有两个孩子及到什么是b树-与二叉搜索树和平衡二叉树区别-以及b-树区别","427":"/notes/network/#对称密钥为什么速度快-没答上来","428":"/notes/go/#go-垃圾回收-什么时候触发-2次","429":"/notes/os/#内存","430":"/notes/mysql/#数据库的索引-1","431":"/notes/network/#一个网页的请求过程","432":"/notes/go/#gmp源码级别分析","433":"/notes/os/#了解虚拟内存吗-什么是虚拟内存-为什么要有虚拟内存","434":"/notes/mysql/#数据库覆盖索引","435":"/notes/network/#用户输入阶段","436":"/notes/go/#go-内存逃逸分析-分析了栈帧-讲五种例子-描述堆栈优缺点-点头","437":"/notes/os/#mmu有了解吗-讲讲mmu","438":"/notes/mysql/#数据库聚集索引和辅助索引","439":"/notes/network/#发起url请求阶段","440":"/notes/go/#性能问题排查","441":"/notes/os/#内存分页的目的是什么","442":"/notes/mysql/#mysql-的索引","443":"/notes/network/#准备渲染进程阶段","444":"/notes/go/#golang-性能问题怎么排查-profile","445":"/notes/os/#内存管理-包括-虚拟内存-重点-、分页、分段、分页系统地址映射、内存置换算法-重点-。","446":"/notes/mysql/#何时使用索引","447":"/notes/network/#提交文档阶段","448":"/notes/go/#项目调试-讲了下gdb","449":"/notes/os/#页面置换算法","450":"/notes/mysql/#索引是如何实现的-多种引擎的实现区别-聚族索引-非聚族索引-二级索引-唯一索引、最左匹配原则等等-非常重要","451":"/notes/network/#页面渲染阶段","452":"/notes/go/#gdb","453":"/notes/os/#虚拟内存是什么","454":"/notes/mysql/#锁-1","455":"/notes/network/#https和http区别","456":"/notes/go/#异常处理","457":"/notes/os/#其他","458":"/notes/mysql/#mysql的锁类型","459":"/notes/network/#https为什么要对称加密-非对称加密-ca机构","460":"/notes/go/#defer-recover-的问题-自己了解不多-简单介绍","461":"/notes/os/#操作系统组成","462":"/notes/mysql/#行锁什么时候变表锁","463":"/notes/network/#https中ssl的握手过程-为什么不一直用非对称加密","464":"/notes/go/#go-defer","465":"/notes/os/#cpu密集型-cpu-bound-与-io密集型-i-o-bound","466":"/notes/mysql/#select语句什么时候行锁什么时候变表锁","467":"/notes/network/#涉及到的知识点","468":"/notes/go/#defer的执行顺序","469":"/notes/os/#cpu密集型-cpu-bound","470":"/notes/mysql/#mysql的锁","471":"/notes/network/#http和https在建立连接的时候的区别与联系-https中的s指的是什么","472":"/notes/go/#defer-a-defer-b-defer-panic-a和b能不能执行到","473":"/notes/os/#io密集型-i-o-bound","474":"/notes/mysql/#用什么语句实现数据库锁","475":"/notes/network/#然后问知道哪些http方法","476":"/notes/go/#defer-recover-panic-执行顺序","477":"/notes/os/#内存泄漏与内存溢出","478":"/notes/mysql/#innodb的一些特性-和myisam的-行锁表锁","479":"/notes/network/#了解-http-协议吗","480":"/notes/go/#go相关的其他问题","481":"/notes/os/#阻塞与非阻塞","482":"/notes/mysql/#各种锁相关-例如表锁-行锁-间隙锁-共享锁-排他锁。这些锁的出现主要是用来解决哪些问题-重要","483":"/notes/network/#http-协议的连接过程","484":"/notes/go/#go怎样实现继承","485":"/notes/os/#同步与异步","486":"/notes/mysql/#存储引擎-1","487":"/notes/network/#http1-x-和-http2-0-的区别","488":"/notes/go/#逃逸分析讲一下","489":"/notes/os/#堆-栈-区别","490":"/notes/mysql/#innodb的一些特性-和myisam的-行锁表锁-1","491":"/notes/network/#http-缓存-强制缓存、协商缓存","492":"/notes/go/#socket","493":"/notes/os/#操作系统中的锁","494":"/notes/mysql/#mysql中innodb引擎","495":"/notes/network/#说一下url的格式-越详细越好","496":"/notes/go/#copy是操作符还是内置函数","497":"/notes/os/#socket的概念","498":"/notes/mysql/#知道哪些存储引擎","499":"/notes/network/#get和post","500":"/notes/go/#一道很简单的go题目-go怎么做深拷贝。","501":"/notes/os/#磁盘转一次要多久","502":"/notes/mysql/#存储引擎在mysql这个系统架构的哪个位置","503":"/notes/network/#get与post的区别","504":"/notes/go/#golang有什么设计很巧妙的地方吗-举几个例子。","505":"/notes/os/#cpu负载过高了怎么办-问题定位","506":"/notes/mysql/#innodb与myisam的区别","507":"/notes/network/#服务器server怎么把cookie设置到浏览器的","508":"/notes/go/#实现string-拷贝构造-主要内存开辟析构-没答好","509":"/notes/os/#磁盘寻道算法","510":"/notes/mysql/#mysql的存储引擎","511":"/notes/network/#cookie传输","512":"/notes/go/#go语言的性能的优劣","513":"/notes/os/#程序执行的交互过程-cpu-os-内存和磁盘都要涉及。","514":"/notes/mysql/#设计","515":"/notes/network/#cookie与session区别","516":"/notes/go/#golang-的默认参数传递方式以及哪些是引用传递","517":"/notes/os/#linuxio-的原理-具体-io-过程介绍。","518":"/notes/mysql/#数据表设计遵循的原则","519":"/notes/network/#多个服务器怎么保存session一致性","520":"/notes/go/#go相关知识点-内存分配、go优缺点、go错误处理有什么优缺点","521":"/notes/os/#临时变量存放在哪里","522":"/notes/mysql/#数据库三大范式","523":"/notes/network/#浏览器刷新界面-服务器如何区分两次相同的请求","524":"/notes/go/#一个go源码级别的仓库讲解-https-github-com-bereborn-learn-blob-master-go-go-e5-86-85-e5-ad-98-e5-88-86-e9-85-8d-c","525":"/notes/os/#执行代码存放在哪里","526":"/notes/mysql/#一范式为什么要列不可分割","527":"/notes/network/#http请求头有什么内容","528":"/notes/go/#框架问题","529":"/notes/mysql/#设计学生成绩系统-如何建表-如何建索引","530":"/notes/network/#http-协议了解吧-session-和-cookie-有什么区别","531":"/notes/go/#gin框架如何实现-我说用go内置的net-http包实现的","532":"/notes/mysql/#数据库表是如何设计的","533":"/notes/network/#_301-302-有什么区别","534":"/notes/go/#了解中间件吗-有什么好处","535":"/notes/mysql/#其他问题","536":"/notes/network/#url-访问过程","537":"/notes/go/#etcd-原理-讲了下raft协议","538":"/notes/mysql/#数据库完整性的实现","539":"/notes/network/#http-和-https-的区别-ca-证书-数字签名-ssl-层握手过程-rsa。","540":"/notes/go/#rpc","541":"/notes/mysql/#主键","542":"/notes/network/#http断点续传","543":"/notes/go/#new-和-make区别","544":"/notes/mysql/#介绍mysql","545":"/notes/network/#其他问题","546":"/notes/go/#为什么要使用-go-语言-go-语言的优势在哪里","547":"/notes/mysql/#数据库中有两个关联列-请问在搜索时-这两个关联列会怎样","548":"/notes/network/#计算机在设置ip的时候会设置哪些参数","549":"/notes/go/#go-func-使用注意点-博大群里面提出的问题","550":"/notes/mysql/#mysql怎么去查询的-什么时候走索引-什么时候不走","551":"/notes/network/#自己简历上写的-icmp","552":"/notes/go/#go语言中的坑-泫提出的","553":"/notes/mysql/#mysql了解什么-有没有搭过mysql、redis","554":"/notes/network/#arp协议","555":"/notes/mysql/#数据库的部署怎么做","556":"/notes/network/#说说你所知道的网络定时器的机制","557":"/notes/mysql/#读写分离具体怎么做","558":"/notes/network/#dns协议","559":"/notes/mysql/#数据库优化-缓存-缓存的不一致-binlog解析器-读写分离-分库分表","560":"/notes/network/#dns-是什么-dns-的查询过程","561":"/notes/mysql/#mysql怎么存储时间","562":"/notes/network/#icmp-这个协议他位于网络的第几层知道吧","563":"/notes/mysql/#mysql把邮戳转化为日常格式时间的函数","564":"/notes/network/#那链路层的协议有哪些啊","565":"/notes/mysql/#sql慢查询","566":"/notes/network/#讲讲ping命令用到了哪些协议","567":"/notes/mysql/#如果一个表查询-插入等很慢-你怎么做","568":"/notes/network/#还没有整理的","569":"/notes/mysql/#mysql-分布式id-项目用到的","570":"/notes/network/#同样问到了-url-访问原理-但是很细节-比如-dns-的原理-在路由器上找的时候-有哪几-种情况","571":"/notes/mysql/#sql语句-查询所有课程分数都大于或等于80分的学生姓名","572":"/notes/network/#http-跟-tcp-是什么关系","573":"/notes/mysql/#写个sql语句-两张表-学生表-学生课程表-求平均分大于85的学生的姓名","574":"/notes/mysql/#sql语句-表【学生-科目-成绩】查询每个学生成绩最好的科目和成绩-没完全写出来","575":"/notes/mysql/#mysql-和-mongodb-的区别-什么时候用-mysql-什么时候用-mongo-因为简历上-有写-mongodb","576":"/notes/mysql/#给定一张表-user-id-name-age","577":"/notes/mysql/#一个教务系统-包括学生信息-课程信息-考试安排-成绩查询-绩点分析-你来设-计数据库表应该怎么设计","578":"/notes/mysql/#char-和-varchar","579":"/notes/mysql/#sql-一个表-user-字段-userid-username-city-查询用户数量最多的三个城市。","580":"/notes/mysql/#mysql-的自增主键和随机生成主键的区别-为什么自增主键效率高。","581":"/notes/mysql/#如何查看数据库表结构","582":"/notes/mysql/#如何提高-sql-查询效率-在语句方面上的优化","583":"/notes/mysql/#一条-sql-语句是如何执行的-进行更新时又是怎么处理的","584":"/notes/mysql/#日志相关-redolog-binlog-undolog-这些日志的实现原理-为了解决怎么问题-日志也是非常重要的吧-面试也问的挺多。","585":"/notes/mysql/#数据库的主从备份、如何保证数据不丢失、如何保证高可用等等。","586":"/notes/mysql/#如何保证多个服务器的数据一致性","587":"/notes/mysql/#建立一张数据库表需要考虑哪些因素-索引的底层实现-是否了解过b-树之外的索引结构。"},"fieldIds":{"title":0,"titles":1,"text":2},"fieldLength":{"0":[1,1,11],"1":[1,1,12],"2":[1,1,10],"3":[1,1,2],"4":[1,1,5],"5":[1,1,1],"6":[1,1,29],"7":[1,1,80],"8":[1,1,7],"9":[17,1,1],"10":[3,1,1],"11":[1,1,1],"12":[7,1,1],"13":[1,1,1],"14":[3,1,1],"15":[3,1,1],"16":[2,1,1],"17":[2,1,1],"18":[1,1,1],"19":[8,1,1],"20":[1,1,1],"21":[1,1,1],"22":[1,1,1],"23":[2,1,1],"24":[2,1,1],"25":[1,1,1],"26":[12,1,1],"27":[8,1,1],"28":[1,2,30],"29":[2,1,16],"30":[5,1,1],"31":[8,1,1],"32":[2,1,1],"33":[5,1,1],"34":[5,1,1],"35":[1,2,77],"36":[3,1,1],"37":[3,1,1],"38":[1,1,1],"39":[2,1,1],"40":[1,1,1],"41":[3,1,1],"42":[4,1,1],"43":[4,1,1],"44":[6,1,1],"45":[1,2,112],"46":[6,1,1],"47":[5,1,1],"48":[1,1,1],"49":[6,1,1],"50":[3,1,1],"51":[2,1,1],"52":[2,1,1],"53":[5,1,1],"54":[4,1,1],"55":[13,1,1],"56":[1,2,46],"57":[5,1,1],"58":[1,1,30],"59":[1,1,46],"60":[1,1,1],"61":[8,1,1],"62":[6,1,1],"63":[3,1,22],"64":[2,1,1],"65":[1,1,1],"66":[2,1,1],"67":[2,1,1],"68":[3,1,1],"69":[1,2,14],"70":[11,1,1],"71":[1,1,1],"72":[1,1,4],"73":[5,1,2],"74":[3,1,1],"75":[2,1,1],"76":[5,1,1],"77":[1,1,10],"78":[5,1,1],"79":[2,1,1],"80":[1,1,1],"81":[2,1,4],"82":[14,1,1],"83":[2,2,1],"84":[1,1,1],"85":[1,1,3],"86":[8,1,1],"87":[9,1,12],"88":[4,1,1],"89":[8,1,1],"90":[1,2,1],"91":[9,1,41],"92":[2,1,1],"93":[3,1,1],"94":[5,1,1],"95":[2,2,1],"96":[1,2,10],"97":[1,1,5],"98":[7,1,1],"99":[11,1,1],"100":[6,1,1],"101":[1,1,1],"102":[1,2,1],"103":[1,1,40],"104":[1,1,8],"105":[2,1,1],"106":[4,1,1],"107":[15,2,1],"108":[1,2,13],"109":[1,1,1],"110":[1,1,1],"111":[5,1,1],"112":[3,1,1],"113":[3,1,1],"114":[3,1,1],"115":[1,1,1],"116":[5,1,1],"117":[2,1,1],"118":[1,1,1],"119":[12,2,1],"120":[1,2,27],"121":[2,2,1],"122":[1,1,1],"123":[1,1,4],"124":[8,1,1],"125":[8,1,1],"126":[4,1,1],"127":[1,1,1],"128":[1,1,1],"129":[3,6,84],"130":[1,1,1],"131":[3,1,1],"132":[1,1,1],"133":[4,2,17],"134":[5,2,68],"135":[2,2,1],"136":[2,2,1],"137":[3,1,1],"138":[1,1,8],"139":[8,1,1],"140":[1,1,1],"141":[1,1,1],"142":[3,1,1],"143":[1,1,1],"144":[1,1,1],"145":[2,6,2],"146":[2,1,3],"147":[6,1,1],"148":[1,1,1],"149":[6,2,1],"150":[1,2,10],"151":[2,2,1],"152":[1,1,1],"153":[3,4,219],"154":[1,1,148],"155":[1,1,1],"156":[2,1,1],"157":[6,1,2],"158":[1,1,1],"159":[1,6,8],"160":[3,1,4],"161":[9,1,1],"162":[13,1,1],"163":[2,2,1],"164":[1,2,9],"165":[4,2,1],"166":[1,2,1],"167":[1,4,14],"168":[1,1,1],"169":[1,2,12],"170":[2,1,1],"171":[1,1,1],"172":[1,6,63],"173":[1,1,1],"174":[5,1,2],"175":[19,1,1],"176":[2,2,5],"177":[2,2,28],"178":[7,1,21],"179":[1,4,103],"180":[2,2,48],"181":[1,2,14],"182":[7,1,11],"183":[1,1,1],"184":[3,6,36],"185":[1,1,21],"186":[11,1,1],"187":[15,1,1],"188":[2,2,6],"189":[4,2,1],"190":[1,4,23],"191":[2,2,5],"192":[1,2,3],"193":[2,1,1],"194":[1,1,1],"195":[1,6,66],"196":[1,1,8],"197":[7,1,1],"198":[2,1,1],"199":[2,2,2],"200":[15,2,1],"201":[1,4,32],"202":[2,2,88],"203":[3,2,21],"204":[2,1,1],"205":[1,1,1],"206":[2,6,5],"207":[5,1,1],"208":[4,1,1],"209":[8,1,1],"210":[6,2,1],"211":[2,2,1],"212":[1,4,31],"213":[2,2,143],"214":[2,2,4],"215":[2,1,1],"216":[5,2,1],"217":[5,6,1],"218":[2,1,1],"219":[1,2,1],"220":[2,2,1],"221":[2,4,40],"222":[1,1,62],"223":[2,1,1],"224":[1,1,1],"225":[1,6,23],"226":[3,1,1],"227":[2,1,3],"228":[2,2,1],"229":[2,4,90],"230":[1,1,73],"231":[1,1,1],"232":[1,1,1],"233":[1,1,12],"234":[3,1,1],"235":[3,3,39],"236":[2,1,1],"237":[2,4,1],"238":[1,1,1],"239":[3,1,1],"240":[1,1,55],"241":[2,2,31],"242":[3,1,1],"243":[1,3,1],"244":[2,2,1],"245":[2,4,1],"246":[10,2,1],"247":[3,1,1],"248":[1,1,16],"249":[1,2,7],"250":[3,1,1],"251":[1,3,1],"252":[1,4,1],"253":[3,2,1],"254":[3,1,13],"255":[1,2,9],"256":[2,2,24],"257":[10,1,1],"258":[3,3,1],"259":[1,4,1],"260":[6,2,1],"261":[1,2,42],"262":[1,2,2],"263":[9,1,1],"264":[1,1,1],"265":[1,4,1],"266":[2,2,1],"267":[1,2,120],"268":[1,2,60],"269":[1,1,1],"270":[1,2,10],"271":[1,4,1],"272":[1,1,1],"273":[2,2,61],"274":[3,2,37],"275":[4,1,1],"276":[1,2,2],"277":[1,4,1],"278":[3,2,1],"279":[2,2,100],"280":[3,2,1],"281":[3,1,1],"282":[3,2,2],"283":[3,4,3],"284":[5,2,1],"285":[4,2,104],"286":[1,2,1],"287":[11,1,1],"288":[2,2,2],"289":[1,4,1],"290":[4,2,1],"291":[1,2,22],"292":[5,2,5],"293":[2,1,1],"294":[1,1,1],"295":[1,4,1],"296":[9,2,1],"297":[1,2,39],"298":[1,2,1],"299":[2,1,1],"300":[1,2,5],"301":[1,4,1],"302":[2,2,1],"303":[4,2,39],"304":[4,2,1],"305":[1,1,1],"306":[1,2,2],"307":[2,4,1],"308":[1,1,22],"309":[2,2,24],"310":[5,2,1],"311":[15,1,1],"312":[2,2,1],"313":[1,4,1],"314":[4,2,2],"315":[1,2,14],"316":[10,2,1],"317":[5,1,1],"318":[2,2,9],"319":[1,4,1],"320":[1,1,72],"321":[1,2,10],"322":[2,2,1],"323":[9,1,1],"324":[2,2,1],"325":[1,4,1],"326":[1,1,1],"327":[10,2,2],"328":[6,2,1],"329":[3,1,33],"330":[5,2,1],"331":[1,4,1],"332":[5,2,1],"333":[1,1,2],"334":[7,2,1],"335":[1,1,27],"336":[4,2,1],"337":[1,4,1],"338":[3,2,1],"339":[1,2,16],"340":[2,2,35],"341":[6,1,1],"342":[1,2,1],"343":[1,4,2],"344":[3,2,1],"345":[9,2,129],"346":[4,2,2],"347":[6,1,1],"348":[1,2,1],"349":[4,4,1],"350":[2,2,1],"351":[2,2,1],"352":[5,2,1],"353":[4,1,1],"354":[2,2,1],"355":[1,4,1],"356":[2,2,1],"357":[2,2,26],"358":[3,2,2],"359":[16,1,1],"360":[1,2,1],"361":[1,1,1],"362":[4,2,1],"363":[1,2,25],"364":[2,2,19],"365":[14,1,8],"366":[2,2,1],"367":[1,2,1],"368":[5,2,1],"369":[1,2,16],"370":[4,2,4],"371":[4,1,1],"372":[3,2,1],"373":[1,2,1],"374":[3,2,1],"375":[4,2,63],"376":[1,1,1],"377":[9,1,1],"378":[3,2,1],"379":[1,2,1],"380":[6,2,1],"381":[1,2,1],"382":[1,2,14],"383":[4,2,1],"384":[1,2,1],"385":[1,1,7],"386":[1,2,1],"387":[1,2,192],"388":[2,2,1],"389":[2,2,1],"390":[1,2,246],"391":[1,2,1],"392":[2,2,1],"393":[1,2,1],"394":[1,2,1],"395":[3,2,2],"396":[5,2,10],"397":[1,2,33],"398":[1,2,1],"399":[6,2,33],"400":[3,2,16],"401":[1,2,68],"402":[1,2,1],"403":[3,8,25],"404":[2,2,1],"405":[1,2,23],"406":[3,2,4],"407":[3,8,23],"408":[1,2,1],"409":[1,2,1],"410":[1,2,1],"411":[2,8,7],"412":[2,2,1],"413":[1,2,1],"414":[1,2,1],"415":[2,8,20],"416":[1,1,1],"417":[1,2,1],"418":[1,2,1],"419":[4,2,1],"420":[1,2,1],"421":[1,2,1],"422":[10,2,1],"423":[2,2,1],"424":[4,2,1],"425":[5,2,1],"426":[5,2,64],"427":[3,2,1],"428":[4,2,1],"429":[1,1,1],"430":[1,2,1],"431":[1,2,6],"432":[1,2,1],"433":[4,2,1],"434":[1,2,34],"435":[1,3,22],"436":[7,2,1],"437":[2,2,1],"438":[1,2,1],"439":[1,3,106],"440":[1,1,1],"441":[2,2,1],"442":[2,2,7],"443":[1,3,24],"444":[4,2,1],"445":[9,2,1],"446":[1,2,1],"447":[1,3,24],"448":[3,2,1],"449":[1,2,37],"450":[9,2,1],"451":[1,3,86],"452":[1,2,1],"453":[1,2,7],"454":[1,1,1],"455":[1,2,33],"456":[1,1,1],"457":[1,1,1],"458":[1,2,5],"459":[4,2,2],"460":[6,2,1],"461":[1,2,5],"462":[1,2,16],"463":[3,2,11],"464":[2,2,1],"465":[8,2,1],"466":[1,2,19],"467":[2,5,25],"468":[1,2,1],"469":[4,10,31],"470":[1,2,1],"471":[3,2,14],"472":[6,2,1],"473":[5,10,56],"474":[1,2,1],"475":[1,2,3],"476":[4,2,1],"477":[2,2,1],"478":[3,2,1],"479":[4,2,6],"480":[1,1,1],"481":[1,2,3],"482":[9,2,54],"483":[3,2,54],"484":[1,2,1],"485":[1,2,16],"486":[1,1,1],"487":[6,2,2],"488":[1,2,1],"489":[3,2,1],"490":[3,2,1],"491":[5,2,21],"492":[1,2,1],"493":[1,2,1],"494":[1,2,1],"495":[2,2,13],"496":[1,2,4],"497":[1,2,1],"498":[1,2,1],"499":[1,2,1],"500":[3,2,31],"501":[1,2,1],"502":[1,2,1],"503":[1,2,14],"504":[3,2,1],"505":[2,2,1],"506":[1,2,1],"507":[1,2,2],"508":[5,2,1],"509":[1,2,1],"510":[1,2,1],"511":[1,2,1],"512":[1,2,1],"513":[5,2,1],"514":[1,1,1],"515":[1,2,1],"516":[3,2,21],"517":[6,2,1],"518":[1,2,1],"519":[2,2,6],"520":[5,2,1],"521":[2,1,1],"522":[1,2,17],"523":[2,2,4],"524":[18,1,1],"525":[2,1,119],"526":[1,2,1],"527":[1,2,1],"528":[1,1,1],"529":[3,2,1],"530":[6,2,1],"531":[3,2,1],"532":[1,2,1],"533":[3,2,1],"534":[2,2,1],"535":[1,1,1],"536":[2,2,4],"537":[4,2,1],"538":[1,2,1],"539":[11,2,1],"540":[1,2,1],"541":[1,2,1],"542":[1,2,1],"543":[3,1,108],"544":[1,2,1],"545":[1,1,1],"546":[5,1,27],"547":[4,2,1],"548":[1,2,6],"549":[4,1,33],"550":[3,2,1],"551":[2,2,14],"552":[3,1,23],"553":[3,2,1],"554":[1,2,1],"555":[1,2,1],"556":[1,2,1],"557":[1,2,1],"558":[1,2,1],"559":[5,2,1],"560":[4,2,27],"561":[1,2,1],"562":[2,2,1],"563":[1,2,1],"564":[1,2,1],"565":[1,2,1],"566":[1,2,1],"567":[4,2,1],"568":[1,1,1],"569":[4,2,1],"570":[10,3,1],"571":[2,2,1],"572":[4,3,144],"573":[5,2,1],"574":[5,2,1],"575":[9,2,1],"576":[6,2,10],"577":[9,2,4],"578":[3,2,9],"579":[9,2,1],"580":[4,2,54],"581":[2,2,1],"582":[5,2,1],"583":[5,2,63],"584":[9,2,56],"585":[4,2,1],"586":[1,1,21],"587":[4,1,133]},"averageFieldLength":[2.9931972789115657,1.8520408163265294,11.421768707482993],"storedFields":{"0":{"title":"安装","titles":[null,null]},"1":{"title":"配置","titles":[null,null]},"2":{"title":"原因","titles":[null]},"3":{"title":"更新记录","titles":[null,null]},"4":{"title":"下载安装程序","titles":[null]},"5":{"title":"贡献者","titles":[null,null]},"6":{"title":"背景","titles":[null]},"7":{"title":"Redis对象系统介绍","titles":[null]},"8":{"title":"Redis主要数据结构一览","titles":[null]},"9":{"title":"第二题是特别简单的 dynamic programming。[1,4,33,67,34] #数字不记得了，乱写的。 然后相邻两个数只能选一个，求能返回最大数。我觉得 leetcode easy 都比这个难。","titles":[null]},"10":{"title":"描述一下迪杰斯特拉（最短路径）算法","titles":[null]},"11":{"title":"数据结构具体实现","titles":[null]},"12":{"title":"跳台阶。先递归，然后让优化，改成了 DP，如果数特别大怎么办？","titles":[null]},"13":{"title":"两个线程交替打印","titles":[null]},"14":{"title":"大数相加（代码题）","titles":[null]},"15":{"title":"面试题：手写代码：最长回文子串","titles":[null]},"16":{"title":"算法题 最小通路","titles":[null]},"17":{"title":"面试题：各种排序算法及其效率","titles":[null]},"18":{"title":"LRU设计与实现","titles":[null]},"19":{"title":"机器人走路，有多少种做法；做完又加难度，然后在每个方格加一个权值，求最小成本是 多少；然后又加难度，如果不限方向怎么做","titles":[null]},"20":{"title":"三个线程交替输出123","titles":[null]},"21":{"title":"数组基本概念","titles":[null]},"22":{"title":"布隆过滤器讲一下","titles":[null]},"23":{"title":"面试题：字符串数组的公共最长前缀","titles":[null]},"24":{"title":"说下常见的排序稳定性和复杂度，堆排序是怎么样的","titles":[null]},"25":{"title":"LFU设计与实现","titles":[null]},"26":{"title":"算法是给一个很大的数字，怎么返回固定长度的 substring，so that 他的数值最 大，很简单的 dp。（而且不要求写题，只要讲思路）","titles":[null]},"27":{"title":"写爬虫系统时，如何判定该 url 已经爬过了。这个问题很开 放，而且也挺有意思。","titles":[null]},"28":{"title":"特点","titles":[null,"数组基本概念"]},"29":{"title":"面试题：找虫子","titles":[null,null]},"30":{"title":"海量数据处理：1T大文件，每一行是一个单词，请在4G内存条件下，统计出频次最高的10个单词","titles":[null]},"31":{"title":"面试题：字符串匹配算法，了解原理吗？(其实就是想问下面的kmp懂吗？描述一下（不懂细节，大概讲了讲）","titles":[null]},"32":{"title":"面试题：堆排序实现","titles":[null]},"33":{"title":"设计题：设计一个任务定时器，给定时间和任务，到时间了自动执行对应的任务。","titles":[null]},"34":{"title":"点分十进制 ip 地址转为 32 位整数","titles":[null]},"35":{"title":"数组插入和删除技巧","titles":[null,"数组基本概念"]},"36":{"title":"面试题：25 匹马五条赛道怎么最快选出前三个","titles":[null,null]},"37":{"title":"面试题：两个栈实现一个队列。","titles":[null]},"38":{"title":"海量日志查询某一段时间内的记录","titles":[null]},"39":{"title":"面试题：检验字符串是一个回文字符串","titles":[null]},"40":{"title":"dfs和bfs的区别","titles":[null]},"41":{"title":"面试题：口述快排并实现、手写快排","titles":[null]},"42":{"title":"如何设计一个 HashMap，考虑线程安全？","titles":[null]},"43":{"title":"面试题：O(1)的单链表元素删除","titles":[null]},"44":{"title":"给定 ip 和命中概率，写一个接口来获取 ip，要求获取 ip 的概率和给定的相同","titles":[null]},"45":{"title":"注意事项","titles":[null,"数组基本概念"]},"46":{"title":"面试题：36匹马，6个跑道，最少跑多少趟就可以筛选出前三匹最快的马？六路归并排序。","titles":[null,null]},"47":{"title":"面试题：给一个出栈序列长度为 n，有多少种入栈的可能。","titles":[null]},"48":{"title":"中间件","titles":[]},"49":{"title":"算法（口述）：一千万个0-100之间的浮点数，找出前100个最大的，不考虑空间复杂度","titles":[null]},"50":{"title":"面试题：给定一个字符串s，找到s中最长的回文子串","titles":[null]},"51":{"title":"面试题：判断是否为完美二叉树","titles":[null]},"52":{"title":"面试题：说一下归并排序和复杂度","titles":[null]},"53":{"title":"通过内存的计数器：实现一个限流器。限制请求在每秒 1000 次以下","titles":[null]},"54":{"title":"面试题：获得单链表的最后 N 个元素","titles":[null]},"55":{"title":"代码：随机播放 100 首歌（洗牌算法/这个我把自己绕进去了，洗一次直接输出就完了， 我当时脑子短路了，洗一次播一首非要再洗一次来手动提升复杂度，最后没绕出去，然后 换题了）","titles":[null]},"56":{"title":"一些疑问","titles":[null,"数组基本概念"]},"57":{"title":"两个人抛硬币，抛到正面为止，抛到正面的人赢，问第一个抛的人赢的概率。","titles":[null,null]},"58":{"title":"把数组元素按照正负序重排列","titles":[null]},"59":{"title":"CDN","titles":["中间件"]},"60":{"title":"设计","titles":[]},"61":{"title":"算法题：一千万条数据找最大的前 100 个数据（每个数据都是 0-100 的浮点数），最差时间复杂度以及优化","titles":[null]},"62":{"title":"两个字符串求相似度，说了力扣编辑距离，问还有吗，然后就扯到 nlp 了","titles":[null]},"63":{"title":"面试题：如何判断一棵树是否为BST？","titles":[null]},"64":{"title":"面试题：手撕堆排","titles":[null]},"65":{"title":"分布式","titles":[]},"66":{"title":"hash表是如何实现的 hash表的扩容","titles":[null]},"67":{"title":"面试题：删除有序链表中重复元素","titles":[null]},"68":{"title":"你用了贪心法, 贪心可能会存在什么问题?","titles":[null]},"69":{"title":"总结","titles":[null,"数组基本概念"]},"70":{"title":"8 个跑道 64 匹马要决出最快的 8 匹马要怎么做呢（只记得决出最快 4 匹马，当场算没算 出来）","titles":[null,null]},"71":{"title":"系统设计","titles":["设计"]},"72":{"title":"Go语言相关","titles":[]},"73":{"title":"海量数字，范围都是 1～10000，怎么排序？","titles":[null]},"74":{"title":"不区分大小写的 C 字符串比较","titles":[null]},"75":{"title":"面试题：求树的最大高度","titles":[null]},"76":{"title":"面试题：多路归并（用了堆，在细节上有一些问题）","titles":[null]},"77":{"title":"CAP","titles":["分布式"]},"78":{"title":"map 如何实现的，map 的如何查找，unordered_map 呢","titles":[null]},"79":{"title":"面试题：反转一个单链表第i到j的部分","titles":[null]},"80":{"title":"堆里面如何控制并发安全","titles":[null]},"81":{"title":"面试题：手撕顺时针打印二维矩阵","titles":[null]},"82":{"title":"判断一个点是否在封闭图形里边，封闭图形所有点坐标都给出，说思路（这个查了下有个专门的算法 https://www.zhihu.com/question/26551754 任一射线穿过多边形，奇数个交点则位于多边形之内，偶数个交点则位于多边形之外）","titles":[null,null]},"83":{"title":"面试题：设计一个加密算法","titles":["设计","系统设计"]},"84":{"title":"基本数据结构","titles":["Go语言相关"]},"85":{"title":"Kafka","titles":[]},"86":{"title":"算法题：千万级别的数据量，实现队列 FIFO，如何设计数据结构节省内存空间（数据+ 链表）","titles":[null]},"87":{"title":"给定一个字符串，字符串中只有 abc 三种字符，求出其含有 a b c 字符的子串数","titles":[null]},"88":{"title":"面试题：判断二叉树是否对称(迭代)","titles":[null]},"89":{"title":"2.求快速排序的算法复杂度的那个递推关系式: T(n) = 2T(n/2) + n，这个简单","titles":[null]},"90":{"title":"分布式算法知道哪些","titles":["分布式","CAP"]},"91":{"title":"实现一个位图，包含 constructor(int size)、check(int val)、put(int val) 三个方法","titles":[null]},"92":{"title":"面试题：链表是否有环","titles":[null]},"93":{"title":"面试题： 两个有序数组合成一个有序数组，不允许有重复数据","titles":[null]},"94":{"title":"轮流取石头 范围[1-6] 先后手策略","titles":[null,null]},"95":{"title":"面试题：设计一个哈希函数","titles":["设计","系统设计"]},"96":{"title":"数组未初始化能不能求len","titles":["Go语言相关","基本数据结构"]},"97":{"title":"Linux","titles":[]},"98":{"title":"提取两个海量 url 数据中的相同值，不准用 Hash 分治。","titles":[null]},"99":{"title":"字符串逆置：输入&quot;abc&quot; 输出&quot;cba&quot;（我万万没想到会出这个，感觉出这个简单题可能是 面试官怕我挂了伤心，安慰我的）","titles":[null]},"100":{"title":"面试题：给定一个二叉树，从根节点出发，按照前序遍历的顺序打印每个节点，最后回到根节点，比如","titles":[null]},"101":{"title":"归并排序算法的细节","titles":[null]},"102":{"title":"了解pasox算法吗","titles":["分布式","CAP"]},"103":{"title":"Mysql","titles":[]},"104":{"title":"计算机网络","titles":[]},"105":{"title":"面试题：链表合并去重","titles":[null]},"106":{"title":"面试题：找出一个数组中长度等于k且阈值大于等于threshold的所有连续的子数组(遍历一遍就完事了)","titles":[null]},"107":{"title":"面试题：手写代码：实现无锁同步 （×：我写成了 CAS 操作，被打断，说特定的 ARM 处理器没有 这个同步原语，不能依赖相关指令。包括信号量等也不行。）","titles":["设计","系统设计"]},"108":{"title":"未初始化的slice能不能append","titles":["Go语言相关","基本数据结构"]},"109":{"title":"操作命令","titles":["Linux"]},"110":{"title":"Nginx","titles":[]},"111":{"title":"一个上 T 的文本文件，里面很多字符串并且用空格分隔，找到不同的字符串数量","titles":[null]},"112":{"title":"算法题：最长不重复子串，返回这个子串","titles":[null]},"113":{"title":"面试题：根据这个打印结果，把树给建立起来","titles":[null]},"114":{"title":"对一个二维数组按照成绩实现快排，里面存的是学生姓名，学生分数","titles":[null]},"115":{"title":"事务","titles":["Mysql"]},"116":{"title":"OSI 7层协议 与 五层协议 与4层协议","titles":["计算机网络"]},"117":{"title":"K 个一组反转链表","titles":[null]},"118":{"title":"两个有序数组的中位数","titles":[null]},"119":{"title":"面试题：手写代码：自定场景，实现一个满足需求的内存池 （×：晕乎乎写出了几个 bug，面试官 眼尖…而且自我感觉回收算法不够好，感谢放过）","titles":["设计","系统设计"]},"120":{"title":"go数组和slice的区别","titles":["Go语言相关","基本数据结构"]},"121":{"title":"面试题：一行命令将大文件切成小文件","titles":["Linux","操作命令"]},"122":{"title":"负载均衡原理","titles":["Nginx"]},"123":{"title":"操作系统","titles":[]},"124":{"title":"100M 的内存，100G 的文件（每行只有一个单词），统计频率最高的 20 个单","titles":[null]},"125":{"title":"有两个字符串 x1 和 x2，写一个函数判断 x2 是否包含 x1 的排列。","titles":[null]},"126":{"title":"面试题：二叉树中任意 3 个节点的最近公共祖先","titles":[null]},"127":{"title":"设计模式","titles":[]},"128":{"title":"隔离级别","titles":["Mysql"]},"129":{"title":"OSI 7层协议：","titles":["计算机网络","OSI 7层协议 与 五层协议 与4层协议"]},"130":{"title":"项目","titles":[]},"131":{"title":"算法题：定义链表结构，链表合并","titles":[null]},"132":{"title":"搜索旋转数组最小值","titles":[null]},"133":{"title":"面试题：我现在要做一个限流功能, 怎么做？","titles":["设计","系统设计"]},"134":{"title":"nil slice 和 empty slice区别","titles":["Go语言相关","基本数据结构"]},"135":{"title":"面试题：如何实时查看日志","titles":["Linux","操作命令"]},"136":{"title":"面试题：负载均衡怎么实现","titles":["Nginx","负载均衡原理"]},"137":{"title":"进程 线程 协程","titles":["操作系统"]},"138":{"title":"Redis面试题整理","titles":[]},"139":{"title":"假如有一个文件，文件里有100万条url，请给出方法统计出现次数最高的前100条（思路：100组，每组前100条拿出来，归并）","titles":[null]},"140":{"title":"正则表达式匹配","titles":[null]},"141":{"title":"面试技巧","titles":[]},"142":{"title":"面试题：AVL树或者红黑树 插入和查找的细节","titles":[null]},"143":{"title":"说说你用过的设计模式","titles":["设计模式"]},"144":{"title":"锁","titles":["Mysql"]},"145":{"title":"链路层，物理层作用","titles":["计算机网络","OSI 7层协议 与 五层协议 与4层协议"]},"146":{"title":"挑选一个自己做的最好的项目介绍一下：","titles":["项目"]},"147":{"title":"面试题：一个链表，奇数位升序，偶数位降序，如何整体排成升序？","titles":[null]},"148":{"title":"两个有序数组怎么求交集","titles":[null]},"149":{"title":"面试题：某一个业务中现在需要生成全局唯一的递增 ID, 并发量非常大, 怎么做？","titles":["设计","系统设计"]},"150":{"title":"slice底层实现","titles":["Go语言相关","基本数据结构"]},"151":{"title":"面试题：常用的Shell命令","titles":["Linux","操作命令"]},"152":{"title":"项目","titles":["Nginx"]},"153":{"title":"进程，线程，协程以及他们的区别","titles":["操作系统","进程 线程 协程"]},"154":{"title":"数据结构系列","titles":["Redis面试题整理"]},"155":{"title":"邓大总结的面试技巧与话术","titles":["面试技巧"]},"156":{"title":"面试题：红黑树与AVL差别","titles":[null]},"157":{"title":"单例模式写一下，是并发安全的吗？如何并发安全（加锁，锁加的区域能不能更小点，临界区控制","titles":["设计模式"]},"158":{"title":"索引","titles":["Mysql"]},"159":{"title":"5层协议","titles":["计算机网络","OSI 7层协议 与 五层协议 与4层协议"]},"160":{"title":"cookie 和 session的关系","titles":["项目"]},"161":{"title":"面试题：链表相加(代码题，这里我理解了合并有序链表，写错代码题，当场翻车，场面一度十分尴 尬)","titles":[null]},"162":{"title":"一个数组，每个位置的值对应下标。重新排列，要求对应位置上不能有同下标相同的 值，即原先 a[0]=0，重排后 a[0]不可以等于 0。输出总共有多少种重新排列的方法。","titles":[null]},"163":{"title":"面试题：","titles":["设计","系统设计"]},"164":{"title":"map的底层原理","titles":["Go语言相关","基本数据结构"]},"165":{"title":"面试题：你在 Linux 使用经常哪些指令","titles":["Linux","操作命令"]},"166":{"title":"项目中Nginx用来干什么","titles":["Nginx","项目"]},"167":{"title":"进程与线程区别","titles":["操作系统","进程 线程 协程"]},"168":{"title":"内存系列","titles":["Redis面试题整理"]},"169":{"title":"为什么使用A","titles":["面试技巧","邓大总结的面试技巧与话术"]},"170":{"title":"面试题：二叉树从根到叶子的路径总和是否存在指定的值","titles":[null]},"171":{"title":"存储引擎","titles":["Mysql"]},"172":{"title":"4层协议","titles":["计算机网络","OSI 7层协议 与 五层协议 与4层协议"]},"173":{"title":"单点登录原理","titles":["项目"]},"174":{"title":"单向链表的复制。单项链表还有个random域指针这个有可能指向了前后的结点。完成这个链表的深复制。包括random域也要复制新的链新的。","titles":[null]},"175":{"title":"求数组的中位数。数组由一个升序数组翻转形成，如 1 2 3 4 5 6 7 可以从 5 处翻转，形成 5 6 7 1 2 3 4，求 5 6 7 1 2 3 4 的中位数。要求时间复杂度低于 O(n)。","titles":[null]},"176":{"title":"Map是线程安全的吗？怎么解决并发安全问题","titles":["Go语言相关","基本数据结构"]},"177":{"title":"面试题：如何查看CPU负载情况","titles":["Linux","操作命令"]},"178":{"title":"nginx的master-worker 和 php-fpm的master-worker有什么区别？","titles":["Nginx"]},"179":{"title":"进程之间如何通信","titles":["操作系统","进程 线程 协程"]},"180":{"title":"面试题：Redis内存满了怎么办","titles":["Redis面试题整理","内存系列"]},"181":{"title":"你如何解决了X","titles":["面试技巧","邓大总结的面试技巧与话术"]},"182":{"title":"算法题： 给定一个仅包含数字 0−9 的二叉树，每一条从根节点到叶子节点的路径都可以 用一个数字表示。","titles":[null]},"183":{"title":"日志","titles":["Mysql"]},"184":{"title":"路由器、防火墙、交换机处于哪一层","titles":["计算机网络","OSI 7层协议 与 五层协议 与4层协议"]},"185":{"title":"项目问题","titles":["项目"]},"186":{"title":"算法：有一个单链表，奇数位是升序的，偶数位是降序的，要求进行给它进行排序。（我用一个栈来装入偶数位，然后遍历奇数位与这个栈进行，循环比较链表结点与栈顶的大 小，并进行合并就行了……）","titles":[null]},"187":{"title":"给一个数组，定义 X 为某个区间的最小值乘上这个区间内所有元素的和，求最大的 X。如数组为 3 1 6 4 5，则最大的 X=4*（6+4+5）=60","titles":[null]},"188":{"title":"go 常见数据结构","titles":["Go语言相关","基本数据结构"]},"189":{"title":"面试题：Linux 的 top命令了解么","titles":["Linux","操作命令"]},"190":{"title":"进程的生命周期","titles":["操作系统","进程 线程 协程"]},"191":{"title":"面试题：Redis未设置过期时间会怎么样","titles":["Redis面试题整理","内存系列"]},"192":{"title":"究竟和面试官聊什么","titles":["面试技巧","邓大总结的面试技巧与话术"]},"193":{"title":"Z 字型打印二叉树","titles":[null]},"194":{"title":"性能优化","titles":["Mysql"]},"195":{"title":"计网转发分组的详细过程","titles":["计算机网络","OSI 7层协议 与 五层协议 与4层协议"]},"196":{"title":"项目问题","titles":["项目"]},"197":{"title":"一个单链表，奇数位置升序，偶数位置降序，将这个链表调整为整体升序，写出代 码。","titles":[null]},"198":{"title":"面试题：无序数组中找出连续的数中第一个缺失的数字","titles":[null]},"199":{"title":"Slice、map都是安全的吗","titles":["Go语言相关","基本数据结构"]},"200":{"title":"面试题：一些 Linux 语句的作用：less more sed awk du df dd at tee crotab xargs","titles":["Linux","操作命令"]},"201":{"title":"进程调度","titles":["操作系统","进程 线程 协程"]},"202":{"title":"面试题：Redis内存淘汰机制","titles":["Redis面试题整理","内存系列"]},"203":{"title":"小技巧：如果面试官问到，你了解XXXX么","titles":["面试技巧","邓大总结的面试技巧与话术"]},"204":{"title":"给定一个值，找出二叉树中从根节点到叶子节点的路径和等于那个值的路径","titles":[null]},"205":{"title":"SQL语句","titles":["Mysql"]},"206":{"title":"问了网络的协议栈 为什么要分层","titles":["计算机网络","OSI 7层协议 与 五层协议 与4层协议"]},"207":{"title":"撕项目...：扯到文件断点上传，怎么上传的，怎么判断上传完成。","titles":["项目"]},"208":{"title":"单链表实现奇数升序，偶数降序，转化到一个完全升序的 list","titles":[null]},"209":{"title":"两个倒序数组找最第 k 大的（框架差不多，最后发现漏了一种情况，感觉还在想洗牌的事 情）","titles":[null]},"210":{"title":"Golang中的 map 以及 slice 的源码分析以及slice内存泄漏，需要了解什么是内存泄漏","titles":["Go语言相关","基本数据结构"]},"211":{"title":"面试题：在Linux下怎么查找一个日志文件一个方法返回的不同code码的个数","titles":["Linux","操作命令"]},"212":{"title":"并发与并行","titles":["操作系统","进程 线程 协程"]},"213":{"title":"面试题：Redis过期处理方式","titles":["Redis面试题整理","内存系列"]},"214":{"title":"小技巧：准备案例","titles":["面试技巧","邓大总结的面试技巧与话术"]},"215":{"title":"二叉树的右视图。","titles":[null]},"216":{"title":"数据库语句：工人打工工资日结 一周一根金条 金条只可以被切分两次，怎么做","titles":["Mysql","SQL语句"]},"217":{"title":"OSI 和 TCP/IP 协议之间的对应关系","titles":["计算机网络","OSI 7层协议 与 五层协议 与4层协议"]},"218":{"title":"算法题：找出数组B里面比数组A大的所有数","titles":[null]},"219":{"title":"线程安全的map锁分段的细节","titles":["Go语言相关","基本数据结构"]},"220":{"title":"面试题：如何查看某个进程占用的内存大小","titles":["Linux","操作命令"]},"221":{"title":"线程共享的有什么，不共享的有什么","titles":["操作系统","进程 线程 协程"]},"222":{"title":"线程模型","titles":["Redis面试题整理"]},"223":{"title":"算法:用栈先序遍历二叉树","titles":[null]},"224":{"title":"高可靠","titles":["Mysql"]},"225":{"title":"网络连接的各层的状态","titles":["计算机网络","OSI 7层协议 与 五层协议 与4层协议"]},"226":{"title":"算法题 偏转顺序数组 二分","titles":[null]},"227":{"title":"channel 管道","titles":["Go语言相关"]},"228":{"title":"面试题：一个文件中去重后的IP地址数目","titles":["Linux","操作命令"]},"229":{"title":"孤儿进程的区别，如何解决孤儿进程的出现","titles":["操作系统","进程 线程 协程"]},"230":{"title":"redis的IO模型","titles":["Redis面试题整理"]},"231":{"title":"二叉树的左视图打印","titles":[null]},"232":{"title":"数据库设计","titles":["Mysql"]},"233":{"title":"TCP和UDP","titles":["计算机网络"]},"234":{"title":"算法：两个区间数组，求彼此区间的交集","titles":[null]},"235":{"title":"channel 有缓冲 无缓冲","titles":["Go语言相关","channel 管道"]},"236":{"title":"Linux 系统","titles":["Linux"]},"237":{"title":"了解锁么，如何实现一个锁","titles":["操作系统","进程 线程 协程"]},"238":{"title":"持久化","titles":["Redis面试题整理"]},"239":{"title":"面试题：红黑树/旋转","titles":[null]},"240":{"title":"参考","titles":["Mysql"]},"241":{"title":"UDP和TCP 区别","titles":["计算机网络","TCP和UDP"]},"242":{"title":"谈谈二分查找（讲解并手写）","titles":[null]},"243":{"title":"关闭channel读取后会怎样","titles":["Go语言相关","channel 管道"]},"244":{"title":"面试题：Linux内核了解多少","titles":["Linux","Linux 系统"]},"245":{"title":"上层协程结束了，如果通知到子协程也结束","titles":["操作系统","进程 线程 协程"]},"246":{"title":"面试题：Redis 持久化有哪几种，主要用来存什么数据，Redis 崩了怎么办（持久化没答上来， 说这是运维的工作 ，崩了说的哨兵，顺带说了下集群）","titles":["Redis面试题整理","持久化"]},"247":{"title":"第一题：求二叉树的最长路径，路径指任意结点到结点之间的最短距离","titles":[null]},"248":{"title":"事务","titles":["Mysql"]},"249":{"title":"TCP可靠性的实现方式","titles":["计算机网络","TCP和UDP"]},"250":{"title":"算法 数组内打印三个数，加起来等于指定的值","titles":[null]},"251":{"title":"golang中channel调用问题","titles":["Go语言相关","channel 管道"]},"252":{"title":"用户态和内核态","titles":["操作系统","进程 线程 协程"]},"253":{"title":"面试题：Redis 怎么做持久化","titles":["Redis面试题整理","持久化"]},"254":{"title":"求二叉树是否存在和为 N 的路径","titles":[null]},"255":{"title":"什么是事务","titles":["Mysql","事务"]},"256":{"title":"tcp三次握手 四次挥手","titles":["计算机网络","TCP和UDP"]},"257":{"title":"第一道原题，数据流的中位数。这道题有点吃亏，虽然见过原题，但是没有去网上找过最 优的解法。然后现场面，面试官就硬要让优化，最后才想出来用两个堆实现。","titles":[null]},"258":{"title":"go 同步，channel的实现","titles":["Go语言相关","channel 管道"]},"259":{"title":"线程的上下文切换","titles":["操作系统","进程 线程 协程"]},"260":{"title":"面试题：bgsave 讲一下，为什么要 fork 一个进程来做","titles":["Redis面试题整理","持久化"]},"261":{"title":"事务的特点或特性","titles":["Mysql","事务"]},"262":{"title":"关于很多TCP面试题的总结","titles":["计算机网络","TCP和UDP"]},"263":{"title":"面试题：无序中位数找第 K 大的数字-&gt; 内存是只能存 1/3 的数据怎么办","titles":[null]},"264":{"title":"内存泄漏","titles":["Go语言相关"]},"265":{"title":"内核态线程和用户态线程的区别如何切换","titles":["操作系统","进程 线程 协程"]},"266":{"title":"面试题：写时修改","titles":["Redis面试题整理","持久化"]},"267":{"title":"mysql事务隔离级别对应的问题","titles":["Mysql","事务"]},"268":{"title":"拥塞控制","titles":["计算机网络","TCP和UDP"]},"269":{"title":"三数之和","titles":[null]},"270":{"title":"goroutine内存泄漏场景","titles":["Go语言相关","内存泄漏"]},"271":{"title":"上下文切换的细节","titles":["操作系统","进程 线程 协程"]},"272":{"title":"高可用","titles":["Redis面试题整理"]},"273":{"title":"事务隔离级别，对应的问题","titles":["Mysql","事务"]},"274":{"title":"请详细介绍一下TCP的三次握手机制，为什么需要三次握手？","titles":["计算机网络","TCP和UDP"]},"275":{"title":"x^2=n 怎么求 x？","titles":[null]},"276":{"title":"go中导致内存泄漏的原因","titles":["Go语言相关","内存泄漏"]},"277":{"title":"fork之后的父子进程虚拟内存空间的相同与不同","titles":["操作系统","进程 线程 协程"]},"278":{"title":"面试题：Redis 集群搭建","titles":["Redis面试题整理","高可用"]},"279":{"title":"mysql事务的隔离级别以及分别如何实现？","titles":["Mysql","事务"]},"280":{"title":"tcp访问一个主机如果主机端口不存在返回什么信息 我说应该是time out吧","titles":["计算机网络","TCP和UDP"]},"281":{"title":"股票买入时机，限制最多两次。","titles":[null]},"282":{"title":"了解内存泄漏吗？有什么危害？","titles":["Go语言相关","内存泄漏"]},"283":{"title":"多线程中会对全局变量进行pad操作，请问是为啥？","titles":["操作系统","进程 线程 协程"]},"284":{"title":"面试题：Redis 哨兵什么作用，怎么实现的，怎么保证可用的","titles":["Redis面试题整理","高可用"]},"285":{"title":"事务的隔离有哪些,说一下每个隔离的区别,mysql默认使用哪个隔离,日常应用中应该使用已提交读还是可重复读","titles":["Mysql","事务"]},"286":{"title":"一个tcp程序的具体步骤","titles":["计算机网络","TCP和UDP"]},"287":{"title":"random（n）可以生成 0 到 n-1 的数，用 random（n）实现 random（m），m 为任意值","titles":[null]},"288":{"title":"go 内存分配","titles":["Go语言相关","内存泄漏"]},"289":{"title":"一个线程是如何被挂起的","titles":["操作系统","进程 线程 协程"]},"290":{"title":"面试题：添加一个节点如何分配槽(说详细具体过程)","titles":["Redis面试题整理","高可用"]},"291":{"title":"提交读和可重复读的实现原理","titles":["Mysql","事务"]},"292":{"title":"TIME_WAIT？有什么方法可以避免 TIME_WAIT？TIME_WAIT 是主动断开连接的一方还是被动断开的一方？","titles":["计算机网络","TCP和UDP"]},"293":{"title":"求分位数，相当于手撕快排","titles":[null]},"294":{"title":"协程与并发","titles":["Go语言相关"]},"295":{"title":"一个进程是如何被挂起的","titles":["操作系统","进程 线程 协程"]},"296":{"title":"面试题：迁移 slot 的过程中， get 或者 set 怎么办？","titles":["Redis面试题整理","高可用"]},"297":{"title":"事务的实现","titles":["Mysql","事务"]},"298":{"title":"TCP相关的关闭连接","titles":["计算机网络","TCP和UDP"]},"299":{"title":"01 矩阵求最大正方形","titles":[null]},"300":{"title":"Golang中哪些方式可以安全读写共享变量","titles":["Go语言相关","协程与并发"]},"301":{"title":"线程之间的通信方式","titles":["操作系统","进程 线程 协程"]},"302":{"title":"面试题：如何保证多个服务器的数据一致性","titles":["Redis面试题整理","高可用"]},"303":{"title":"事务的几个特性 2次 事务的特性以及对应的问题，如何保证的","titles":["Mysql","事务"]},"304":{"title":"TCP最多有几个连接（fd限制+四元组ip、port限制）","titles":["计算机网络","TCP和UDP"]},"305":{"title":"Fib数列","titles":[null]},"306":{"title":"go并发为什么快","titles":["Go语言相关","协程与并发"]},"307":{"title":"进程池 线程池","titles":["操作系统","进程 线程 协程"]},"308":{"title":"缓存应用","titles":["Redis面试题整理"]},"309":{"title":"mysql 的事务锁了解吗","titles":["Mysql","事务"]},"310":{"title":"服务端出现大量close_wait原因（主子进程共享socket，close不能完全关闭）","titles":["计算机网络","TCP和UDP"]},"311":{"title":"有一个序列，知道 a[1]&gt;a[0], a[n-1] &gt; a[n]，求在小于 O(n)的复杂度下，求这个序列的波峰。卡了很久，然后面试官稍微提醒了下，代码写出来了.","titles":[null]},"312":{"title":"go协程 java线程区别","titles":["Go语言相关","协程与并发"]},"313":{"title":"上下文切换的细节","titles":["操作系统","进程 线程 协程"]},"314":{"title":"面试题：微博刷新选取所有关注人的最新 n 条记录如何取","titles":["Redis面试题整理","缓存应用"]},"315":{"title":"那每一个事务隔离级别分别解决了什么问题呢","titles":["Mysql","事务"]},"316":{"title":"那为什么它们的 seq 需要不同的 seq 呢，我可以直接在 seq 上加个 1，把收到的 seq 置为相同的不久行了吗，为什么我服务器端要单独发送自己的 seq 呢","titles":["计算机网络","TCP和UDP"]},"317":{"title":"手写代码：从长序列中找出前 K 大的数字，堆排序","titles":[null]},"318":{"title":"sync.Once的实现原理","titles":["Go语言相关","协程与并发"]},"319":{"title":"内核态线程和用户态线程的区别如何切换","titles":["操作系统","进程 线程 协程"]},"320":{"title":"缓存雪崩怎么解决","titles":["Redis面试题整理"]},"321":{"title":"讲讲可重复读隔离级别","titles":["Mysql","事务"]},"322":{"title":"为什么建立连接需要三次握手，断开连接需要四次挥手","titles":["计算机网络","TCP和UDP"]},"323":{"title":"算法 12322121343434 1232212134343*4 数字必须在 0-600 之间，有几种插入方法","titles":[null]},"324":{"title":"context包有没有用过，我说没用过","titles":["Go语言相关","协程与并发"]},"325":{"title":"多线程线程的弊端","titles":["操作系统","进程 线程 协程"]},"326":{"title":"扩展","titles":["Redis面试题整理"]},"327":{"title":"事务相关：例如事务的隔离是如何实现的？事务是如何保证原子性？不同的事务看到的数据怎么就不一样了？难道每个事务都拷贝一份视图？MVCC 的实现原理（重要）等等。","titles":["Mysql","事务"]},"328":{"title":"为什么会有一个半关闭的状态，明明客户端已经要求断开连接了呀，你还向客户端发送报（不知道，瞎猜数据没传输完）","titles":["计算机网络","TCP和UDP"]},"329":{"title":"给两个数组（长度可能不等），要求循环输出","titles":[null]},"330":{"title":"sync.Map 怎么解决线程安全问题？看过源码吗？","titles":["Go语言相关","协程与并发"]},"331":{"title":"线程的上下文切换","titles":["操作系统","进程 线程 协程"]},"332":{"title":"面试题：你对 redis 怎么理解的？","titles":["Redis面试题整理","扩展"]},"333":{"title":"索引","titles":["Mysql"]},"334":{"title":"这个数据没传输完指的什么，客户端请求断开连接的时候数据没有传输完吗，谁的数据没有传输完（尴尬了 2 分多钟）","titles":["计算机网络","TCP和UDP"]},"335":{"title":"找名人","titles":[null]},"336":{"title":"golang 的 waitGroup 用法","titles":["Go语言相关","协程与并发"]},"337":{"title":"用户态和内核态","titles":["操作系统","进程 线程 协程"]},"338":{"title":"面试题：Redis 的总体结构","titles":["Redis面试题整理","扩展"]},"339":{"title":"索引的结构以及概念","titles":["Mysql","索引"]},"340":{"title":"TCP 连接他有一个四元组知道吧","titles":["计算机网络","TCP和UDP"]},"341":{"title":"代码是一个 1-13 张牌分牌（队列）","titles":[null]},"342":{"title":"Go的协程可以不可以自己让出cpu","titles":["Go语言相关","协程与并发"]},"343":{"title":"什么是线程安全","titles":["操作系统","进程 线程 协程"]},"344":{"title":"面试题：Client 功能是怎么实现的","titles":["Redis面试题整理","扩展"]},"345":{"title":"mysql索引的数据结构以及分类(B+树以及和B-树，红黑树，二叉树的优缺点，聚簇索引，非聚簇索引，hash索引的优缺点以及实现)","titles":["Mysql","索引"]},"346":{"title":"TCP 三次握手可以携带数据吗？为什么？","titles":["计算机网络","TCP和UDP"]},"347":{"title":"零钱问题（有零钱1，3，5 求有多少种可能性）","titles":[null]},"348":{"title":"Go的协程可以只挂在一个线程上面吗","titles":["Go语言相关","协程与并发"]},"349":{"title":"进程、线程究竟是由什么组成的？有哪些数据？","titles":["操作系统","进程 线程 协程"]},"350":{"title":"面试题：Redis的事件分发","titles":["Redis面试题整理","扩展"]},"351":{"title":"数据库中数据很多的时候如何处理？面试官提示了索引","titles":["Mysql","索引"]},"352":{"title":"TCP 和 UDP 稳定性方面的差别?","titles":["计算机网络","TCP和UDP"]},"353":{"title":"算法题：一堆纸牌，哥哥和妹妹都按照最优策略轮流随机抽取一张，最后返回哥哥手中牌的分数之和与妹妹手中牌的总和的差","titles":[null]},"354":{"title":"一个协程挂起换入另外一个协程是什么过程？","titles":["Go语言相关","协程与并发"]},"355":{"title":"进程调度算法","titles":["操作系统","进程 线程 协程"]},"356":{"title":"面试题：讲一下文件事件有哪些","titles":["Redis面试题整理","扩展"]},"357":{"title":"索引越多越好么？","titles":["Mysql","索引"]},"358":{"title":"TCP 为什么要四次挥手？","titles":["计算机网络","TCP和UDP"]},"359":{"title":"一个环上有 10 个点，编号为 0-9，从 0 点出发，每步可以顺时针到下一个点，也可 以逆时针到上一个点，求：经过 n 步又回到 0 点有多少种不同的走法","titles":[null]},"360":{"title":"有一个高并发的场景该怎么处理","titles":["Go语言相关","协程与并发"]},"361":{"title":"IO模型","titles":["操作系统"]},"362":{"title":"面试题：Redis 和数据库一致性怎么实现？","titles":["Redis面试题整理","扩展"]},"363":{"title":"B+树有什么好处","titles":["Mysql","索引"]},"364":{"title":"视频面用的是tcp还是udp，为什么","titles":["计算机网络","TCP和UDP"]},"365":{"title":"给你一个数字 n(n &lt; 1e9),再给你一个数字 k(k &lt; n),要求你找到 1,2,3,...,n 按照字典序排序后，第 k 小的数字；","titles":[null]},"366":{"title":"golang 协程机制","titles":["Go语言相关","协程与并发"]},"367":{"title":"IO和多路复用","titles":["操作系统","IO模型"]},"368":{"title":"面试题：时间事件（serverCron 函数）","titles":["Redis面试题整理","扩展"]},"369":{"title":"那么对于mysql来说为什么采用b+树而不采用b树","titles":["Mysql","索引"]},"370":{"title":"后面的问题：udp有什么缺点，如何解决？","titles":["计算机网络","TCP和UDP"]},"371":{"title":"算法题, M*N 横向纵向均递增的矩阵找指定数","titles":[null]},"372":{"title":"协程的栈空间大小有限制吗？会主动扩展吗？","titles":["Go语言相关","协程与并发"]},"373":{"title":"epoll的底层实现","titles":["操作系统","IO模型"]},"374":{"title":"面试题：serverCron 做了什么","titles":["Redis面试题整理","扩展"]},"375":{"title":"二叉树，b 树，b+树的区别","titles":["Mysql","索引"]},"376":{"title":"Http和Https","titles":["计算机网络"]},"377":{"title":"算法题: N 场演唱会, 以 [{startTime, endTime}…] 的形式给出, 计算出最多能听几 场演唱会。用你最熟悉的语言把这个算法实现","titles":[null]},"378":{"title":"golang context 应用场景","titles":["Go语言相关","协程与并发"]},"379":{"title":"io多路复用的类别","titles":["操作系统","IO模型"]},"380":{"title":"面试题：Redis 10W 的 QPS 瓶颈点在哪里","titles":["Redis面试题整理","扩展"]},"381":{"title":"InnoDB二级索引流程","titles":["Mysql","索引"]},"382":{"title":"HTTP状态码","titles":["计算机网络","Http和Https"]},"383":{"title":"context 的数据结构（树）","titles":["Go语言相关","协程与并发"]},"384":{"title":"Io模型","titles":["操作系统","IO模型"]},"385":{"title":"参考资料","titles":["Redis面试题整理"]},"386":{"title":"主键和索引的区别","titles":["Mysql","索引"]},"387":{"title":"HTTP常见字段有哪些","titles":["计算机网络","Http和Https"]},"388":{"title":"go 协程","titles":["Go语言相关","协程与并发"]},"389":{"title":"select、epoll","titles":["操作系统","IO模型"]},"390":{"title":"mysql索引类型有哪些","titles":["Mysql","索引"]},"391":{"title":"HTTP中的请求方法有哪些","titles":["计算机网络","Http和Https"]},"392":{"title":"go 协程怎么切换的","titles":["Go语言相关","协程与并发"]},"393":{"title":"Epoll","titles":["操作系统","IO模型"]},"394":{"title":"如何提高索引的速度","titles":["Mysql","索引"]},"395":{"title":"http请求报文格式 + 响应报文格式","titles":["计算机网络","Http和Https"]},"396":{"title":"Golang 的协程与 Java 线程的区别？","titles":["Go语言相关","协程与并发"]},"397":{"title":"死锁","titles":["操作系统","IO模型"]},"398":{"title":"innodb的索引有哪些","titles":["Mysql","索引"]},"399":{"title":"http1.0 http1.1 http2.0 http3.0各自的优缺点","titles":["计算机网络","Http和Https"]},"400":{"title":"Golang 的协程间通讯方式有哪些？","titles":["Go语言相关","协程与并发"]},"401":{"title":"死锁产生的四个必要条件","titles":["操作系统","IO模型"]},"402":{"title":"联合索引的使用原则","titles":["Mysql","索引"]},"403":{"title":"http1.0 ：","titles":["计算机网络","Http和Https","http1.0 http1.1 http2.0 http3.0各自的优缺点"]},"404":{"title":"Go里面一个协程能保证绑定在一个内核线程上面的。","titles":["Go语言相关","协程与并发"]},"405":{"title":"四种处理死锁的策略","titles":["操作系统","IO模型"]},"406":{"title":"联合索引在b树，b+树的结构是怎么样的，查找过程你了解过么","titles":["Mysql","索引"]},"407":{"title":"http1.1：","titles":["计算机网络","Http和Https","http1.0 http1.1 http2.0 http3.0各自的优缺点"]},"408":{"title":"go多线程","titles":["Go语言相关","协程与并发"]},"409":{"title":"操作系统死锁的问题","titles":["操作系统","IO模型"]},"410":{"title":"如何创建索引","titles":["Mysql","索引"]},"411":{"title":"http2.0","titles":["计算机网络","Http和Https","http1.0 http1.1 http2.0 http3.0各自的优缺点"]},"412":{"title":"golang协程i/o多路复用机制","titles":["Go语言相关","协程与并发"]},"413":{"title":"死锁以及怎样避免","titles":["操作系统","IO模型"]},"414":{"title":"数据库的索引","titles":["Mysql","索引"]},"415":{"title":"http3.0","titles":["计算机网络","Http和Https","http1.0 http1.1 http2.0 http3.0各自的优缺点"]},"416":{"title":"GMP与垃圾回收","titles":["Go语言相关"]},"417":{"title":"死锁的必要条件","titles":["操作系统","IO模型"]},"418":{"title":"mysql索引","titles":["Mysql","索引"]},"419":{"title":"了解 https 吗？","titles":["计算机网络","Http和Https"]},"420":{"title":"go垃圾回收","titles":["Go语言相关","GMP与垃圾回收"]},"421":{"title":"死锁的预防","titles":["操作系统","IO模型"]},"422":{"title":"mysql 索引慢分析（线上开启slowlog，提取慢查询，然后仔细分析explain 中 tye字段以及extra字段，发生的具体场景及mysql是怎么做的，被表扬回答的不错）","titles":["Mysql","索引"]},"423":{"title":"ssl 的具体流程","titles":["计算机网络","Http和Https"]},"424":{"title":"go gmp 调度 4次","titles":["Go语言相关","GMP与垃圾回收"]},"425":{"title":"死锁的处理策略（死锁预防、死锁检测与恢复、死锁避免）","titles":["操作系统","IO模型"]},"426":{"title":"了解Mysql中的索引：涉3树是这样的一颗多路查找树，其中每一个节点都具有两个孩子及到什么是B树，与二叉搜索树和平衡二叉树区别，以及B+树区别","titles":["Mysql","索引"]},"427":{"title":"对称密钥为什么速度快（没答上来）","titles":["计算机网络","Http和Https"]},"428":{"title":"go 垃圾回收，什么时候触发 2次","titles":["Go语言相关","GMP与垃圾回收"]},"429":{"title":"内存","titles":["操作系统"]},"430":{"title":"数据库的索引","titles":["Mysql","索引"]},"431":{"title":"一个网页的请求过程","titles":["计算机网络","Http和Https"]},"432":{"title":"GMP源码级别分析","titles":["Go语言相关","GMP与垃圾回收"]},"433":{"title":"了解虚拟内存吗？什么是虚拟内存？为什么要有虚拟内存？","titles":["操作系统","内存"]},"434":{"title":"数据库覆盖索引","titles":["Mysql","索引"]},"435":{"title":"用户输入阶段","titles":["计算机网络","Http和Https","一个网页的请求过程"]},"436":{"title":"go 内存逃逸分析（分析了栈帧，讲五种例子，描述堆栈优缺点，点头）","titles":["Go语言相关","GMP与垃圾回收"]},"437":{"title":"mmu有了解吗? 讲讲mmu","titles":["操作系统","内存"]},"438":{"title":"数据库聚集索引和辅助索引","titles":["Mysql","索引"]},"439":{"title":"发起URL请求阶段","titles":["计算机网络","Http和Https","一个网页的请求过程"]},"440":{"title":"性能问题排查","titles":["Go语言相关"]},"441":{"title":"内存分页的目的是什么？","titles":["操作系统","内存"]},"442":{"title":"MySQL 的索引","titles":["Mysql","索引"]},"443":{"title":"准备渲染进程阶段","titles":["计算机网络","Http和Https","一个网页的请求过程"]},"444":{"title":"golang 性能问题怎么排查？（profile）","titles":["Go语言相关","性能问题排查"]},"445":{"title":"内存管理，包括：虚拟内存（重点）、分页、分段、分页系统地址映射、内存置换算法（重点）。","titles":["操作系统","内存"]},"446":{"title":"何时使用索引","titles":["Mysql","索引"]},"447":{"title":"提交文档阶段","titles":["计算机网络","Http和Https","一个网页的请求过程"]},"448":{"title":"项目调试（讲了下GDB）","titles":["Go语言相关","性能问题排查"]},"449":{"title":"页面置换算法","titles":["操作系统","内存"]},"450":{"title":"索引是如何实现的？多种引擎的实现区别？聚族索引，非聚族索引，二级索引，唯一索引、最左匹配原则等等（非常重要）","titles":["Mysql","索引"]},"451":{"title":"页面渲染阶段","titles":["计算机网络","Http和Https","一个网页的请求过程"]},"452":{"title":"gdb","titles":["Go语言相关","性能问题排查"]},"453":{"title":"虚拟内存是什么","titles":["操作系统","内存"]},"454":{"title":"锁","titles":["Mysql"]},"455":{"title":"https和http区别","titles":["计算机网络","Http和Https"]},"456":{"title":"异常处理","titles":["Go语言相关"]},"457":{"title":"其他","titles":["操作系统"]},"458":{"title":"mysql的锁类型","titles":["Mysql","锁"]},"459":{"title":"https为什么要对称加密 + 非对称加密 + CA机构","titles":["计算机网络","Http和Https"]},"460":{"title":"defer recover 的问题（自己了解不多，简单介绍）","titles":["Go语言相关","异常处理"]},"461":{"title":"操作系统组成","titles":["操作系统","其他"]},"462":{"title":"行锁什么时候变表锁","titles":["Mysql","锁"]},"463":{"title":"https中ssl的握手过程？为什么不一直用非对称加密？","titles":["计算机网络","Http和Https"]},"464":{"title":"go defer","titles":["Go语言相关","异常处理"]},"465":{"title":"CPU密集型（CPU-bound）与 IO密集型（I/O bound）","titles":["操作系统","其他"]},"466":{"title":"select语句什么时候行锁什么时候变表锁","titles":["Mysql","锁"]},"467":{"title":"涉及到的知识点：","titles":["计算机网络","Http和Https","https中ssl的握手过程？为什么不一直用非对称加密？"]},"468":{"title":"defer的执行顺序","titles":["Go语言相关","异常处理"]},"469":{"title":"CPU密集型（CPU-bound）","titles":["操作系统","其他","CPU密集型（CPU-bound）与 IO密集型（I/O bound）"]},"470":{"title":"mysql的锁","titles":["Mysql","锁"]},"471":{"title":"http和https在建立连接的时候的区别与联系，https中的s指的是什么？","titles":["计算机网络","Http和Https"]},"472":{"title":"defer A ; defer B ; defer panic(&quot;&quot;) A和B能不能执行到","titles":["Go语言相关","异常处理"]},"473":{"title":"IO密集型（I/O bound）","titles":["操作系统","其他","CPU密集型（CPU-bound）与 IO密集型（I/O bound）"]},"474":{"title":"用什么语句实现数据库锁","titles":["Mysql","锁"]},"475":{"title":"然后问知道哪些http方法","titles":["计算机网络","Http和Https"]},"476":{"title":"defer recover panic 执行顺序","titles":["Go语言相关","异常处理"]},"477":{"title":"内存泄漏与内存溢出：","titles":["操作系统","其他"]},"478":{"title":"innodb的一些特性，和Myisam的，行锁表锁","titles":["Mysql","锁"]},"479":{"title":"了解 HTTP 协议吗？","titles":["计算机网络","Http和Https"]},"480":{"title":"go相关的其他问题","titles":["Go语言相关"]},"481":{"title":"阻塞与非阻塞","titles":["操作系统","其他"]},"482":{"title":"各种锁相关，例如表锁，行锁，间隙锁，共享锁，排他锁。这些锁的出现主要是用来解决哪些问题？（重要）","titles":["Mysql","锁"]},"483":{"title":"HTTP 协议的连接过程？","titles":["计算机网络","Http和Https"]},"484":{"title":"go怎样实现继承","titles":["Go语言相关","go相关的其他问题"]},"485":{"title":"同步与异步","titles":["操作系统","其他"]},"486":{"title":"存储引擎","titles":["Mysql"]},"487":{"title":"HTTP1.x 和 HTTP2.0 的区别","titles":["计算机网络","Http和Https"]},"488":{"title":"逃逸分析讲一下","titles":["Go语言相关","go相关的其他问题"]},"489":{"title":"堆 栈 区别","titles":["操作系统","其他"]},"490":{"title":"innodb的一些特性，和Myisam的，行锁表锁","titles":["Mysql","存储引擎"]},"491":{"title":"HTTP 缓存（强制缓存、协商缓存）","titles":["计算机网络","Http和Https"]},"492":{"title":"socket","titles":["Go语言相关","go相关的其他问题"]},"493":{"title":"操作系统中的锁","titles":["操作系统","其他"]},"494":{"title":"mysql中innodb引擎","titles":["Mysql","存储引擎"]},"495":{"title":"说一下URL的格式，越详细越好","titles":["计算机网络","Http和Https"]},"496":{"title":"copy是操作符还是内置函数","titles":["Go语言相关","go相关的其他问题"]},"497":{"title":"socket的概念","titles":["操作系统","其他"]},"498":{"title":"知道哪些存储引擎","titles":["Mysql","存储引擎"]},"499":{"title":"get和post","titles":["计算机网络","Http和Https"]},"500":{"title":"一道很简单的Go题目，Go怎么做深拷贝。","titles":["Go语言相关","go相关的其他问题"]},"501":{"title":"磁盘转一次要多久","titles":["操作系统","其他"]},"502":{"title":"存储引擎在MySQL这个系统架构的哪个位置","titles":["Mysql","存储引擎"]},"503":{"title":"get与post的区别","titles":["计算机网络","Http和Https"]},"504":{"title":"golang有什么设计很巧妙的地方吗，举几个例子。","titles":["Go语言相关","go相关的其他问题"]},"505":{"title":"CPU负载过高了怎么办，问题定位","titles":["操作系统","其他"]},"506":{"title":"innodb与myisam的区别","titles":["Mysql","存储引擎"]},"507":{"title":"服务器server怎么把cookie设置到浏览器的","titles":["计算机网络","Http和Https"]},"508":{"title":"实现string ，拷贝构造，主要内存开辟析构（没答好)","titles":["Go语言相关","go相关的其他问题"]},"509":{"title":"磁盘寻道算法","titles":["操作系统","其他"]},"510":{"title":"mysql的存储引擎","titles":["Mysql","存储引擎"]},"511":{"title":"cookie传输","titles":["计算机网络","Http和Https"]},"512":{"title":"go语言的性能的优劣","titles":["Go语言相关","go相关的其他问题"]},"513":{"title":"程序执行的交互过程，CPU，OS，内存和磁盘都要涉及。","titles":["操作系统","其他"]},"514":{"title":"设计","titles":["Mysql"]},"515":{"title":"cookie与session区别","titles":["计算机网络","Http和Https"]},"516":{"title":"Golang 的默认参数传递方式以及哪些是引用传递？","titles":["Go语言相关","go相关的其他问题"]},"517":{"title":"LinuxIO 的原理，具体 IO 过程介绍。","titles":["操作系统","其他"]},"518":{"title":"数据表设计遵循的原则","titles":["Mysql","设计"]},"519":{"title":"多个服务器怎么保存session一致性，","titles":["计算机网络","Http和Https"]},"520":{"title":"go相关知识点（内存分配、go优缺点、go错误处理有什么优缺点）","titles":["Go语言相关","go相关的其他问题"]},"521":{"title":"临时变量存放在哪里？","titles":["操作系统"]},"522":{"title":"数据库三大范式","titles":["Mysql","设计"]},"523":{"title":"浏览器刷新界面，服务器如何区分两次相同的请求","titles":["计算机网络","Http和Https"]},"524":{"title":"一个GO源码级别的仓库讲解：https://github.com/bereborn/learn/blob/master/go/go%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.c","titles":["Go语言相关"]},"525":{"title":"执行代码存放在哪里？","titles":["操作系统"]},"526":{"title":"一范式为什么要列不可分割","titles":["Mysql","设计"]},"527":{"title":"http请求头有什么内容","titles":["计算机网络","Http和Https"]},"528":{"title":"框架问题","titles":["Go语言相关"]},"529":{"title":"设计学生成绩系统，如何建表，如何建索引","titles":["Mysql","设计"]},"530":{"title":"http 协议了解吧，session 和 cookie 有什么区别","titles":["计算机网络","Http和Https"]},"531":{"title":"gin框架如何实现，我说用go内置的net http包实现的","titles":["Go语言相关","框架问题"]},"532":{"title":"数据库表是如何设计的","titles":["Mysql","设计"]},"533":{"title":"301，302 有什么区别","titles":["计算机网络","Http和Https"]},"534":{"title":"了解中间件吗?有什么好处","titles":["Go语言相关","框架问题"]},"535":{"title":"其他问题","titles":["Mysql"]},"536":{"title":"url 访问过程","titles":["计算机网络","Http和Https"]},"537":{"title":"etcd 原理（讲了下raft协议）","titles":["Go语言相关","框架问题"]},"538":{"title":"数据库完整性的实现","titles":["Mysql","其他问题"]},"539":{"title":"HTTP 和 HTTPS 的区别，CA 证书，数字签名，SSL 层握手过程，RSA。","titles":["计算机网络","Http和Https"]},"540":{"title":"RPC","titles":["Go语言相关","框架问题"]},"541":{"title":"主键","titles":["Mysql","其他问题"]},"542":{"title":"http断点续传","titles":["计算机网络","Http和Https"]},"543":{"title":"new 和 make区别","titles":["Go语言相关"]},"544":{"title":"介绍mysql","titles":["Mysql","其他问题"]},"545":{"title":"其他问题","titles":["计算机网络"]},"546":{"title":"为什么要使用 Go 语言？Go 语言的优势在哪里？","titles":["Go语言相关"]},"547":{"title":"数据库中有两个关联列，请问在搜索时，这两个关联列会怎样？","titles":["Mysql","其他问题"]},"548":{"title":"计算机在设置ip的时候会设置哪些参数","titles":["计算机网络","其他问题"]},"549":{"title":"go func 使用注意点：博大群里面提出的问题","titles":["Go语言相关"]},"550":{"title":"Mysql怎么去查询的，什么时候走索引，什么时候不走","titles":["Mysql","其他问题"]},"551":{"title":"自己简历上写的：ICMP","titles":["计算机网络","其他问题"]},"552":{"title":"go语言中的坑 （泫提出的）","titles":["Go语言相关"]},"553":{"title":"Mysql了解什么，有没有搭过mysql、redis","titles":["Mysql","其他问题"]},"554":{"title":"arp协议","titles":["计算机网络","其他问题"]},"555":{"title":"数据库的部署怎么做","titles":["Mysql","其他问题"]},"556":{"title":"说说你所知道的网络定时器的机制","titles":["计算机网络","其他问题"]},"557":{"title":"读写分离具体怎么做","titles":["Mysql","其他问题"]},"558":{"title":"DNS协议","titles":["计算机网络","其他问题"]},"559":{"title":"数据库优化+缓存（缓存的不一致，binlog解析器），读写分离，分库分表","titles":["Mysql","其他问题"]},"560":{"title":"DNS 是什么？DNS 的查询过程？","titles":["计算机网络","其他问题"]},"561":{"title":"mysql怎么存储时间","titles":["Mysql","其他问题"]},"562":{"title":"ICMP 这个协议他位于网络的第几层知道吧","titles":["计算机网络","其他问题"]},"563":{"title":"mysql把邮戳转化为日常格式时间的函数","titles":["Mysql","其他问题"]},"564":{"title":"那链路层的协议有哪些啊","titles":["计算机网络","其他问题"]},"565":{"title":"sql慢查询","titles":["Mysql","其他问题"]},"566":{"title":"讲讲ping命令用到了哪些协议","titles":["计算机网络","其他问题"]},"567":{"title":"如果一个表查询，插入等很慢，你怎么做？","titles":["Mysql","其他问题"]},"568":{"title":"还没有整理的","titles":["计算机网络"]},"569":{"title":"mysql 分布式id（项目用到的）","titles":["Mysql","其他问题"]},"570":{"title":"同样问到了 url 访问原理，但是很细节，比如 dns 的原理，在路由器上找的时候，有哪几 种情况","titles":["计算机网络","还没有整理的","讲讲ping命令用到了哪些协议"]},"571":{"title":"sql语句：查询所有课程分数都大于或等于80分的学生姓名","titles":["Mysql","其他问题"]},"572":{"title":"http 跟 tcp 是什么关系","titles":["计算机网络","还没有整理的","讲讲ping命令用到了哪些协议"]},"573":{"title":"写个sql语句，两张表，学生表，学生课程表，求平均分大于85的学生的姓名","titles":["Mysql","其他问题"]},"574":{"title":"sql语句：表【学生|科目|成绩】查询每个学生成绩最好的科目和成绩 ( 没完全写出来","titles":["Mysql","其他问题"]},"575":{"title":"mysql 和 mongodb 的区别，什么时候用 mysql，什么时候用 mongo（因为简历上 有写 mongodb）","titles":["Mysql","其他问题"]},"576":{"title":"给定一张表 user(id,name,age)","titles":["Mysql","其他问题"]},"577":{"title":"一个教务系统，包括学生信息，课程信息，考试安排，成绩查询，绩点分析，你来设 计数据库表应该怎么设计？","titles":["Mysql","其他问题"]},"578":{"title":"char 和 varchar","titles":["Mysql","其他问题"]},"579":{"title":"SQL，一个表 User，字段 userid，username，city 查询用户数量最多的三个城市。","titles":["Mysql","其他问题"]},"580":{"title":"MySQL 的自增主键和随机生成主键的区别，为什么自增主键效率高。","titles":["Mysql","其他问题"]},"581":{"title":"如何查看数据库表结构？","titles":["Mysql","其他问题"]},"582":{"title":"如何提高 SQL 查询效率，在语句方面上的优化？","titles":["Mysql","其他问题"]},"583":{"title":"一条 sql 语句是如何执行的？进行更新时又是怎么处理的？","titles":["Mysql","其他问题"]},"584":{"title":"日志相关：redolog，binlog，undolog，这些日志的实现原理，为了解决怎么问题？日志也是非常重要的吧，面试也问的挺多。","titles":["Mysql","其他问题"]},"585":{"title":"数据库的主从备份、如何保证数据不丢失、如何保证高可用等等。","titles":["Mysql","其他问题"]},"586":{"title":"如何保证多个服务器的数据一致性","titles":["Mysql"]},"587":{"title":"建立一张数据库表需要考虑哪些因素，索引的底层实现，是否了解过b+树之外的索引结构。","titles":["Mysql"]}},"dirtCount":0,"index":[["妈耶我真的好菜",{"2":{"587":1}}],["妈呀这啥",{"2":{"525":1}}],["太多怎么办",{"2":{"587":1}}],["现有一个新的查询场景",{"2":{"587":1}}],["现在就是",{"2":{"583":1}}],["现在就来回答一下",{"2":{"390":1}}],["现在需要支持深分页",{"2":{"59":1}}],["现在",{"2":{"35":1}}],["显示热门评论",{"2":{"587":1}}],["显然",{"2":{"580":1}}],["质疑我没有考虑高并发时的同步和效率问题",{"2":{"587":1}}],["刷盘",{"2":{"587":1}}],["刷进盘",{"2":{"587":1}}],["刷进",{"2":{"587":1}}],["秒杀业务",{"2":{"586":1}}],["宕机时",{"2":{"584":1}}],["宕机的时候可以从redo",{"2":{"303":1}}],["得到新的一行数据",{"2":{"583":1}}],["得到最后",{"2":{"267":1}}],["得到最后的",{"2":{"267":1}}],["普通索引占用的空间也就越小",{"2":{"580":1}}],["普通索引的叶子节点就越小",{"2":{"580":1}}],["共同关注数",{"2":{"578":1}}],["共享锁",{"0":{"482":1}}],["共享的资源有",{"2":{"221":1}}],["共享内存和协程通信",{"2":{"400":1}}],["共享内存",{"2":{"179":3}}],["绩点分析",{"0":{"577":1}}],["课程信息",{"0":{"577":1}}],["学生|科目|成绩",{"0":{"574":1}}],["学生课程表",{"0":{"573":1}}],["学生表",{"0":{"573":1}}],["学生分数",{"0":{"114":1}}],["寻址等",{"2":{"572":1}}],["寻址和分段",{"2":{"172":1}}],["带外数据如何使用",{"2":{"572":1}}],["延迟",{"2":{"572":1}}],["意义何在",{"2":{"572":1}}],["意味着其搜索复杂度为",{"2":{"390":1}}],["超时吗",{"2":{"572":1}}],["超时重传",{"2":{"268":1}}],["何确定文件是否发送完成",{"2":{"572":1}}],["何时使用索引",{"0":{"446":1}}],["握手和挥手",{"2":{"572":1}}],["据失序的辨识",{"2":{"572":1}}],["跟",{"0":{"572":1}}],["种情况",{"0":{"570":1}}],["局部",{"2":{"560":2}}],["局部堆是独享的",{"2":{"221":1}}],["递归解析",{"2":{"560":1}}],["向客户机所设定的局部",{"2":{"560":1}}],["向上取整",{"2":{"375":2}}],["本地和直接解析",{"2":{"560":1}}],["本地解析",{"2":{"560":1}}],["本文我们介绍了内置函数",{"2":{"543":1}}],["本文我们首先分别介绍二者",{"2":{"543":1}}],["拿到的node是不能修改的",{"2":{"552":1}}],["泫提出的",{"0":{"552":1}}],["欢迎大家补充",{"2":{"549":1}}],["博大",{"2":{"549":1}}],["博大群里面提出的问题",{"0":{"549":1}}],["匿名函数内的遍历是否逃逸",{"2":{"549":1}}],["匿名管道由于没有名字",{"2":{"179":1}}],["匿名管道",{"2":{"179":1}}],["闭包引用",{"2":{"549":1}}],["跨平台编译",{"2":{"546":1}}],["介绍mysql",{"0":{"544":1}}],["介绍一下",{"2":{"59":1}}],["仅用于初始化",{"2":{"543":1}}],["仅用作分配内存空间",{"2":{"543":1}}],["仅仅表示客户端不再发送数据了但是还能接受数据",{"2":{"256":1}}],["缓冲容量",{"2":{"543":1}}],["缓存机制了解吗",{"2":{"572":1}}],["缓存的不一致",{"0":{"559":1}}],["缓存击穿",{"2":{"320":1}}],["缓存穿透",{"2":{"320":1}}],["缓存雪崩怎么解决",{"0":{"320":1}}],["缓存雪崩",{"2":{"308":1,"314":1}}],["缓存和数据库一致性更新原则",{"2":{"222":1}}],["缓存一致性问题",{"2":{"185":1}}],["缓存应用",{"0":{"308":1},"1":{"314":1},"2":{"138":1}}],["缓存",{"0":{"491":1},"2":{"77":1,"308":1}}],["初始化时无需指定容量的大小",{"2":{"543":1}}],["初始化",{"2":{"543":3}}],["官方介绍是内置函数",{"2":{"543":1}}],["官方的介绍是",{"2":{"543":1}}],["官方网站",{"2":{"382":1}}],["框架问题",{"0":{"528":1},"1":{"531":1,"534":1,"537":1,"540":1}}],["框架差不多",{"0":{"209":1}}],["女儿只吃橘子",{"2":{"525":1}}],["儿子只吃苹果",{"2":{"525":1}}],["盘子里面只能放",{"2":{"525":1}}],["母亲生产橘子",{"2":{"525":1}}],["父亲生产苹果",{"2":{"525":1}}],["父进程只管生成新的子进程",{"2":{"229":1}}],["物理地址和虚地址",{"2":{"525":1}}],["物理层作用",{"0":{"145":1}}],["物理层的作用是实现计算机节点之间比特流的透明传送",{"2":{"129":1}}],["物理层",{"2":{"129":1}}],["碰撞攻击",{"2":{"525":1}}],["软中断记不得了",{"2":{"525":1}}],["软中断与硬中断",{"2":{"525":1}}],["硬中断记得是外设硬件产生",{"2":{"525":1}}],["硬盘",{"2":{"469":1,"473":1}}],["态",{"2":{"525":1}}],["于是",{"2":{"525":1}}],["于是就有",{"2":{"268":1}}],["记不清了",{"2":{"525":1}}],["记录的是每行实际数据的变更",{"2":{"285":1}}],["记录的是修改sql语句",{"2":{"285":1}}],["临时变量存放在哪里",{"0":{"521":1}}],["临界区",{"2":{"221":1}}],["临界区控制",{"0":{"157":1}}],["拷贝构造",{"0":{"508":1}}],["拷贝的是数据地址",{"2":{"500":1}}],["拷贝的是数据本身",{"2":{"500":1}}],["举几个例子",{"0":{"504":1}}],["幂等是指多次执行相同的操作结果都是相同的",{"2":{"503":1}}],["磁盘寻道算法",{"0":{"509":1}}],["磁盘转一次要多久",{"0":{"501":1}}],["磁盘io的任务都是io密集型任务",{"2":{"473":1}}],["浅拷贝",{"2":{"500":1,"552":1}}],["浅谈mysql数据库中的锁与事务",{"2":{"240":1}}],["新对象值修改时老对象也会变化",{"2":{"500":1}}],["新对象值修改时不会影响原对象值",{"2":{"500":1}}],["新创建的对象在内存中开辟一个新的内存地址",{"2":{"500":1}}],["新创建的对象与原对象不共享内存",{"2":{"500":1}}],["创造一个样的新对象",{"2":{"500":1}}],["创建线程和进程的开销指什么",{"2":{"525":1}}],["创建状态",{"2":{"190":1}}],["创建和撤销线程比进程开销小很多",{"2":{"153":1}}],["深拷贝",{"2":{"500":1,"552":1}}],["深度解密go语言之slice",{"2":{"120":1}}],["顶级域名",{"2":{"495":1}}],["密码",{"2":{"495":1}}],["强制缓存",{"0":{"491":1}}],["逃逸分析讲一下",{"0":{"488":1}}],["模拟",{"2":{"572":1}}],["模型",{"2":{"525":1}}],["模型将",{"2":{"172":1}}],["模式为",{"2":{"483":2}}],["左开右闭",{"2":{"482":1}}],["左子树包含小于最小元素的元素",{"2":{"426":1}}],["左子树包含小于较小元素的元素",{"2":{"426":1}}],["左子树包含的元素小于该元素",{"2":{"426":1}}],["失败",{"2":{"482":4}}],["成绩查询",{"0":{"577":1}}],["成功",{"2":{"482":1}}],["成为首选",{"2":{"45":1}}],["排他锁",{"0":{"482":1}}],["各种锁相关",{"0":{"482":1}}],["各种排序算法及其效率",{"0":{"17":1}}],["脚本语言是首选",{"2":{"473":1}}],["花在cpu上的时间很少",{"2":{"473":1}}],["任务越多",{"2":{"473":1}}],["任务的大部分时间都在等待io操作完成",{"2":{"473":1}}],["任一射线穿过多边形",{"0":{"82":1}}],["客户端浏览器读取响应数据html",{"2":{"483":1}}],["客户端被动关闭连接",{"2":{"483":1}}],["客户端的浏览器根据双方同意的安全等级",{"2":{"471":1}}],["客户端的服务端开始协商ssl连接的安全等级",{"2":{"471":1}}],["客户端请求断开连接的时候数据没有传输完吗",{"0":{"334":1}}],["传入的",{"2":{"572":1}}],["传入的参数是类型",{"2":{"543":1}}],["传递的是指针的复制",{"2":{"516":1}}],["传送一份给客户端",{"2":{"471":1}}],["传输控制协议",{"2":{"129":1,"172":1}}],["传输层定义了两个主要协议",{"2":{"172":1}}],["传输层的主要任务是为两台主机进程之间的通信提供服务",{"2":{"129":1}}],["传输层",{"2":{"129":1,"172":1,"184":1}}],["证书",{"0":{"539":1}}],["证书中包含公钥",{"2":{"471":1}}],["证书权威机构",{"2":{"455":1}}],["便于部署",{"2":{"546":1}}],["便于区间查找和遍历",{"2":{"375":2}}],["便是属于cpu",{"2":{"469":1}}],["逻辑判断等cpu动作的程序称之cpu",{"2":{"469":1}}],["签名",{"2":{"467":1}}],["涉及到网络",{"2":{"473":1}}],["涉及到的知识点",{"0":{"467":1}}],["涉3树是这样的一颗多路查找树",{"0":{"426":1}}],["申请数字证书",{"2":{"455":1}}],["申请的时候可以先申请资源序号小的",{"2":{"401":1}}],["信息是明文传输",{"2":{"455":1}}],["信号是一种比较复杂的通信方式",{"2":{"179":1}}],["信号",{"2":{"179":1}}],["信号量的意图在于进程间同步",{"2":{"179":1}}],["信号量是一个计数器",{"2":{"179":1}}],["信号量",{"2":{"179":3,"525":1}}],["光栅化",{"2":{"451":1}}],["光栅化和合成",{"2":{"451":1}}],["轴排序等",{"2":{"451":1}}],["变换",{"2":{"451":1}}],["依据",{"2":{"451":1}}],["绘制",{"2":{"451":2}}],["布局阶段",{"2":{"451":2}}],["布隆过滤器",{"2":{"320":1}}],["布隆过滤器讲一下",{"0":{"22":1}}],["样式计算",{"2":{"451":2}}],["构建",{"2":{"451":2}}],["构建请求",{"2":{"439":1}}],["渲染引擎还需要为特定的节点生成专用的图层",{"2":{"451":1}}],["渲染阶段比较复杂",{"2":{"451":1}}],["渲染进程将开始页面解析和子资源加载",{"2":{"451":1}}],["渲染进程会返回",{"2":{"447":1}}],["渲染进程收到消息后",{"2":{"447":1}}],["渲染进程准备好后",{"2":{"447":1}}],["唯一索引",{"0":{"450":1}}],["唯一索引扫描",{"2":{"390":1}}],["聚族索引",{"0":{"450":1}}],["聚簇索引",{"0":{"345":1},"2":{"345":2}}],["页锁",{"2":{"462":1}}],["页面滚动",{"2":{"451":1}}],["页面中有很多复杂的效果",{"2":{"451":1}}],["页面渲染阶段",{"0":{"451":1}}],["页面置换算法",{"0":{"449":1},"2":{"449":4}}],["页面是空白页",{"2":{"447":1}}],["页面",{"2":{"447":1}}],["页码直接跳转",{"2":{"59":1}}],["文档一旦提交",{"2":{"451":1}}],["文档数据传输完成后",{"2":{"447":1}}],["文件",{"2":{"560":1}}],["文件通信了解过么",{"2":{"525":1}}],["文件后缀",{"2":{"495":1}}],["文件名",{"2":{"495":1}}],["文件管理",{"2":{"461":1}}],["文件等公用资源",{"2":{"221":1}}],["文件操作",{"2":{"153":1}}],["文件里有100万条url",{"0":{"139":1}}],["虚拟内存和物理内存的区别",{"2":{"525":1}}],["虚拟内存是什么",{"0":{"453":1},"2":{"525":2}}],["虚拟内存",{"0":{"445":1}}],["虚拟地址空间被划分为用户空间和内核空间",{"2":{"153":1}}],["准备渲染进程阶段",{"0":{"443":1}}],["准备案例",{"0":{"214":1}}],["解析返回域名对应的",{"2":{"439":1}}],["解析",{"2":{"439":1,"483":1}}],["解决方案",{"2":{"320":3}}],["解决脏读",{"2":{"315":2}}],["解决脏读问题",{"2":{"315":1}}],["解决措施",{"2":{"308":1}}],["解决这个问题的方案有两种",{"2":{"285":1}}],["解决的问题以及出现的问题",{"2":{"279":1}}],["解决幻读的办法是锁住记录之间的",{"2":{"267":1}}],["按赞数倒序排序",{"2":{"587":1}}],["按下回车键",{"2":{"435":1}}],["按照渲染的时间顺序可以分为",{"2":{"451":1}}],["按照字典序排序后",{"0":{"365":1}}],["按照实现方式分",{"2":{"345":1}}],["按照图中标注的数字",{"2":{"192":1}}],["按照前序遍历的顺序打印每个节点",{"0":{"100":1}}],["规则",{"2":{"435":1}}],["默认采用值传递",{"2":{"516":1}}],["默认全部都是浅复制",{"2":{"500":1}}],["默认全部都是深复制",{"2":{"500":1}}],["默认",{"2":{"439":2}}],["默认搜索引擎合成新的",{"2":{"435":1}}],["默认的内存淘汰策略",{"2":{"202":2}}],["合成线程就会生成一个绘制图块的命令",{"2":{"451":1}}],["合成",{"2":{"435":1,"451":1}}],["垃圾回收",{"0":{"428":1}}],["节点最大的孩子数目称为b树的阶",{"2":{"426":1}}],["节流以及缓冲区大小受限等缺",{"2":{"179":1}}],["右子树包含大于最大元素的元素",{"2":{"426":1}}],["右子树包含大于较大元素的元素",{"2":{"426":1}}],["右子树包含的元素大于该元素",{"2":{"426":1}}],["右子树也分别为二叉排序树",{"2":{"63":1}}],["且go",{"2":{"516":1}}],["且多次提交之后就会新建多个资源",{"2":{"503":1}}],["且与二叉排序树类似",{"2":{"426":1}}],["且叶子结点本身依关键字的大小自小而大顺序链接",{"2":{"345":1}}],["容量",{"2":{"543":1}}],["容量为",{"2":{"543":1}}],["容易队头阻塞",{"2":{"407":1}}],["容器可否完全替代数组",{"2":{"45":1}}],["破坏保持等待",{"2":{"405":1}}],["破坏循环等待",{"2":{"405":1}}],["破坏互斥",{"2":{"405":1}}],["杀死进程恢复",{"2":{"405":1}}],["采用多进程开发",{"2":{"473":1}}],["采用了",{"2":{"279":1}}],["采取行动解决问题",{"2":{"405":1}}],["鸵鸟算法",{"2":{"405":1}}],["忽略死锁带来的影响",{"2":{"405":1}}],["浏览器刷新界面",{"0":{"523":1}}],["浏览器首先解析状态行",{"2":{"483":1}}],["浏览器首先会向服务器发送请求行",{"2":{"439":1}}],["浏览器向服务器发送一个文本的请求报文",{"2":{"483":1}}],["浏览器与",{"2":{"483":1}}],["浏览器收到",{"2":{"447":1}}],["浏览器会发出",{"2":{"447":1}}],["浏览器会根据用户输入的信息判断是搜索还是网址",{"2":{"435":1}}],["浏览器进程首先会构建请求行信息",{"2":{"439":1}}],["浏览器导航栏显示",{"2":{"435":1}}],["浏览器就会根据",{"2":{"435":1}}],["浏览器每次请求都需要与服务器建立一个tcp连接",{"2":{"403":1}}],["浏览器支持的语言",{"2":{"387":1}}],["循环等待",{"2":{"401":1}}],["循环比较链表结点与栈顶的大",{"0":{"186":1}}],["必然会存在一个线程",{"2":{"401":1}}],["必须使用内置函数",{"2":{"543":1}}],["必须有足够的理由",{"2":{"522":1}}],["必须要从头传到尾",{"2":{"399":1}}],["必须对方告诉说收到消息才算收到消息",{"2":{"274":1}}],["抢占使用",{"2":{"401":1}}],["释放内存地址时",{"2":{"500":2}}],["释放tcp连接",{"2":{"483":1}}],["释放",{"2":{"401":1,"483":1}}],["释放它们占用的系统进程表中的资源",{"2":{"229":1}}],["互斥必须满足",{"2":{"401":1}}],["互斥",{"2":{"401":1}}],["互相发的时候如何确定消息发过去呢",{"2":{"274":1}}],["队头阻塞",{"2":{"399":1,"403":1}}],["队头组死啊",{"2":{"399":1}}],["队列",{"0":{"341":1},"2":{"28":1,"439":1}}],["减少慢启动的影响",{"2":{"399":1}}],["减少握手次数",{"2":{"399":1}}],["减少tcp重复建立以及关闭的开销",{"2":{"399":1}}],["长度",{"2":{"543":1}}],["长度可能不等",{"0":{"329":1}}],["长连接讲一下",{"2":{"572":1}}],["长连接",{"2":{"407":1}}],["长连接的好处",{"2":{"399":1}}],["短连接将会在发完response就会关闭连接了",{"2":{"399":1}}],["期望获取现场",{"2":{"397":1}}],["期望获取线程",{"2":{"397":1}}],["持有并等待",{"2":{"401":2}}],["持有",{"2":{"401":1}}],["持有的资源",{"2":{"397":2}}],["持久性",{"2":{"261":1,"303":1}}],["持久性durability",{"2":{"261":1}}],["持久化没答上来",{"0":{"246":1}}],["持久化有哪几种",{"0":{"246":1}}],["持久化",{"0":{"238":1},"1":{"246":1,"253":1,"260":1,"266":1}}],["死锁及如何避免",{"2":{"525":1}}],["死锁避免",{"0":{"425":1}}],["死锁检测与恢复",{"0":{"425":1}}],["死锁预防",{"0":{"425":1}}],["死锁的处理策略",{"0":{"425":1}}],["死锁的预防",{"0":{"421":1}}],["死锁的必要条件",{"0":{"417":1}}],["死锁以及怎样避免",{"0":{"413":1}}],["死锁发生的时候对其进行检测",{"2":{"405":1}}],["死锁产生的四个必要条件",{"0":{"401":1}}],["死锁一般发生在多线程",{"2":{"397":1}}],["死锁",{"0":{"397":1}}],["区间都被锁定了无法插入",{"2":{"482":1}}],["区分度公式",{"2":{"390":1}}],["区分度就是某个字段",{"2":{"390":1}}],["区别在哪",{"2":{"525":1}}],["区别",{"0":{"241":1,"489":1},"2":{"153":1,"235":1,"525":1,"572":2}}],["区别是数组支持随机访问",{"2":{"28":1}}],["越详细越好",{"0":{"495":1}}],["越靠前的字段被用于索引过滤的概率越高",{"2":{"390":1}}],["越往下效率越低",{"2":{"273":1}}],["联合索引在b树",{"0":{"406":1}}],["联合索引的使用原则",{"0":{"402":1}}],["联合索引时",{"2":{"390":1}}],["联合索引",{"2":{"390":1}}],["名称",{"2":{"390":1}}],["价格作为一个组合索引",{"2":{"390":1}}],["价格",{"2":{"390":1}}],["覆盖索引指的是在一次查询中",{"2":{"434":1}}],["覆盖索引是指",{"2":{"390":1}}],["覆盖索引优化",{"2":{"390":1}}],["参数=值",{"2":{"495":1}}],["参数有",{"2":{"390":1}}],["参考小林图解网络",{"2":{"399":1}}],["参考cyc2018基础知识面试中的cookie",{"2":{"507":1}}],["参考cyc2018",{"2":{"395":1}}],["参考资料",{"0":{"385":1}}],["参考腾讯技术工程知乎文章",{"2":{"370":1}}],["参考视频",{"2":{"274":2}}],["参考自己的os打印的那个笔记书",{"2":{"201":1}}],["参考模型中的物理层和数据链路层",{"2":{"172":1}}],["参考模型中的会话层",{"2":{"172":1}}],["参考模型的网络层",{"2":{"172":1}}],["参考模型的传输层",{"2":{"172":1}}],["参考5",{"2":{"153":1}}],["参考4",{"2":{"150":1,"153":1,"164":1}}],["参考3",{"2":{"150":1,"153":1,"164":1}}],["参考2",{"2":{"120":1,"150":1,"153":1,"164":1}}],["参考1",{"2":{"120":1,"150":1,"164":1}}],["参考列表",{"2":{"104":1}}],["参考",{"0":{"240":1},"2":{"72":1,"120":1,"150":1,"153":1,"154":4,"179":1,"201":2,"213":1,"221":1,"227":1,"229":2,"235":1,"262":1,"270":2,"276":1,"282":1,"288":1,"291":1,"300":2,"303":1,"306":1,"318":1,"333":2,"343":1,"346":1,"363":1,"364":1,"399":1,"406":1,"431":1,"458":1,"466":1,"485":1,"543":1,"551":1}}],["高出不少",{"2":{"390":1}}],["高可靠",{"0":{"224":1}}],["高可用",{"0":{"272":1},"1":{"278":1,"284":1,"290":1,"296":1,"302":1},"2":{"138":1}}],["适合",{"2":{"390":1}}],["适用于两种情况",{"2":{"357":1}}],["商品编码",{"2":{"390":1}}],["辅助索引",{"2":{"390":1}}],["详细属性见文后附表",{"2":{"387":1}}],["告诉服务器一些浏览器的相关信息",{"2":{"439":1}}],["告诉服务器是从哪个网站链接过来的",{"2":{"387":1}}],["告诉服务器可以接受的文件格式",{"2":{"387":1}}],["告诉浏览器它发送的数据属于什么文件类型",{"2":{"387":1}}],["响应报文格式",{"0":{"395":1}}],["响应可被任何缓存区缓存",{"2":{"387":1}}],["响应体的长度",{"2":{"387":1}}],["响应头告知以下为若干字节的html文档和文档的字符集",{"2":{"483":1}}],["响应头部",{"2":{"483":1}}],["响应头",{"2":{"387":2}}],["响应状态码",{"2":{"387":1}}],["域名解析~呜呜",{"2":{"536":1}}],["域名",{"2":{"387":1,"495":1}}],["核心技术与实战",{"2":{"385":1}}],["核心分为四个组件",{"2":{"230":1}}],["答扩容",{"2":{"587":1}}],["答了",{"2":{"516":1}}],["答错了",{"2":{"382":1}}],["答案是",{"2":{"401":1}}],["答案参考",{"2":{"364":1}}],["答案就是把产生大量僵尸进程的那个元凶枪毙掉",{"2":{"229":1}}],["瓶颈点在哪里",{"0":{"380":1}}],["qq",{"2":{"584":3,"587":1}}],["q2hly2sgsw50zwdyaxr5iq==",{"2":{"387":1}}],["qps",{"0":{"380":1}}],["query",{"2":{"390":1}}],["queuing",{"2":{"179":1}}],["question",{"0":{"82":1}}],["quot",{"0":{"99":4,"472":2},"2":{"2":2,"153":4,"230":2,"482":8,"552":4}}],["矮胖",{"2":{"375":1}}],["棵子树",{"2":{"375":2}}],["叶子节点采用的是双链表连接",{"2":{"390":1}}],["叶子节点包含了这棵树的所有数据",{"2":{"375":1}}],["叶子结点row数据",{"2":{"345":1}}],["横向纵向均递增的矩阵找指定数",{"0":{"371":1}}],["既然内存地址不同",{"2":{"500":1}}],["既然mysql索引是b+树",{"2":{"369":1}}],["既然所有进程都必须在退出之后被wait",{"2":{"229":1}}],["占用部分资源的线程进一步申请其他资源时",{"2":{"401":1}}],["占用",{"2":{"401":1}}],["占用很大内存怎么理解",{"2":{"369":1}}],["占用的内存不会及时得到释放",{"2":{"213":1}}],["追问",{"2":{"369":3}}],["试官说主要还是考察思路和逻辑",{"2":{"365":1}}],["纯手打",{"2":{"364":1}}],["甚至能比非对称加密慢上1000倍",{"2":{"463":1}}],["甚至有可能会导致tcp报文没有带宽可用",{"2":{"364":1}}],["甚至是底层数据结构和算法等",{"2":{"103":1}}],["视频面用的是",{"2":{"572":1}}],["视频面用的是tcp还是udp",{"0":{"364":1}}],["视图",{"2":{"103":1}}],["步又回到",{"0":{"359":1}}],["经过解析器后输出一个以",{"2":{"451":1}}],["经过",{"0":{"359":1}}],["编号如何存",{"2":{"572":1}}],["编号为",{"0":{"359":1}}],["编译有哪些阶段",{"2":{"525":1}}],["编码转换",{"2":{"154":1}}],["编码类型",{"2":{"154":1}}],["次握手",{"2":{"572":1}}],["次数要更多",{"2":{"390":1}}],["次数下",{"2":{"390":1}}],["次的磁盘",{"2":{"390":1}}],["次的磁盘i",{"2":{"357":1}}],["次以下",{"0":{"53":1}}],["哥哥和妹妹都按照最优策略轮流随机抽取一张",{"0":{"353":1}}],["稳定性方面的差别",{"0":{"352":1}}],["零钱问题",{"0":{"347":1}}],["回",{"2":{"587":1}}],["回滚到了第2步",{"2":{"583":1}}],["回滚到了哪一步",{"2":{"583":1}}],["回表",{"2":{"345":1}}],["回答的时候谦虚一点",{"2":{"203":1}}],["回答方式",{"2":{"203":1}}],["别人的",{"2":{"345":1}}],["折叠法",{"2":{"345":1}}],["平衡二叉树",{"2":{"426":1}}],["平方取中法",{"2":{"345":1}}],["平均分到不同节点上",{"2":{"320":1}}],["平均情况时间复杂度为",{"2":{"69":1}}],["散列表",{"2":{"345":1}}],["简介与优点",{"2":{"572":1}}],["简称ua",{"2":{"387":1}}],["简要说下",{"2":{"345":1}}],["简单介绍",{"0":{"460":1}}],["简单讲就是聚簇索引相当于物理内存地址",{"2":{"345":1}}],["简单讲",{"2":{"297":1}}],["简单理解是两次读取的数据中间被修改",{"2":{"267":1}}],["简单的说就是通信的两方的一种约定",{"2":{"179":1}}],["简单动态字符串",{"2":{"8":1}}],["哈希索引",{"2":{"345":1}}],["哈希对象",{"2":{"6":2,"7":1}}],["查",{"2":{"587":1}}],["查看表明请求是否成功的状态代码",{"2":{"483":1}}],["查找缓存",{"2":{"439":1}}],["查找过程可以理解为",{"2":{"406":1}}],["查找过程你了解过么",{"0":{"406":1}}],["查询效率",{"0":{"582":1}}],["查询用户数量最多的三个城市",{"0":{"579":1}}],["查询每个学生成绩最好的科目和成绩",{"0":{"574":1}}],["查询所有课程分数都大于或等于80分的学生姓名",{"0":{"571":1}}],["查询的name无法从索引数据获取",{"2":{"434":1}}],["查询将不会再次检索主键索引",{"2":{"390":1}}],["查询商品数据的过程",{"2":{"390":1}}],["查询快",{"2":{"345":1}}],["查询性能最快",{"2":{"345":1}}],["查到是空的",{"2":{"285":1}}],["底层的数据结构就是哈希表",{"2":{"345":1}}],["底层的跳跃表怎么实现的",{"2":{"154":1}}],["谈谈索引的数据结构",{"2":{"345":1}}],["谈谈二分查找",{"0":{"242":1}}],["非主键列只依赖于主键",{"2":{"522":1}}],["非主键列完全依赖于主键",{"2":{"522":1}}],["非阻塞是指调用线程或者进程不会被操作系统挂起",{"2":{"481":1}}],["非对称密钥",{"2":{"467":1}}],["非对称密钥加密",{"2":{"467":1}}],["非对称加密的优势在于它可以很好帮助完成秘钥的交换",{"2":{"463":1}}],["非对称加密加密解密算法效率较低",{"2":{"463":1}}],["非对称加密",{"0":{"459":1}}],["非常重要",{"0":{"450":1}}],["非聚族索引",{"0":{"450":1}}],["非聚簇索引",{"0":{"345":1}}],["非唯一索引扫描",{"2":{"390":1}}],["非负",{"2":{"387":1}}],["非根节点",{"2":{"375":2}}],["非叶子结点只存储主键id",{"2":{"345":1}}],["非线性表",{"2":{"28":1}}],["树无法做到这一点",{"2":{"390":1}}],["树查询到对应的叶子节点",{"2":{"390":1}}],["树和二叉树来说",{"2":{"390":1}}],["树中依然存在许多不可见的元素",{"2":{"451":1}}],["树中每个节点的具体样式",{"2":{"451":1}}],["树中",{"2":{"345":1}}],["树的区别以及优点",{"2":{"345":1}}],["树",{"0":{"345":1,"375":1,"383":1},"2":{"390":3,"451":2}}],["树了解吗",{"2":{"59":1}}],["功能是怎么实现的",{"0":{"344":1}}],["张牌分牌",{"0":{"341":1}}],["送给tcp",{"2":{"340":1}}],["七元组是",{"2":{"340":1}}],["五元组是",{"2":{"340":1}}],["五层协议",{"0":{"116":1},"1":{"129":1,"145":1,"159":1,"172":1,"184":1,"195":1,"206":1,"217":1,"225":1}}],["理论将其",{"2":{"586":1}}],["理",{"2":{"335":1}}],["理解",{"2":{"273":1}}],["理解了线程的用户栈和内核栈",{"2":{"153":1}}],["结合mvcc和间隙锁可以解决幻读的问题",{"2":{"482":1}}],["结构如下",{"2":{"434":1}}],["结果一百度",{"2":{"516":1}}],["结果只有一条的主键或唯一索引扫描",{"2":{"390":1}}],["结果当场去世",{"2":{"335":1}}],["结点中仅含其子数中的最大",{"2":{"345":1}}],["结束了其生命周期的时候",{"2":{"229":1}}],["结束",{"2":{"29":1}}],["遍历美滋滋",{"2":{"335":1}}],["遍历一遍就完事了",{"0":{"106":1}}],["置换算法所选择的被淘汰页面将是以后永不使用的",{"2":{"449":1}}],["置空",{"2":{"335":1}}],["置为相同的不久行了吗",{"0":{"316":1}}],["认识",{"2":{"335":2}}],["认为数据出现冲突的可能性不大",{"2":{"309":1}}],["认为数据出现冲突的可能性很大",{"2":{"309":1}}],["尴尬了",{"0":{"334":1}}],["谁的数据没有传输完",{"0":{"334":1}}],["维护两个下标变量",{"2":{"329":1}}],["维护了一个进程表",{"2":{"153":1}}],["瞎猜数据没传输完",{"0":{"328":1}}],["明明客户端已经要求断开连接了呀",{"0":{"328":1}}],["断点续传",{"2":{"572":1}}],["断开",{"2":{"439":1}}],["断开连接需要四次挥手",{"0":{"322":1}}],["断路器会造成写入失败",{"2":{"59":1}}],["断路器内部怎么实现的",{"2":{"59":1}}],["防止大量请求打到数据库上",{"2":{"320":1}}],["防火墙",{"0":{"184":1},"2":{"184":1}}],["增强了系统的健壮性",{"2":{"320":1}}],["增删改都会触发",{"2":{"154":1}}],["思考题",{"2":{"320":1}}],["思路",{"0":{"139":1}}],["造成队头阻塞",{"2":{"407":1,"415":1}}],["造成系统不可用",{"2":{"320":1}}],["造成数据库挂掉",{"2":{"320":1}}],["造成了一定的内存空间浪费",{"2":{"213":1}}],["导致tcp饿死",{"2":{"364":1}}],["导致数据库挂掉",{"2":{"320":1}}],["导致请求直接打到数据库上造成数据库崩溃",{"2":{"308":1}}],["打到数据库上",{"2":{"320":1}}],["打开文件句柄表等等",{"2":{"153":1}}],["打开安装包地址下载",{"2":{"4":1}}],["跑定时任务",{"2":{"320":1}}],["让资源的申请和使用有线性顺序",{"2":{"401":1}}],["让这些热点的缓存",{"2":{"320":1}}],["让缓存不要同一时间失效",{"2":{"320":1}}],["让我写出来",{"2":{"318":1}}],["让用户读到更新过程中的数据",{"2":{"261":1}}],["幸亏我事后看了一眼是类似双重检验锁的实现方式哦",{"2":{"318":1}}],["条记录如何取",{"0":{"314":1}}],["条数据放入",{"2":{"45":1}}],["微博刷新选取所有关注人的最新",{"0":{"314":1}}],["卡了很久",{"0":{"311":1}}],["机制",{"2":{"309":1}}],["机器人走路",{"0":{"19":1}}],["乐观锁利用",{"2":{"309":1}}],["乐观锁",{"2":{"309":1}}],["悲观锁一般利用",{"2":{"309":1}}],["悲观锁",{"2":{"309":1}}],["十分钟给你讲的明明白白",{"2":{"308":1}}],["击穿",{"2":{"308":1}}],["穿透",{"2":{"308":1}}],["运算效率高",{"2":{"467":1}}],["运用的优化思想有读写分离",{"2":{"303":1}}],["运输层则向网络层传递该报文段",{"2":{"225":1}}],["运输层收取到报文并附上附加信息",{"2":{"225":1}}],["运输层包括两种协议",{"2":{"129":1}}],["矩阵求最大正方形",{"0":{"299":1}}],["基于",{"2":{"479":1}}],["基于非唯一性索引的检索",{"2":{"357":1}}],["基于一个范围的检索",{"2":{"357":1}}],["基于锁的并发控制",{"2":{"297":1}}],["基本所有存储引擎都支持btree索引",{"2":{"345":1}}],["基本上90",{"2":{"345":1}}],["基本数据结构",{"0":{"84":1},"1":{"96":1,"108":1,"120":1,"134":1,"150":1,"164":1,"176":1,"188":1,"199":1,"210":1,"219":1}}],["迁移",{"0":{"296":1}}],["化",{"2":{"291":1}}],["串行化时",{"2":{"462":1}}],["串行的情况下tcp有一个问题叫队头阻塞",{"2":{"399":1}}],["串行",{"2":{"291":1}}],["整个事务存在期间都用这个视图",{"2":{"291":1}}],["访问原理",{"0":{"570":1}}],["访问过程",{"0":{"536":1}}],["访问的时候以视图的逻辑结果为准",{"2":{"291":1}}],["访问数组的本质就是访问一段连续内存",{"2":{"45":1}}],["添加一个节点如何分配槽",{"0":{"290":1}}],["奈何row格式是在mysql5",{"2":{"285":1}}],["半一致性读",{"2":{"285":1}}],["影响性能",{"2":{"285":1}}],["生产中使用rc隔离级别主要原因如下",{"2":{"285":1}}],["生成了网络层数据报",{"2":{"225":1}}],["日常应用中推荐将隔离级别设计为已提交读",{"2":{"285":1}}],["日常应用中应该使用已提交读还是可重复读",{"0":{"285":1}}],["日志只要看这3篇文章就可以了",{"2":{"584":1}}],["日志也是非常重要的吧",{"0":{"584":1}}],["日志相关",{"0":{"584":1}}],["日志",{"0":{"183":1}}],["哨兵什么作用",{"0":{"284":1}}],["股票买入时机",{"0":{"281":1}}],["序列化",{"2":{"315":1}}],["序列化实现",{"2":{"279":1}}],["序列号不能从0开始",{"2":{"274":1}}],["序列号生成器等",{"2":{"103":1}}],["级别下的mvcc机制有关系",{"2":{"279":1}}],["好处是可以提升并发处理性能",{"2":{"279":1}}],["行锁表锁",{"0":{"478":1,"490":1}}],["行锁还是表锁",{"2":{"466":1}}],["行锁",{"0":{"482":1},"2":{"462":1,"584":1}}],["行锁什么时候变表锁",{"0":{"462":1}}],["行锁解决不了幻读",{"2":{"267":1}}],["行3",{"2":{"308":1}}],["行级排它锁",{"2":{"279":1}}],["行级共享锁",{"2":{"279":1}}],["自增主键往往是更合理的选择",{"2":{"580":1}}],["自增主键的插入数据模式",{"2":{"580":1}}],["自增时取模就行了",{"2":{"329":1}}],["自己总结的笔记",{"2":{"551":1}}],["自己总结的mysql",{"2":{"458":1}}],["自己简历上写的",{"0":{"551":1}}],["自己了解不多",{"0":{"460":1}}],["自己说有效减少磁盘io次数",{"2":{"369":1}}],["自己之前在bilibili看到的极客时间一个老师讲解的视频",{"2":{"274":1}}],["自然就不会出现sql执行顺序不一样的问题",{"2":{"285":1}}],["自定场景",{"0":{"119":1}}],["建立一张数据库表需要考虑哪些因素",{"0":{"587":1}}],["建立会话秘钥",{"2":{"471":1}}],["建立会话需要时间",{"2":{"364":1}}],["建立",{"2":{"439":1}}],["建立联合索引时的字段顺序",{"2":{"390":1}}],["建连接需要3次握手",{"2":{"274":1}}],["建议选择btree索引",{"2":{"345":1}}],["建议收藏",{"2":{"240":1}}],["建议采用一个实例去记",{"2":{"230":1}}],["换句话说",{"2":{"273":1,"279":1}}],["换题了",{"0":{"55":1}}],["允许读取并发事务已经提交的数据",{"2":{"273":1,"279":1}}],["允许读取尚未提交的数据变更",{"2":{"273":1,"279":1}}],["允许接收端运输层向上向适当的应用程序交付报文的信息以及差错检测位信息",{"2":{"225":1}}],["标识为",{"2":{"587":1}}],["标头有什么东西",{"2":{"572":1}}],["标志",{"2":{"495":1}}],["标签里定义的样式",{"2":{"451":1}}],["标签引入的外部样式",{"2":{"451":1}}],["标准定义了四个隔离级别",{"2":{"273":1}}],["标记清除垃圾回收算法的核心思想吗",{"2":{"35":1}}],["泄露的情况有哪些",{"2":{"549":1}}],["泄露",{"2":{"270":1}}],["哪些数据要存放在磁盘",{"2":{"453":1}}],["哪些数据要加载到内存",{"2":{"453":1}}],["哪些数据没收到",{"2":{"268":1}}],["哪些提供出来的数据结构用到了",{"2":{"154":1}}],["选择现有页面中其",{"2":{"449":1}}],["选择性确认",{"2":{"268":1}}],["选了第二道",{"2":{"365":1}}],["选项",{"2":{"268":1}}],["头部和消息体全部采用二进制",{"2":{"411":1}}],["头部压缩",{"2":{"411":1}}],["头部",{"2":{"268":1}}],["头条的文章的评论量非常大",{"2":{"59":1}}],["段",{"2":{"268":1}}],["流量控制",{"2":{"572":1}}],["流量控制和拥塞控制",{"2":{"572":1}}],["流量控制以及拥塞控制等来实现可靠传输",{"2":{"241":1}}],["流媒体等类型",{"2":{"439":1}}],["流程看图",{"2":{"268":1}}],["报文也比tcp小",{"2":{"364":1}}],["报文",{"2":{"268":1}}],["报文时",{"2":{"268":2}}],["报告转发分组出错",{"2":{"195":1}}],["快速重传的工作方式是当收到三个相同的",{"2":{"268":2}}],["快速重传",{"2":{"268":2}}],["快速恢复",{"2":{"268":1}}],["快速地传输",{"2":{"172":1}}],["收到3个重复的ack",{"2":{"268":1}}],["涨到慢启动门限为止",{"2":{"268":1}}],["慢启动",{"2":{"268":1}}],["拥塞窗口要不要把自己的大小发给接收方",{"2":{"572":1}}],["拥塞发生",{"2":{"268":1}}],["拥塞避免",{"2":{"268":1}}],["拥塞控制及对应方法的使用场景",{"2":{"572":1}}],["拥塞控制",{"0":{"268":1}}],["拥有资源",{"2":{"153":1}}],["叫间隙锁",{"2":{"267":1}}],["间隙锁是可重复读级别下才会有的锁",{"2":{"482":1}}],["间隙锁",{"0":{"482":1},"2":{"482":1,"584":1}}],["间隙",{"2":{"267":1}}],["产生了幻觉一样",{"2":{"267":1}}],["刚好是前面",{"2":{"267":1}}],["案例",{"2":{"267":1,"397":1}}],["幻读问题",{"2":{"315":3}}],["幻读或不可重复读",{"2":{"273":1,"279":1}}],["幻读是针对数据插入",{"2":{"267":1}}],["幻读",{"2":{"267":2}}],["幻读及实现原理",{"2":{"240":1}}],["前进后退的历史状态",{"2":{"447":1}}],["前提首先是一颗二叉排序树",{"2":{"426":1}}],["前缀索引有一定的局限性",{"2":{"390":1}}],["前缀索引就是用某个字段中",{"2":{"390":1}}],["前缀索引优化",{"2":{"390":1}}],["前面总结过",{"2":{"358":1}}],["前面也讲到",{"2":{"56":1}}],["前一个rollback了操作",{"2":{"267":1}}],["某个流丢失的时候",{"2":{"415":1}}],["某个事务已更新一份数据",{"2":{"267":1}}],["某一个非常热点的key失效",{"2":{"320":1}}],["某一个业务中现在需要生成全局唯一的递增",{"0":{"149":1}}],["某一时间段",{"2":{"212":1}}],["脏读的解决办法是升级事务隔离级别",{"2":{"267":1}}],["脏读对应的隔离级别是",{"2":{"267":1}}],["脏读",{"2":{"267":2}}],["关于网络异常",{"2":{"572":1}}],["关于内置函数",{"2":{"543":2}}],["关于它们之间的区别",{"2":{"543":1}}],["关于为什么不一直用非对称加密",{"2":{"463":1}}],["关于层叠上下文的知识",{"2":{"451":1}}],["关于很多tcp面试题的总结",{"0":{"262":1}}],["关键字个数的范围为m",{"2":{"375":2}}],["关键字",{"2":{"345":1}}],["关连接为什么需要4次",{"2":{"274":1}}],["关闭连接需要4次握手",{"2":{"274":1}}],["关闭channel读取后会怎样",{"0":{"243":1}}],["读写分离",{"0":{"559":1}}],["读写分离具体怎么做",{"0":{"557":1}}],["读写数据都会锁住整张表",{"2":{"462":1}}],["读写并行",{"2":{"303":1}}],["读读并行",{"2":{"303":1}}],["读提交和可重复读是",{"2":{"584":1}}],["读提交",{"2":{"291":1}}],["读的时候加读锁",{"2":{"279":1}}],["读的时候不加锁",{"2":{"279":1}}],["读的操作不能排斥写请求",{"2":{"279":1}}],["读无锁",{"2":{"279":1}}],["读锁",{"2":{"273":1,"279":1}}],["读",{"2":{"273":1,"279":1}}],["读取表级共享锁直到事务结束释放",{"2":{"279":1}}],["读取共享锁直到事务结束释放",{"2":{"279":1}}],["读取",{"2":{"279":1}}],["读取已提交",{"2":{"273":1}}],["读取未提交",{"2":{"273":1,"279":1}}],["读取到了一个意想不到的数据",{"2":{"267":1}}],["读取数据和写数据的时候都会开启一个线程",{"2":{"230":1}}],["读了一次商品表",{"2":{"267":1}}],["读已提交实现",{"2":{"279":1}}],["读已提交",{"2":{"267":2,"315":1}}],["读未提交实现",{"2":{"279":1}}],["读未提交",{"2":{"267":2,"291":1,"315":1}}],["读到的一定是更新前的数据",{"2":{"261":1}}],["隔离性",{"2":{"261":1,"303":1}}],["隔离性isolation",{"2":{"261":1}}],["隔离级别下直接用加锁的方式来避免并行访问",{"2":{"291":1}}],["隔离级别下直接返回记录上的最新值",{"2":{"291":1}}],["隔离级别下",{"2":{"291":2}}],["隔离级别",{"0":{"128":1},"2":{"103":1,"273":1,"279":1}}],["四元组是",{"2":{"340":1}}],["四次握手",{"2":{"256":1}}],["四次挥手",{"0":{"256":1}}],["四种处理死锁的策略",{"0":{"405":1}}],["四种隔离级别",{"2":{"240":1}}],["四种事务隔离级别的基础知识",{"2":{"103":1}}],["要怎么解决",{"2":{"587":1}}],["要想着检测到泄露要如何优雅地关闭goroutine",{"2":{"549":1}}],["要想解决幻读不能升级事务隔离级别到",{"2":{"267":1}}],["要尽量遵守三范式",{"2":{"522":1}}],["要把区分度大的字段排在前面",{"2":{"390":1}}],["要么具有4个孩子",{"2":{"426":1}}],["要么具有3个孩子",{"2":{"426":1}}],["要么就有两个",{"2":{"426":1}}],["要么失败",{"2":{"261":1}}],["要么成功",{"2":{"261":1}}],["要么都不执行",{"2":{"255":1}}],["要么都执行",{"2":{"255":1}}],["要求建立索引来优化查询",{"2":{"587":1}}],["要求客户机使用",{"2":{"387":1}}],["要求你找到",{"0":{"365":1}}],["要求输出重复时循环跳出",{"2":{"329":1}}],["要求循环输出",{"0":{"329":1}}],["要求进行给它进行排序",{"0":{"186":1}}],["要求时间复杂度低于",{"0":{"175":1}}],["要求对应位置上不能有同下标相同的",{"0":{"162":1}}],["要求",{"2":{"154":1}}],["要求获取",{"0":{"44":1}}],["稍微改一改也就行了",{"2":{"254":1}}],["取代的重要原因之一",{"2":{"248":1}}],["取决于防火墙的种类",{"2":{"184":1}}],["引用类型",{"2":{"543":1}}],["引用类型的数据",{"2":{"500":1}}],["引起tcp传输速度下降",{"2":{"364":1}}],["引擎区别",{"2":{"587":1}}],["引擎把刚刚写入的",{"2":{"583":1}}],["引擎将这行新数据更新到内存中",{"2":{"583":1}}],["引擎通过",{"2":{"267":1}}],["引擎就不支持事务",{"2":{"248":1}}],["引入了新的锁",{"2":{"267":1}}],["引申出quic",{"2":{"370":1}}],["引申出的问题",{"2":{"230":1}}],["引申出来一个面试题",{"2":{"28":1}}],["路径指任意结点到结点之间的最短距离",{"0":{"247":1}}],["路由器收到判断是广播之后并不会转发",{"2":{"195":1}}],["路由器收到后并不会进行转发",{"2":{"195":1}}],["路由器就知道了自己的该接口与哪个网络直连",{"2":{"195":1}}],["路由器取出ip数据报中的首部各地址字段的值",{"2":{"195":1}}],["路由器",{"0":{"184":1},"2":{"184":1}}],["路由器只有下面三层协议",{"2":{"172":1}}],["顺带说了下集群",{"0":{"246":1}}],["崩了说的哨兵",{"0":{"246":1}}],["崩了怎么办",{"0":{"246":1}}],["讲了下raft协议",{"0":{"537":1}}],["讲了下gdb",{"0":{"448":1}}],["讲讲ping命令用到了哪些协议",{"0":{"566":1},"1":{"570":1,"572":1}}],["讲讲mmu",{"0":{"437":1}}],["讲讲可重复读隔离级别",{"0":{"321":1}}],["讲五种例子",{"0":{"436":1}}],["讲也提到了死锁",{"2":{"397":1}}],["讲解并手写",{"0":{"242":1}}],["讲一下所知道的状态码",{"2":{"382":1}}],["讲一下文件事件有哪些",{"0":{"356":1}}],["讲一下",{"0":{"260":1}}],["讲一下redis数据结构",{"2":{"154":1}}],["讲一讲方案",{"2":{"178":1}}],["滑动窗口和",{"2":{"572":1}}],["滑动窗口",{"2":{"241":1,"572":1}}],["双方都可以发送接收",{"2":{"274":1}}],["双方随时都可以发送和接收数据",{"2":{"241":1}}],["双工",{"2":{"274":1}}],["双端链表",{"2":{"8":1}}],["全索引扫描",{"2":{"390":1}}],["全表扫描",{"2":{"390":1}}],["全表扫描和全索引扫描要尽量避免",{"2":{"390":1}}],["全文索引等",{"2":{"345":1}}],["全双工",{"2":{"241":1}}],["全局变量",{"2":{"221":1}}],["支持一对一",{"2":{"241":1}}],["支持万维网应用的",{"2":{"129":1}}],["他说不是这意思",{"2":{"523":1}}],["他说这样破坏了服务器无状态啥的设计原则",{"2":{"519":1}}],["他记录的顺序是先插后删",{"2":{"285":1}}],["他其实不是幻读",{"2":{"240":1}}],["他的数值最",{"0":{"26":1}}],["未读",{"2":{"240":1}}],["未初始化只是一个为长度和容量都为0的一个切片",{"2":{"108":1}}],["未初始化的slice能不能append",{"0":{"108":1}}],["已读",{"2":{"240":1}}],["已经用完了分配的栈空间",{"2":{"546":1}}],["已经获取了资源",{"2":{"401":2}}],["已经被线程",{"2":{"401":1}}],["已经持有了资源",{"2":{"401":1}}],["已经持有的资源",{"2":{"401":1}}],["已经占有的资源",{"2":{"401":1}}],["已经过期",{"2":{"213":1}}],["已经帮我们实现好了",{"2":{"45":1}}],["已经爬过了",{"0":{"27":1}}],["看下图",{"2":{"485":1}}],["看过源码吗",{"0":{"330":1}}],["看小林图解网络",{"2":{"256":1}}],["看这一篇文章就够了",{"2":{"240":1}}],["看完吊打面试官",{"2":{"240":1}}],["看上面",{"2":{"145":1}}],["吊打面试官",{"2":{"240":1}}],["脱颖而出",{"2":{"240":1}}],["助你",{"2":{"240":1}}],["阿里p8整理mysql面试题答案",{"2":{"240":1}}],["透彻解读mysql的可重复读",{"2":{"240":1}}],["极客时间",{"2":{"240":1,"385":1}}],["旋转",{"0":{"239":1}}],["红黑树",{"0":{"239":1,"345":1}}],["红黑树与avl差别",{"0":{"156":1}}],["直至进行中的请求完成",{"2":{"439":1}}],["直到程序结束",{"2":{"270":1}}],["直到另一个相对应的操作准备好为止",{"2":{"235":1}}],["直接解析",{"2":{"560":1}}],["直接将这个索引设置为主键",{"2":{"580":1}}],["直接将缓存资源返回给浏览器进程",{"2":{"439":1}}],["直接将其ip拉黑",{"2":{"320":1}}],["直接可以查找到",{"2":{"345":1}}],["直接递归就行了",{"2":{"254":1}}],["直接答出sds的特性",{"2":{"154":1}}],["直接使用数组可能会更合适",{"2":{"69":1}}],["直接使用容器就足够了",{"2":{"45":1}}],["发起者又是谁",{"2":{"525":1}}],["发起url请求阶段",{"0":{"439":1}}],["发生的具体场景及mysql是怎么做的",{"0":{"422":1}}],["发生死锁时",{"2":{"401":1}}],["发现数据不匹配",{"2":{"267":1}}],["发现是用起来像引用传递",{"2":{"516":1}}],["发现是",{"2":{"254":1,"267":1}}],["发现会有记录因此就会出现幻读的情况",{"2":{"240":1}}],["发现过期直接返回null",{"2":{"213":1}}],["发送一个比较大的文件该如何操作",{"2":{"572":1}}],["发送信号使进程退出",{"2":{"525":1}}],["发送",{"2":{"439":1,"483":1}}],["发送方使用公有密钥将消息进行加密",{"2":{"467":1}}],["发送方",{"2":{"268":4}}],["发送将会阻塞",{"2":{"235":1}}],["发送goroutine和接收gouroutine必须是同步的",{"2":{"235":1}}],["才可以使用",{"2":{"543":1}}],["才可以完成发送和接收操作",{"2":{"235":1}}],["才可进入加密报文传输",{"2":{"455":1}}],["才能继续执行",{"2":{"273":1,"279":1}}],["才发送fin报文给客户端表示同意现在关闭服务器到客户端的连接",{"2":{"256":1}}],["才会检查",{"2":{"213":1}}],["万",{"2":{"233":1}}],["端口号",{"2":{"495":1}}],["端口",{"2":{"439":1}}],["端",{"2":{"233":1}}],["讨论到memcache和redis的区别",{"2":{"230":1}}],["讨论到",{"2":{"230":1}}],["讨论到io模型",{"2":{"230":1}}],["讨论到多路复用",{"2":{"230":1}}],["讨论redis为什么那么高效",{"2":{"230":1}}],["根本的差距在于redis只有一个主线程执行命令",{"2":{"230":1}}],["根据html的语法对其进行格式化",{"2":{"483":1}}],["根据响应头中的",{"2":{"443":1}}],["根据网络带宽调整tcp滑动窗口大小",{"2":{"364":1}}],["根据ip协议号确定送给哪个模块",{"2":{"340":1}}],["根据内存淘汰策略进行淘汰",{"2":{"180":1}}],["根据数据报报头中的目的地址将数据传送到目的地址",{"2":{"172":1}}],["根据这个打印结果",{"0":{"113":1}}],["根据下标随机访问时间复杂度是o",{"2":{"28":1}}],["根据对象的类型来判断一个对象是否可以执行给定的命令",{"2":{"6":1}}],["丢失了会怎么样",{"2":{"572":1}}],["丢给workers线程",{"2":{"230":1}}],["丢过去给套接字队列",{"2":{"230":1}}],["专门负责读取io数据",{"2":{"230":1}}],["专门负责处理孤儿进程的善后工作",{"2":{"229":1}}],["具有n个关键字的节点包含",{"2":{"375":1}}],["具有特定的格式",{"2":{"179":1}}],["具体查看什么问题",{"2":{"572":1}}],["具体",{"0":{"517":1}}],["具体参考小林图解网络",{"2":{"459":1}}],["具体参考自己总结的笔记",{"2":{"297":1}}],["具体可以参考这里彻底搞懂css层叠上下文",{"2":{"451":1}}],["具体都是谁",{"2":{"335":1}}],["具体介绍一下",{"2":{"261":1}}],["具体解释",{"2":{"230":1}}],["具体流程图",{"2":{"230":1}}],["僵尸",{"2":{"229":1}}],["僵尸进程并不是问题的根源",{"2":{"229":1}}],["僵尸进程",{"2":{"229":1}}],["枪毙了元凶进程之后",{"2":{"229":1}}],["罪魁祸首是产生出大量僵尸进程的那个父进程",{"2":{"229":1}}],["严格地来说",{"2":{"229":1}}],["严格来说",{"2":{"222":1}}],["倘若用ps命令查看的话",{"2":{"229":1}}],["至少破坏其中一个条件",{"2":{"401":1}}],["至少要了解基本思路是怎样的",{"2":{"103":1}}],["至此",{"2":{"390":1}}],["至于数据库事务锁",{"2":{"309":1}}],["至于子进程退出之后的事情",{"2":{"229":1}}],["什么场景下使用",{"2":{"572":1}}],["什么问题",{"2":{"572":1}}],["什么是虚拟内存",{"0":{"433":1}}],["什么是线程安全",{"0":{"343":1}}],["什么是redis缓存雪崩",{"2":{"308":1}}],["什么是事务",{"0":{"255":1}}],["什么情况下僵尸进程会威胁系统的稳定呢",{"2":{"229":1}}],["什么时候用",{"0":{"575":2}}],["什么时候发送",{"2":{"572":1}}],["什么时候不走",{"0":{"550":1}}],["什么时候走索引",{"0":{"550":1}}],["什么时候触发",{"0":{"428":1}}],["什么时候会向对端传窗口大小",{"2":{"572":1}}],["什么时候会用302",{"2":{"382":1}}],["什么时候会触发连锁更新",{"2":{"154":1}}],["什么时候退化成ziplist",{"2":{"154":1}}],["真正会对系统构成威胁的是僵尸进程",{"2":{"229":1}}],["凄凉地",{"2":{"229":1}}],["或没有孩子",{"2":{"426":3}}],["或三个孩子",{"2":{"426":1}}],["或最小",{"2":{"345":1}}],["或实例",{"2":{"279":1}}],["或",{"2":{"267":1}}],["或还包含可以接收的数据",{"2":{"235":1}}],["或waitpid",{"2":{"229":1}}],["或者使用",{"2":{"451":1}}],["或者是在最长时间内不再被访问的页面",{"2":{"449":1}}],["或者是具有下列性质的二叉树",{"2":{"426":1}}],["或者当cpu利用率降低到某个标准下去检测",{"2":{"405":1}}],["或者查询条件是",{"2":{"390":1}}],["或者",{"0":{"296":1},"2":{"431":1}}],["或者自己这个事务也可能修改数据",{"2":{"279":1}}],["或者为了实现可重复读",{"2":{"279":1}}],["或者说是",{"2":{"261":1}}],["或者waitpid",{"2":{"229":1}}],["或者显示地删除一个消息队列时",{"2":{"179":1}}],["或者希望使用基本类型",{"2":{"45":1}}],["孤儿进程并不会有什么危害",{"2":{"229":1}}],["孤儿进程是指这样一类进程",{"2":{"229":1}}],["孤儿进程又是怎么回事呢",{"2":{"229":1}}],["孤儿进程的区别",{"0":{"229":1}}],["子网掩码有什么用",{"2":{"572":1}}],["子网掩码",{"2":{"548":1}}],["子域名",{"2":{"495":1}}],["子进程虽然已经退出了",{"2":{"229":1}}],["子进程产生子子进程这样的方式创建出完成各项相互协作功能的进程的",{"2":{"229":1}}],["子串数为",{"2":{"87":1}}],["二级索引",{"0":{"450":1}}],["二级索引树=",{"2":{"345":1}}],["二级索引树上找到对应的id=",{"2":{"345":1}}],["二级索引树",{"2":{"345":1}}],["二分",{"0":{"226":1}}],["二叉排序树",{"2":{"426":1}}],["二叉搜索树",{"2":{"375":1}}],["二叉搜索树的定义",{"2":{"63":1}}],["二叉树或",{"2":{"390":1}}],["二叉树",{"0":{"375":1},"2":{"375":1}}],["二叉树的优缺点",{"0":{"345":1}}],["二叉树的左视图打印",{"0":{"231":1}}],["二叉树的右视图",{"0":{"215":1}}],["二叉树从根到叶子的路径总和是否存在指定的值",{"0":{"170":1}}],["二叉树中任意",{"0":{"126":1}}],["偏转顺序数组",{"0":{"226":1}}],["偏移",{"2":{"56":1}}],["地址",{"2":{"560":1}}],["地址栏的",{"2":{"447":1}}],["地址后被封装成数据帧",{"2":{"225":1}}],["地址和接收端",{"2":{"225":1}}],["地址转为",{"0":{"34":1}}],["附加的信息可能包括",{"2":{"225":1}}],["六",{"2":{"222":1}}],["六路归并排序",{"0":{"46":1}}],["些",{"2":{"222":1}}],["酷",{"2":{"222":1}}],["集群搭建",{"0":{"278":1}}],["集群数据同步等",{"2":{"222":1}}],["集合命令实现方法",{"2":{"154":1}}],["集合对象或者有序集合对象的其中一种",{"2":{"7":1}}],["集合对象和有序集合对象这五种类型的对象",{"2":{"6":2}}],["异步是指进程不需要一直等下去",{"2":{"485":1}}],["异步是非阻塞模式",{"2":{"485":1}}],["异步删除",{"2":{"222":1}}],["异常处理",{"0":{"456":1},"1":{"460":1,"464":1,"468":1,"472":1,"476":1}}],["异常怎么做",{"2":{"196":1}}],["寄存器",{"2":{"221":1}}],["独享的资源有",{"2":{"221":1}}],["虽然多任务也可以完成计算密集型任务",{"2":{"473":1}}],["虽然见过原题",{"0":{"257":1}}],["虽然对于局部变量来说",{"2":{"221":1}}],["虽然没花多少时间",{"2":{"63":1}}],["静态变量",{"2":{"221":1}}],["金条只可以被切分两次",{"0":{"216":1}}],["工人打工工资日结",{"0":{"216":1}}],["工作在网络层",{"2":{"184":1}}],["扩展",{"0":{"326":1},"1":{"332":1,"338":1,"344":1,"350":1,"356":1,"362":1,"368":1,"374":1,"380":1}}],["扩展点三",{"2":{"230":1}}],["扩展点二",{"2":{"230":1}}],["扩展点一",{"2":{"230":1}}],["扩展问题",{"2":{"213":1,"222":1}}],["扩容过程中需不需要重新写入",{"2":{"150":1}}],["避免每次客户端与服务器请求都要重复建立释放建立tcp连接",{"2":{"407":1}}],["避免其他事务意外修改数据",{"2":{"309":1}}],["避免重写太多",{"2":{"213":1}}],["避免所有的路由器都进行广播造成广播风暴严重浪费因特网资源",{"2":{"195":1}}],["能够通过函数传参后",{"2":{"516":1}}],["能够解决吗",{"2":{"178":1}}],["能容纳更多节点元素",{"2":{"375":1}}],["能做到读写并行",{"2":{"279":1}}],["能删除多少删除多少",{"2":{"213":1}}],["难为小哥听我这个错到离谱的答案了",{"2":{"587":1}}],["难道每个事务都拷贝一份视图",{"0":{"327":1}}],["难以确定删除操作执行的时长和频率",{"2":{"213":1}}],["难点",{"2":{"146":1}}],["惰性删除策略对内存不友好",{"2":{"213":1}}],["惰性删除策略对",{"2":{"213":1}}],["惰性删除",{"2":{"213":2}}],["惰性删除+定期删除",{"2":{"213":1}}],["缺点",{"2":{"213":3}}],["缺点是重启",{"2":{"180":1}}],["缺点是必须重启",{"2":{"180":1}}],["定位请求资源",{"2":{"483":1}}],["定时去刷新缓存",{"2":{"320":1}}],["定时删除策略对",{"2":{"213":1}}],["定时删除对内存是最友好的",{"2":{"213":1}}],["定时删除",{"2":{"213":1}}],["定期删除和惰性删除",{"2":{"213":1}}],["定期删除策略变得和定时删除策略一样",{"2":{"213":1}}],["定期删除",{"2":{"213":2}}],["定义的时候通过make的第2个参数指定缓冲区大小",{"2":{"235":1}}],["定义的时候就需要确定",{"2":{"120":1}}],["定义",{"0":{"187":1}}],["定义链表结构",{"0":{"131":1}}],["定义通用的传输层协议就可以支持不断增多的",{"2":{"129":1}}],["过程介绍",{"0":{"517":1}}],["过期",{"2":{"213":1}}],["过期删除策略是什么",{"2":{"213":1}}],["过期删除策略",{"2":{"213":1}}],["过滤型防火墙是在网络层与传输层中",{"2":{"184":1}}],["过滤型防火墙",{"2":{"184":1}}],["接受请求返回响应",{"2":{"483":1}}],["接着读了一下最新的",{"2":{"267":1}}],["接收窗口和拥塞窗口",{"2":{"572":1}}],["接收者呢",{"2":{"525":1}}],["接收方使用公有密钥解密验证签名是否正确",{"2":{"467":1}}],["接收方使用私有密钥进行解密",{"2":{"467":1}}],["接收方将缓存的地图发送给发送方",{"2":{"268":1}}],["接收将会阻塞",{"2":{"235":1}}],["接收的数据是零值",{"2":{"235":1}}],["接下来浏览器获取这个地址",{"2":{"439":1}}],["接下来事务",{"2":{"267":1}}],["接下来",{"2":{"222":1}}],["接下来就可以看看线程切换是怎么回事了",{"2":{"153":1}}],["接完后继续吃饭",{"2":{"212":1}}],["电话来了",{"2":{"212":3}}],["电子邮件系统采用的",{"2":{"129":1}}],["几种重传的方式",{"2":{"268":1}}],["几种方式",{"2":{"179":1}}],["几个程序在同一个cpu上运行",{"2":{"212":1}}],["情景题",{"2":{"587":1}}],["情",{"0":{"209":1}}],["转换样式表中的属性值",{"2":{"451":1}}],["转换成long",{"2":{"154":1}}],["转化成浏览器能够理解的结构",{"2":{"451":1}}],["转化到一个完全升序的",{"0":{"208":1}}],["扯到文件断点上传",{"0":{"207":1}}],["扯了下",{"2":{"185":1}}],["撕项目",{"0":{"207":1}}],["知道哪些存储引擎",{"0":{"498":1}}],["知道收到返回信息才继续执行下去",{"2":{"485":1}}],["知道",{"0":{"311":1},"2":{"268":1}}],["知道了这些信息",{"2":{"268":1}}],["知道一丢丢",{"2":{"203":1}}],["知道如何分析",{"2":{"103":1}}],["略有耳闻",{"2":{"203":1}}],["应该准备渲染进程了",{"2":{"443":1}}],["应该主动告诉面试官自己知道",{"2":{"202":1}}],["应用场景",{"0":{"378":1}}],["应用",{"2":{"308":1}}],["应用代理防火墙主要的工作范围就是在ois的最高层",{"2":{"184":1}}],["应用代理防火墙",{"2":{"184":1}}],["应用程序利用该服务传送应用层报文",{"2":{"129":1}}],["应用层报文和运输层首部信息一道构成了运输层报文段",{"2":{"225":1}}],["应用层可能会直接使用",{"2":{"172":1}}],["应用层协议",{"2":{"129":1}}],["应用层",{"2":{"129":1,"172":1,"184":1}}],["拓展问题",{"2":{"202":1}}],["淘汰整个键值中最少使用的键值",{"2":{"202":1}}],["淘汰整个键值中最久未使用的键值",{"2":{"202":1}}],["淘汰所有设置了过期时间的键值中",{"2":{"202":2}}],["移除最近最少使用的",{"2":{"202":2}}],["针对一个场景设计索引",{"2":{"587":1}}],["针对每个连接维护一个线程",{"2":{"587":1}}],["针对",{"2":{"202":1}}],["限制最多两次",{"0":{"281":1}}],["限制请求在每秒",{"0":{"53":1}}],["限期调度",{"2":{"201":1}}],["公司里面用到了xxx",{"2":{"203":1}}],["公平分享调度",{"2":{"201":1}}],["公式",{"2":{"29":1}}],["彩票调度",{"2":{"201":1}}],["保活",{"2":{"572":1}}],["保持",{"2":{"439":1}}],["保证数据有序性",{"2":{"572":1}}],["保证主从复制不出问题",{"2":{"285":1}}],["保证调度",{"2":{"201":1}}],["保存用户态执行现场",{"2":{"153":1}}],["轮询调度",{"2":{"201":1}}],["轮流取石头",{"0":{"94":1}}],["交互式",{"2":{"201":1}}],["交换机",{"2":{"184":1}}],["交换机处于哪一层",{"0":{"184":1}}],["批处理",{"2":{"201":1}}],["语言的优势在哪里",{"0":{"546":1}}],["语言",{"0":{"546":1}}],["语言中的内置函数",{"2":{"543":1}}],["语言中是一种未决行为",{"2":{"45":1}}],["语言中",{"2":{"45":1}}],["语句在",{"2":{"583":1}}],["语句是如何执行的",{"0":{"583":1}}],["语句调优",{"2":{"390":1}}],["语句开始执行的时候创建的",{"2":{"291":1}}],["语句",{"2":{"273":1,"466":1}}],["语句的作用",{"0":{"200":1}}],["码",{"0":{"197":1}}],["仔细说下实习的业务",{"2":{"196":1}}],["之间",{"0":{"323":1}}],["之前",{"2":{"202":1}}],["之前项目怎么做降级",{"2":{"196":1}}],["之后提交事务设置redolog",{"2":{"587":1}}],["之后用对称密钥加密进行通信保证通信过程的效率",{"2":{"467":1}}],["之后发送给接收方",{"2":{"467":2}}],["之后使用对称密钥加密进行通信来保证通信过程的效率",{"2":{"463":1}}],["之后浏览器将开始生成显示页面",{"2":{"451":1}}],["之后读到的一定是更新后的数据",{"2":{"261":1}}],["之后写入数据的时候又会找到一个io线程去写数据",{"2":{"230":1}}],["之后分发器会挑具体的事件处理器",{"2":{"230":1}}],["之后通过传输介质传送到对端",{"2":{"225":1}}],["之后",{"2":{"180":1,"401":1,"587":1}}],["之后的问题",{"2":{"160":1}}],["首先",{"2":{"483":1}}],["首先客户端通过url访问服务器并建立ssl连接",{"2":{"471":1}}],["首先大量的用户访问redis请求数据",{"2":{"320":1}}],["首先主机a将数据报发送给本网络中的默认网关",{"2":{"195":1}}],["首部最小有20自己",{"2":{"241":1}}],["首部只有8字节",{"2":{"241":1}}],["首歌",{"0":{"55":1}}],["假设你的表中确实有一个唯一字段",{"2":{"580":1}}],["假设",{"2":{"572":1}}],["假设现在user表有几条记录",{"2":{"482":1}}],["假设我们有张表",{"2":{"434":1}}],["假设我们只需要查询商品的名称",{"2":{"390":1}}],["假设前一个请求响应一直不到达",{"2":{"403":1}}],["假设关闭连接的时候",{"2":{"256":1}}],["假设本例中的主机a要将数据转发给主机d",{"2":{"195":1}}],["假如查询",{"2":{"587":1}}],["假如要查",{"2":{"587":1}}],["假如线程a1要切换到另一个进程b的线程b1",{"2":{"153":1}}],["假如有一个文件",{"0":{"139":1}}],["假如这个限流希望做成可配置的",{"2":{"133":1}}],["假如我们不允许写入失败呢",{"2":{"59":1}}],["假如量很大",{"2":{"59":1}}],["假如用",{"2":{"59":1}}],["由被调用方主动通知调用方任务已完成的方式是异步调用",{"2":{"485":1}}],["由调用方盲目主动问询的方式是同步调用",{"2":{"485":1}}],["由浏览器读取",{"2":{"483":1}}],["由网景提出",{"2":{"387":1}}],["由内存+redo",{"2":{"303":1}}],["由事件处理器自动执行",{"2":{"213":1}}],["由默认网关帮主机将ip数据报转发出去",{"2":{"195":1}}],["由于没有其他索引",{"2":{"580":1}}],["由于每个非主键索引的叶子节点上都是主键的值",{"2":{"580":1}}],["由于20存在记录",{"2":{"482":1}}],["由于http1",{"2":{"403":1}}],["由于b+树的内部节点只存放键",{"2":{"363":1}}],["由于某些原因",{"2":{"267":1}}],["由于堆是在进程空间中开辟出来的",{"2":{"221":1}}],["由于时间片很短",{"2":{"153":1}}],["由于线程是独立调度的基本单位",{"2":{"153":1}}],["由于线程不拥有资源",{"2":{"153":1}}],["由于一台主机可同时运行多个线程",{"2":{"129":1}}],["由于应用层协议很多",{"2":{"129":1}}],["称作默认网关",{"2":{"195":1}}],["实际开发工作中建立联合索引时",{"2":{"390":1}}],["实际是用b+树实现的",{"2":{"345":1}}],["实际上有技巧的",{"2":{"335":1}}],["实际上",{"2":{"195":1}}],["实时性要求不高的业务",{"2":{"586":1}}],["实时",{"2":{"201":1}}],["实习学到了什么",{"2":{"196":1}}],["实现string",{"0":{"508":1}}],["实现版本判断",{"2":{"309":1}}],["实现原理",{"2":{"279":1}}],["实现",{"0":{"287":1},"2":{"279":1,"297":1}}],["实现无锁同步",{"0":{"107":1}}],["实现一个满足需求的内存池",{"0":{"119":1}}],["实现一个位图",{"0":{"91":1}}],["实现一个限流器",{"0":{"53":1}}],["实现队列",{"0":{"86":1}}],["实现方式",{"2":{"77":1}}],["实现评论的时序展示与分页",{"2":{"59":1}}],["主播",{"2":{"578":1}}],["主动释放后再获取",{"2":{"401":1}}],["主键长度越小",{"2":{"580":1}}],["主键",{"0":{"541":1}}],["主键和索引的区别",{"0":{"386":1}}],["主键id=",{"2":{"345":1}}],["主键索引树上的叶子结点行记录",{"2":{"345":1}}],["主键索引树上的id=",{"2":{"345":1}}],["主键索引树",{"2":{"345":2}}],["主子进程共享socket",{"0":{"310":1}}],["主线程监听到套接字事件",{"2":{"230":1}}],["主机a给本网络中的所有主机发送广播",{"2":{"195":1}}],["主机c如何知道应该交给哪个路由器进行转发呢",{"2":{"195":1}}],["主要内存开辟析构",{"0":{"508":1}}],["主要就是通过hash算法",{"2":{"345":1}}],["主要原因",{"2":{"256":1}}],["主要用来存什么数据",{"0":{"246":1}}],["主要是指redis的网络io和键值对读写是由一个线程来完成的",{"2":{"222":1}}],["主要是空间复杂度要求为",{"2":{"58":1}}],["主要负责相同或不同网络中计算机之间的通信",{"2":{"172":1}}],["主要提供及时性服务",{"2":{"129":1}}],["目录",{"2":{"495":1}}],["目的主机收到ip包后",{"2":{"340":1}}],["目的主机的ip地址与源主机的子网掩码相与就可以得到目的主机所在网络的网络地址",{"2":{"195":1}}],["目的端口",{"2":{"340":3}}],["目的ip地址",{"2":{"340":3}}],["目的地址字段的值为d的ip地址",{"2":{"195":1}}],["目前应用较为广泛的防火墙技术当属复合型防火墙技术",{"2":{"184":1}}],["目前效果",{"2":{"169":1}}],["源端口",{"2":{"340":3}}],["源ip地址",{"2":{"340":3}}],["源地址字段的值为主机a的ip地址",{"2":{"195":1}}],["源主机的ip地址与自己的子网掩码相与就可以得到源主机所在网络的网络地址",{"2":{"195":1}}],["源主机如何判断目的主机与自己在同一个网络中呢",{"2":{"195":1}}],["源码",{"2":{"154":1}}],["否则就会创建一个新的渲染进程",{"2":{"443":1}}],["否则",{"2":{"195":3,"439":2,"583":1}}],["否则是间接交付",{"2":{"195":1}}],["若该请求需要一段时间才能返回信息",{"2":{"485":1}}],["若connection",{"2":{"483":1}}],["若",{"2":{"483":1}}],["若路由表中有一个默认路由",{"2":{"195":1}}],["若路由表中有到达网络",{"2":{"195":1}}],["若路由表中有目的地址为",{"2":{"195":1}}],["若主机与此路由器直接相连",{"2":{"195":1}}],["若它的右子树不为空",{"2":{"426":1}}],["若它的右子树不空",{"2":{"63":1}}],["若它的左子树不为空",{"2":{"426":1}}],["若它的左子树不空",{"2":{"63":1}}],["没完全写出来",{"0":{"574":1}}],["没答好",{"0":{"508":1}}],["没答上来",{"0":{"427":1}}],["没想到忽略了基础的",{"2":{"483":1}}],["没有整理的题目",{"2":{"587":1}}],["没有答出",{"2":{"572":1}}],["没有容量限制",{"2":{"543":1}}],["没有充分利用处理器能力",{"2":{"473":1}}],["没有请求优先级控制",{"2":{"407":1}}],["没有线程之间切换的开销",{"2":{"396":1}}],["没有视图概念",{"2":{"291":1}}],["没有出错则进行转发",{"2":{"195":1}}],["没错",{"2":{"35":1}}],["出现幻读问题",{"2":{"315":1}}],["出现不可重读",{"2":{"315":1}}],["出现脏读",{"2":{"315":1}}],["出现超时重传",{"2":{"268":1}}],["出错则丢弃该ip数据报并通告源主机",{"2":{"195":1}}],["出来",{"0":{"70":1}}],["检测",{"2":{"405":1}}],["检测死锁并恢复死锁",{"2":{"405":1}}],["检查ip数据报首部是否出错",{"2":{"195":1}}],["检验字符串是一个回文字符串",{"0":{"39":1}}],["性能问题怎么排查",{"0":{"444":1}}],["性能问题排查",{"0":{"440":1},"1":{"444":1,"448":1,"452":1}}],["性能瓶颈",{"2":{"407":1}}],["性能优化",{"0":{"194":1}}],["性能的优化需要做到极致",{"2":{"45":1}}],["究竟和面试官聊什么",{"0":{"192":1}}],["随时可以提交事务",{"2":{"583":1}}],["随着时间的推移",{"2":{"191":1}}],["随机数法",{"2":{"345":1}}],["随机",{"2":{"213":1}}],["随机选择",{"2":{"213":1}}],["随机淘汰任意键值",{"2":{"202":1}}],["随机淘汰设置了过期时间的任意键值",{"2":{"202":1}}],["随机移除某个",{"2":{"202":2}}],["随机性好",{"2":{"154":1}}],["随机播放",{"0":{"55":1}}],["随机访问呢",{"2":{"28":1}}],["供其它进程收集",{"2":{"190":1}}],["供完整性服务",{"2":{"129":1}}],["终止状态",{"2":{"190":1}}],["阻塞是指调用线程或者进程被操作系统挂起",{"2":{"481":1}}],["阻塞与非阻塞",{"0":{"481":1}}],["阻塞状态",{"2":{"190":1}}],["阻挡",{"2":{"184":1}}],["程序执行的交互过程",{"0":{"513":1}}],["程序正在执行",{"2":{"190":1}}],["程序会先将对象的编码从embstr转换成raw",{"2":{"154":1}}],["程序会将保存在字符串对象里面的字符串值转换回浮点数值",{"2":{"154":1}}],["映射",{"2":{"188":1}}],["常用的是如下4种",{"2":{"449":1}}],["常用的索引可以分为full",{"2":{"390":1}}],["常用的shell命令",{"0":{"151":1}}],["常见的大部分任务都是io密集型任务",{"2":{"473":1}}],["常见的hash算法有直接定址法",{"2":{"345":1}}],["常见索引优化方法",{"2":{"390":1}}],["常见扫描类型的执行效率从低到高的顺序为",{"2":{"390":1}}],["常见数据结构",{"0":{"188":1}}],["小于最大元素的元素",{"2":{"426":1}}],["小于第二元素的元素",{"2":{"426":1}}],["小的数字",{"0":{"365":1}}],["小技巧",{"0":{"203":1,"214":1}}],["小",{"0":{"186":1}}],["小林图解网络",{"2":{"104":1}}],["又称为二叉查找树",{"2":{"426":1}}],["又提出申请资源",{"2":{"401":1}}],["又仍然保留在数据库中",{"2":{"213":1}}],["又可以细分为",{"2":{"202":1}}],["又问",{"2":{"185":1}}],["又因为cpu很快",{"2":{"153":1}}],["业务上有什么吗",{"2":{"196":1}}],["业务之类的怎么处理",{"2":{"185":1}}],["业界有a",{"2":{"181":1}}],["做",{"2":{"451":1}}],["做了什么",{"0":{"374":1}}],["做判断或做关键数据时",{"2":{"267":1}}],["做的什么",{"2":{"185":1}}],["做完它该做的事情之后就退出了",{"2":{"229":1}}],["做完了递归让非递归做一遍",{"2":{"182":1}}],["做完又加难度",{"0":{"19":1}}],["同样问到了",{"0":{"570":1}}],["同自己上面整理的",{"2":{"536":1}}],["同上",{"2":{"475":1}}],["同步原语",{"2":{"549":1}}],["同步就是指一个进程在执行某个请求的时候",{"2":{"485":1}}],["同步是阻塞模式",{"2":{"485":1}}],["同步与异步",{"0":{"485":1}}],["同步的是binlog",{"2":{"285":1}}],["同步",{"0":{"258":1},"2":{"525":1}}],["同时将这个更新操作记录到",{"2":{"583":1}}],["同时释放内存地址",{"2":{"500":1}}],["同时参考自己看bilibili陶辉老师讲解的视频之后自己总结的笔记",{"2":{"487":1}}],["同时利用redis的rdb以及aof持久化机制快速恢复redis的数据",{"2":{"320":1}}],["同时准备后",{"2":{"235":1}}],["同时对redis和数据库进行内存更新的时候",{"2":{"222":1}}],["同时没有惰性删除使用的系统资源少",{"2":{"213":1}}],["同时也能删除一部分过期的数据减少了过期键对空间的无效占用",{"2":{"213":1}}],["同时创建一个定时事件",{"2":{"213":1}}],["同时",{"2":{"212":1}}],["同时摒弃了两种防火墙的原有缺点",{"2":{"184":1}}],["同一个域名同时最多只能建立",{"2":{"439":1}}],["同一个网络中的主机可以直接进行通信",{"2":{"195":1}}],["同一个进程内的线程会共享进程的地址空间和句柄表等资源",{"2":{"153":1}}],["同一进程中线程的切换不会引起进程的切换",{"2":{"153":1}}],["譬如发过来的安全策略是包过滤策略",{"2":{"184":1}}],["综合了包过滤防火墙技术以及应用代理防火墙技术的优点",{"2":{"184":1}}],["复杂度",{"2":{"254":1}}],["复杂度是多少",{"2":{"154":1}}],["复合型防火墙技术",{"2":{"184":1}}],["位于应用层之上",{"2":{"184":1}}],["位整数",{"0":{"34":1}}],["满足安全性能以及类型才可以进行信息的传递",{"2":{"184":1}}],["确认提交",{"2":{"447":2}}],["确认应答",{"2":{"249":1}}],["确定是否可以通过",{"2":{"184":1}}],["确保数据按时成功传送",{"2":{"129":1}}],["方案缺陷",{"2":{"181":1}}],["方法",{"2":{"268":1}}],["方法二",{"2":{"180":2}}],["方法一",{"2":{"180":2}}],["去除不必要的数据",{"2":{"180":1}}],["去系统调用表这里查询对应的系统调用入口并执行",{"2":{"153":1}}],["搭建或者扩充redis集群进行分片存储",{"2":{"180":1}}],["服务器状态",{"2":{"572":1}}],["服务器",{"2":{"560":1}}],["服务器把请求转发至上一级",{"2":{"560":1}}],["服务器向该域名的根域服务器查询",{"2":{"560":1}}],["服务器发一个查询请求",{"2":{"560":1}}],["服务器如何区分两次相同的请求",{"0":{"523":1}}],["服务器server怎么把cookie设置到浏览器的",{"0":{"507":1}}],["服务器将资源复本写到",{"2":{"483":1}}],["服务器的",{"2":{"483":1}}],["服务器利用会话秘钥加密与客户端之间的通信",{"2":{"471":1}}],["服务器利用自己的私钥解密出会话秘钥",{"2":{"471":1}}],["服务器收到客户端请求后",{"2":{"471":1}}],["服务器也会向浏览器发送响应头",{"2":{"439":1}}],["服务器首先返回响应行",{"2":{"439":1}}],["服务器处理请求",{"2":{"439":1}}],["服务器处理完成以后立即断开tcp连接",{"2":{"403":1}}],["服务器推送",{"2":{"411":1}}],["服务器只能被动响应",{"2":{"407":1}}],["服务器是按照请求的顺序响应的",{"2":{"407":1}}],["服务器端会发送401状态码和",{"2":{"387":1}}],["服务器架构是怎么样的",{"2":{"185":1}}],["服务类型以及接口索引",{"2":{"340":1}}],["服务端出现大量close",{"0":{"310":1}}],["服务端收到客户端的fin报文之后",{"2":{"256":1}}],["服务",{"2":{"180":2}}],["服务后配置不会丢失",{"2":{"180":1}}],["策略",{"2":{"180":1}}],["设备",{"2":{"578":1}}],["设备管理",{"2":{"461":1}}],["设想有这样一个父进程",{"2":{"229":1}}],["设置",{"2":{"587":1}}],["设置为",{"2":{"587":1}}],["设置互斥锁",{"2":{"320":1}}],["设置分布式锁",{"2":{"320":1}}],["设置缓存不过期",{"2":{"320":1}}],["设置缓存的失效时间",{"2":{"320":1}}],["设置就会失效",{"2":{"180":1}}],["设置才能生效",{"2":{"180":1}}],["设置redis最大占用内存大小为100m",{"2":{"180":1}}],["设计学生成绩系统",{"0":{"529":1}}],["设计与实现",{"2":{"385":1}}],["设计模式",{"0":{"127":1},"1":{"143":1,"157":1}}],["设计",{"0":{"60":1,"514":1},"1":{"71":1,"83":1,"95":1,"107":1,"119":1,"133":1,"149":1,"163":1,"518":1,"522":1,"526":1,"529":1,"532":1}}],["设计一个购物车",{"2":{"587":1}}],["设计一个哈希函数",{"0":{"95":1}}],["设计一个加密算法",{"0":{"83":1}}],["设计一个后端服务",{"2":{"59":1}}],["设计一个任务定时器",{"0":{"33":1}}],["设计题",{"0":{"33":1},"2":{"587":1}}],["获取到资源",{"2":{"401":1}}],["获取主键值",{"2":{"390":1}}],["获取设置的redis能使用的最大内存大小",{"2":{"180":1}}],["获得单链表的最后",{"0":{"54":1}}],["远程过程调用",{"2":{"179":1}}],["远程面试使用的是牛客网",{"2":{"63":1}}],["此格式是基于行的复制",{"2":{"285":1}}],["此goroutine才退出",{"2":{"270":1}}],["此时执行一个相反的命令",{"2":{"583":1}}],["此时新对象和老对象指向的内存地址是一样的",{"2":{"500":1}}],["此时cpu",{"2":{"473":1}}],["此时的",{"2":{"447":1}}],["此时在主",{"2":{"285":1}}],["此时",{"2":{"229":2,"469":1,"473":1,"583":1}}],["此时我们需要使用ttl命令查看是否过期",{"2":{"213":1}}],["此时面试的时候你就需要好好表现了",{"2":{"203":1}}],["此方法主要用于在客户端和服务器之间通过网络进行通信",{"2":{"179":1}}],["此外",{"2":{"129":1}}],["更通俗的说",{"2":{"339":1}}],["更新完成",{"2":{"583":1}}],["更新数据时会锁住整张表",{"2":{"462":1}}],["更新数据库表中数据",{"2":{"339":1}}],["更新了我们读取的数据并提交了",{"2":{"279":1}}],["更新了这条数据",{"2":{"267":1}}],["更新记录",{"0":{"3":1}}],["更有优势",{"2":{"179":1}}],["比较redis与memcache",{"2":{"230":1}}],["比较多的情况下",{"2":{"213":1}}],["比",{"2":{"179":1}}],["比如原来是",{"2":{"583":1}}],["比如字符串类型的身份证号",{"2":{"580":1}}],["比如锁",{"2":{"549":1}}],["比如大于或等于传入的第二个参数",{"2":{"543":1}}],["比如性能",{"2":{"522":1}}],["比如性别的区分度就很小",{"2":{"390":1}}],["比如web应用",{"2":{"473":1}}],["比如服务器生成返回数据的时间",{"2":{"439":1}}],["比如状态码",{"2":{"439":1}}],["比如浏览器内核",{"2":{"439":1}}],["比如浏览器服务器",{"2":{"274":1}}],["比如线程",{"2":{"401":3}}],["比如你有资源",{"2":{"397":1}}],["比如联合索引",{"2":{"390":1}}],["比如主键",{"2":{"369":1}}],["比如tcp",{"2":{"340":1}}],["比如tcp中的client以及server",{"2":{"274":1}}],["比如89",{"2":{"340":1}}],["比如1",{"2":{"340":1}}],["比如6",{"2":{"340":1}}],["比如mysql集群",{"2":{"320":1}}],["比如mysql原生的",{"2":{"248":1}}],["比如是否可以搭成集群",{"2":{"320":1}}],["比如zookeepeer",{"2":{"320":1}}],["比如用请求id=",{"2":{"320":1}}],["比如缓存快过期的时候用定时任务重新刷新缓存",{"2":{"320":1}}],["比如我们可以在订单表上对商品名称字段的前",{"2":{"390":1}}],["比如我们这次是插入操作",{"2":{"267":1}}],["比如我们要从数据库中取出",{"2":{"45":1}}],["比如save是fork一个线程出来的",{"2":{"222":1,"230":1}}],["比如持久化",{"2":{"222":1}}],["比如会问你你对golang了解么",{"2":{"203":1}}],["比如有所了解",{"2":{"203":1}}],["比如之前我们在一张表里面查",{"2":{"154":1}}],["比如网络调用",{"2":{"153":1,"167":1}}],["比如说一篇热门文章就有几百万的评论",{"2":{"59":1}}],["比如开发网络框架",{"2":{"45":1}}],["比如object",{"2":{"45":1}}],["比如前面提到的数组插入",{"2":{"45":1}}],["比如",{"0":{"100":1,"570":1},"2":{"35":1,"45":1,"267":2,"451":2,"580":1}}],["比如二叉树",{"2":{"28":1}}],["即test",{"2":{"552":1}}],["即最近最久未使用的页面予以淘汰",{"2":{"449":1}}],["即选择在内存中驻留时间最久的页面进行淘汰",{"2":{"449":1}}],["即可",{"2":{"434":1}}],["即不需要查询出包含整行记录的所有信息",{"2":{"390":1}}],["即商品id",{"2":{"390":1}}],["即使数据达到千万级别时",{"2":{"390":1}}],["即使用辅助索引进行查询",{"2":{"390":1}}],["即指向含这些关键字记录的指针",{"2":{"345":1}}],["即一个事务内部的操作及使用的数据对正在进行的其他事务是隔离的",{"2":{"261":1}}],["即创建工作尚未完成",{"2":{"190":1}}],["即",{"2":{"179":1}}],["即原先",{"0":{"162":1}}],["命令熟悉吗",{"2":{"525":1}}],["命令返回的结果为数据库键对应的值对象的类型",{"2":{"7":1}}],["命名管道",{"2":{"179":2}}],["存在安全风险的问题",{"2":{"455":1}}],["存在的问题",{"2":{"403":1}}],["存在最左匹配原则",{"2":{"390":1}}],["存在于实际的磁盘介质或者文件系统",{"2":{"179":1}}],["存于堆中开辟的",{"2":{"221":1}}],["存放在内存中并由消息队列标识符标识",{"2":{"179":1}}],["存储引擎下",{"2":{"583":1}}],["存储引擎在mysql这个系统架构的哪个位置",{"0":{"502":1}}],["存储引擎默认使用表的主键作为主键索引",{"2":{"390":1}}],["存储引擎",{"0":{"171":1,"486":1},"1":{"490":1,"494":1,"498":1,"502":1,"506":1,"510":1},"2":{"103":1}}],["消息不一定要以先进先出的次序读取",{"2":{"179":1}}],["消息直接由发送方传递给接收方",{"2":{"179":1}}],["消息传递是进程间实现通信和同步等待的机制",{"2":{"179":1}}],["消息传递",{"2":{"179":1}}],["消息队列克服了信号承载信息量少",{"2":{"179":1}}],["消息队列可以实现消息的随机查询",{"2":{"179":1}}],["消息队列是消息的链表",{"2":{"179":1}}],["消息队列是内核中存储消息的链表",{"2":{"179":1}}],["消息队列",{"2":{"179":3}}],["套接字连接",{"2":{"483":1}}],["套接字队列",{"2":{"230":1}}],["套接字是支持",{"2":{"179":1}}],["套接字",{"2":{"179":3,"483":1}}],["管道中的某一个请求被阻塞了",{"2":{"415":1}}],["管道传输",{"2":{"407":1}}],["管道只能承载无格式字",{"2":{"179":1}}],["管道和消息队列的通信数据都是先进先出的原则",{"2":{"179":1}}],["管道",{"0":{"227":1},"1":{"235":1,"243":1,"251":1,"258":1},"2":{"179":2,"447":1}}],["管理和终止表示层实体之间的通信会话",{"2":{"129":1}}],["劣势在哪",{"2":{"178":1}}],["优势呢",{"2":{"525":1}}],["优势在哪",{"2":{"178":1}}],["优的解法",{"0":{"257":1}}],["优点记不得了呀",{"2":{"572":1}}],["优点",{"2":{"213":3}}],["优点是设置之后立即生效",{"2":{"180":1}}],["优点是重启",{"2":{"180":1}}],["优先使用奇诡的案例",{"2":{"214":1}}],["优先移除",{"2":{"202":1}}],["优先淘汰更早过期的键值",{"2":{"202":1}}],["优先级调度",{"2":{"201":1}}],["优化工作的",{"2":{"390":1}}],["优化",{"2":{"103":1,"345":1}}],["惊群问题",{"2":{"178":1}}],["指定编译的平台架构以及运行的平台就可以生成对应的二进制文件",{"2":{"546":1}}],["指定请求的服务器的域名和端口号",{"2":{"387":1}}],["指定请求和响应遵循的缓存机制",{"2":{"387":2}}],["指的是系统的硬盘",{"2":{"469":1}}],["指的是缓存和数据库都没有的数据",{"2":{"320":1}}],["指令",{"2":{"177":1}}],["指向底层实现数据结构的指针",{"2":{"7":1}}],["形成",{"0":{"175":1}}],["处于",{"2":{"583":1}}],["处理",{"2":{"340":1}}],["处理器没有",{"0":{"107":1}}],["处翻转",{"0":{"175":1}}],["完成事务",{"2":{"587":1}}],["完成这个链表的深复制",{"0":{"174":1}}],["完整的列表",{"2":{"449":1}}],["完全无法提升运行效率",{"2":{"473":1}}],["完全服从acid的隔离级别",{"2":{"273":1,"279":1}}],["完全不会影响到系统整体的性能",{"2":{"45":1}}],["层的",{"2":{"584":1}}],["层握手过程",{"0":{"539":1}}],["层叠顺序",{"2":{"451":1}}],["层叠等级",{"2":{"451":1}}],["层左右",{"2":{"390":1}}],["层和应用层",{"2":{"172":1}}],["层或者网络接口层",{"2":{"172":1}}],["体系结构不严格遵循",{"2":{"172":1}}],["除数取余法",{"2":{"345":1}}],["除非数据是被本身事务自己所修改",{"2":{"273":1,"279":1}}],["除了考虑性能外",{"2":{"580":1}}],["除了数据库",{"2":{"196":1}}],["除了",{"2":{"172":1}}],["除此之外",{"2":{"45":1}}],["负责选择传送路线",{"2":{"172":1}}],["负载均衡怎么实现",{"0":{"136":1}}],["负载均衡原理",{"0":{"122":1},"1":{"136":1}}],["网关地址",{"2":{"548":1}}],["网际互联层对应",{"2":{"172":1}}],["网际互联层",{"2":{"172":1}}],["网络进程将获取到的数据包进行解析",{"2":{"443":1}}],["网络进程请求首先会从",{"2":{"439":1}}],["网络进程获取到",{"2":{"439":1}}],["网络状态码",{"2":{"382":1}}],["网络连接的各层的状态",{"0":{"225":1}}],["网络接入层的功能对应于",{"2":{"172":1}}],["网络接入层",{"2":{"172":1}}],["网络读写等很多功能",{"2":{"153":1}}],["网络",{"2":{"129":1,"185":1}}],["网络层之间加入了",{"2":{"455":1}}],["网络层增加了如源和目的端系统地址等网络层首部信息",{"2":{"225":1}}],["网络层针对的还是主机之间的数据传输服务",{"2":{"129":1}}],["网络层把传输层传递下来的报文段或者用户数据报封装成分组",{"2":{"129":1}}],["网络层的主要任务就是选择合适的网间路由和交换节点",{"2":{"129":1}}],["网络层",{"2":{"129":1,"184":1}}],["面经上的回答",{"2":{"560":1}}],["面经上的答案",{"2":{"471":1}}],["面",{"2":{"365":1}}],["面向字节流",{"2":{"241":1}}],["面向报文段",{"2":{"241":1}}],["面向连接",{"2":{"241":1}}],["面向无连接的",{"2":{"172":1}}],["面试也问的挺多",{"0":{"584":1}}],["面试关注点",{"2":{"267":3}}],["面试必备常见存储引擎与锁的分类",{"2":{"240":1}}],["面试必刷",{"2":{"240":1}}],["面试常问的mysql事务acid原理",{"2":{"240":1}}],["面试问烂的",{"2":{"240":1}}],["面试了无数公司总结的",{"2":{"240":1}}],["面试技巧",{"0":{"141":1},"1":{"155":1,"169":1,"181":1,"192":1,"203":1,"214":1}}],["面试官补充了一个教科书上没有提到的作用",{"2":{"572":1}}],["面试官问还有没有办法",{"2":{"519":1}}],["面试官说还有一种",{"2":{"400":1}}],["面试官说就试试吧",{"2":{"58":1}}],["面试官提示了索引",{"0":{"351":1}}],["面试官提示从下标考虑",{"2":{"329":1}}],["面试官提及了内存淘汰机制",{"2":{"202":1}}],["面试官解释说是padding操作",{"2":{"283":1}}],["面试官就硬要让优化",{"0":{"257":1}}],["面试官让我再考虑一下",{"2":{"254":1}}],["面试官有兴趣",{"2":{"214":1}}],["面试官有说入参是一个根节点",{"2":{"63":1}}],["面试官出发点",{"2":{"203":1}}],["面试官其实想考察的是",{"2":{"154":1}}],["面试官",{"0":{"119":1},"2":{"240":1}}],["面试官怕我挂了伤心",{"0":{"99":1}}],["面试题列表",{"2":{"154":1}}],["面试题以及答案整理",{"2":{"104":1,"123":1}}],["面试题主要讲解linux",{"2":{"97":1}}],["面试题",{"0":{"15":1,"17":1,"23":1,"29":1,"31":1,"32":1,"36":1,"37":1,"39":1,"41":1,"43":1,"46":1,"47":1,"50":1,"51":1,"52":1,"54":1,"63":1,"64":1,"67":1,"75":1,"76":1,"79":1,"81":1,"83":1,"88":1,"92":1,"93":1,"95":1,"100":1,"105":1,"106":1,"107":1,"113":1,"119":1,"121":1,"126":1,"133":1,"135":1,"136":1,"142":1,"147":1,"149":1,"151":1,"156":1,"161":1,"163":1,"165":1,"170":1,"177":1,"180":1,"189":1,"191":1,"198":1,"200":1,"202":1,"211":1,"213":1,"220":1,"228":1,"239":1,"244":1,"246":1,"253":1,"260":1,"263":1,"266":1,"278":1,"284":1,"290":1,"296":1,"302":1,"314":1,"332":1,"338":1,"344":1,"350":1,"356":1,"362":1,"368":1,"374":1,"380":1}}],["场景",{"2":{"580":1}}],["场景特点",{"2":{"169":1,"181":1}}],["场演唱会",{"0":{"377":2}}],["场面一度十分尴",{"0":{"161":1}}],["挑重点",{"2":{"169":1}}],["挑选一个自己做的最好的项目介绍一下",{"0":{"146":1}}],["值类型的数据",{"2":{"500":1}}],["值最大的",{"2":{"449":1}}],["值是大于100的",{"2":{"390":1}}],["值作为主键索引",{"2":{"390":1}}],["值一起发送给web服务器",{"2":{"387":1}}],["值的筛选",{"2":{"202":1}}],["值进行筛选",{"2":{"202":1}}],["值",{"0":{"162":1}}],["值对象",{"2":{"7":1}}],["重复报文被接收会发生什么",{"2":{"572":1}}],["重新听了问题后还是没有答出来orz",{"2":{"387":1}}],["重新排列",{"0":{"162":1}}],["重要",{"0":{"327":1,"482":1}}],["重要的是点到即止",{"2":{"213":1}}],["重传",{"2":{"572":1}}],["重传丢失的报文",{"2":{"268":1}}],["重传丢失的报文段",{"2":{"268":1}}],["重传计时器超时",{"2":{"268":1}}],["重发控制",{"2":{"249":1}}],["重点",{"0":{"445":2}}],["重点书籍",{"2":{"385":1}}],["重点说一下",{"2":{"382":1}}],["重点就是点到即止",{"2":{"213":1}}],["重点比较",{"2":{"181":1}}],["重排后",{"0":{"162":1}}],["重排列后",{"2":{"58":1}}],["尬",{"0":{"161":1}}],["禁用cookie还可以使用session么",{"2":{"160":1}}],["加盐",{"2":{"525":1}}],["加密",{"2":{"467":1}}],["加密和签名",{"2":{"467":1}}],["加密和解密使用同一密钥",{"2":{"467":1}}],["加载",{"2":{"435":1}}],["加互斥锁或读写锁",{"2":{"300":1}}],["加",{"2":{"267":1}}],["加上",{"2":{"267":1}}],["加起来等于指定的值",{"0":{"250":1}}],["加锁",{"0":{"157":1}}],["加了超时之后有没有可能在没有释放的情况下",{"2":{"133":1}}],["单个资源的银行家算法",{"2":{"405":1}}],["单工",{"2":{"274":1}}],["单机最大并发",{"2":{"233":1}}],["单链表实现奇数升序",{"0":{"208":1}}],["单比率调度",{"2":{"201":1}}],["单项链表还有个random域指针这个有可能指向了前后的结点",{"0":{"174":1}}],["单向链表的复制",{"0":{"174":1}}],["单点登录原理",{"0":{"173":1}}],["单例模式写一下",{"0":{"157":1}}],["单线程的优缺点",{"2":{"222":1}}],["单线程",{"2":{"138":1}}],["邓大总结的面试技巧与话术",{"0":{"155":1},"1":{"169":1,"181":1,"192":1,"203":1,"214":1}}],["跳表",{"2":{"154":1}}],["跳台阶",{"0":{"12":1}}],["推荐",{"2":{"154":1}}],["升级不降级",{"2":{"154":1}}],["连续发送两次",{"2":{"572":1}}],["连续内存",{"2":{"154":1}}],["连接为啥不能",{"2":{"572":1}}],["连接建立相对简单",{"2":{"455":1}}],["连接可以省下下次需要建立连接的时间",{"2":{"439":1}}],["连接",{"2":{"439":5,"483":3}}],["连接他有一个四元组知道吧",{"0":{"340":1}}],["连接管理以及窗口控制等机制实现可靠性传输的",{"2":{"249":1}}],["连接数超过",{"2":{"233":1}}],["连锁更新",{"2":{"154":1}}],["耗时比较大",{"2":{"154":1}}],["渐进式rehash有什么缺点",{"2":{"154":1}}],["特性",{"2":{"345":1}}],["特色",{"2":{"154":2}}],["特点",{"0":{"28":1},"2":{"213":1}}],["|",{"2":{"154":24}}],["|=",{"2":{"91":1}}],["属性上的样式",{"2":{"451":1}}],["属性里面",{"2":{"154":1}}],["属于间接交付",{"2":{"195":1}}],["属于直接交付",{"2":{"195":1}}],["属于所有进程",{"2":{"153":1}}],["到新的地方",{"2":{"587":1}}],["到得到网页要多少时间",{"2":{"572":1}}],["到底是行锁还是表锁取决于你的",{"2":{"466":1}}],["到",{"0":{"287":1}}],["到时候也好解释",{"2":{"230":1}}],["到时间了自动执行对应的任务",{"0":{"33":1}}],["到目前为止",{"2":{"153":1}}],["代价相应的会更大",{"2":{"153":1}}],["代码简单",{"2":{"546":1}}],["代码是一个",{"0":{"341":1}}],["代码写出来了",{"0":{"311":1}}],["代码量最少",{"2":{"473":1}}],["代码量",{"2":{"146":1}}],["代码",{"0":{"55":1}}],["代码题",{"0":{"14":1,"161":1}}],["继续发送响应体的数据",{"2":{"439":1}}],["继续完成它的任务",{"2":{"153":1}}],["继续执行后面的指令",{"2":{"153":1}}],["恢复",{"2":{"405":1}}],["恢复到切换前的执行现场",{"2":{"153":1}}],["恢复现场在用户态的执行现场",{"2":{"153":1}}],["修改对应的数组值",{"2":{"516":1}}],["修改数据也会发生类似的情况",{"2":{"267":1}}],["修改最大文件描述符个数等参数",{"2":{"233":1}}],["修改redis启动使用的配置文件中的内容maxmemory",{"2":{"180":1}}],["修改redis启动使用的配置文件maxmemory",{"2":{"180":1}}],["修改redis内存",{"2":{"180":1}}],["修改一下内存中调度相关的数据结构",{"2":{"153":1}}],["修改为线程a2的信息",{"2":{"153":1}}],["栈是独享的",{"2":{"221":1}}],["栈",{"0":{"489":1},"2":{"221":1}}],["栈指针这些寄存器的值",{"2":{"153":1}}],["栈等也是线性表结构",{"2":{"28":1}}],["后面有",{"2":{"587":1}}],["后面的都会被阻塞",{"2":{"415":1}}],["后面的请求就阻塞了",{"2":{"403":1}}],["后面的即使你传输过去了对方的应用层也不可以接收",{"2":{"399":1}}],["后面的问题",{"0":{"370":1},"2":{"442":1,"453":2,"536":1}}],["后访问的事务必须等前一个事务执行完成",{"2":{"273":1,"279":1}}],["后续的其他操作和故障都不会对事务的结果产生任何影响",{"2":{"261":1}}],["后续再把指令指针",{"2":{"153":1}}],["后新增的内存淘汰策略",{"2":{"202":2}}],["后来看了网上是",{"2":{"587":1}}],["后来又强行答了一波",{"2":{"525":1}}],["后来又要求路径不一定要到叶结点",{"2":{"254":1}}],["后来查了",{"2":{"525":1}}],["后来为了优化系统调用的性能",{"2":{"153":1}}],["后来说如果从原点出发呢",{"2":{"29":1}}],["再",{"2":{"587":1}}],["再写",{"2":{"587":1}}],["再调用引擎接口写入这行新数据",{"2":{"583":1}}],["再请求上上级直到查询到该域名",{"2":{"560":1}}],["再由根域名服务器一级级向下查询",{"2":{"560":1}}],["再申请资源序号大的",{"2":{"401":1}}],["再扩展到其他参数",{"2":{"390":1}}],["再给你一个数字",{"0":{"365":1}}],["再谈谈mysql的索引结构",{"2":{"345":1}}],["再读取时",{"2":{"267":1}}],["再利用之前保存的信息",{"2":{"153":1}}],["再向用户程序暴露接口",{"2":{"153":1}}],["等待",{"2":{"439":1}}],["等待获得cpu",{"2":{"190":1}}],["等等",{"0":{"327":1},"2":{"549":1}}],["等服务端不再发送数据时",{"2":{"256":1}}],["等",{"2":{"172":1,"439":2,"451":1}}],["等到线程a1再次获得时间片之后",{"2":{"153":1}}],["等系统调用结束后",{"2":{"153":1}}],["等机制对于处理的进阶问题的解决",{"2":{"103":1}}],["省去了查询中断向量表的过程",{"2":{"153":1}}],["省时省力",{"2":{"45":1}}],["切换到内核态",{"2":{"153":1}}],["切换到",{"2":{"153":1}}],["切片",{"2":{"188":1}}],["切片怎么扩容",{"2":{"150":1}}],["切片和数组区别和底层",{"2":{"120":1}}],["切片的类型和长度无关",{"2":{"120":1}}],["切片长度不定",{"2":{"120":1}}],["切片未只是声明并未初始化",{"2":{"108":1}}],["还没有整理的",{"0":{"568":1},"1":{"570":1,"572":1}}],["还需进行",{"2":{"455":1}}],["还需要建立",{"2":{"439":1}}],["还需要了解不同索引类型的使用",{"2":{"103":1}}],["还让我运行一下",{"2":{"318":1}}],["还有常用的zk",{"2":{"586":1}}],["还有个坑是",{"2":{"552":1}}],["还有redis实现",{"2":{"320":1}}],["还有在rc隔离级别下",{"2":{"285":1}}],["还有一部分通用寄存器的值",{"2":{"153":1}}],["还会获取区间锁",{"2":{"273":1}}],["还是有更好的操作",{"2":{"587":1}}],["还是有的",{"2":{"580":1}}],["还是最终一致性",{"2":{"586":1}}],["还是用自增字段做主键呢",{"2":{"580":1}}],["还是",{"2":{"572":1}}],["还是接收方回应的",{"2":{"268":1}}],["还是阻止不了插入新数据",{"2":{"267":1}}],["还是可以正常工作",{"2":{"202":1}}],["还可以读到数据么",{"2":{"213":1}}],["还不能访问内核空间",{"2":{"153":1}}],["执行器调用引擎的提交事务接口",{"2":{"583":1}}],["执行器生成这个操作的",{"2":{"583":1}}],["执行器拿到引擎给的行数据",{"2":{"583":1}}],["执行器先找引擎取",{"2":{"583":1}}],["执行代码存放在哪里",{"0":{"525":1}}],["执行顺序",{"0":{"476":1}}],["执行的过程中",{"2":{"397":1}}],["执行效率比多线程高很多",{"2":{"396":1}}],["执行计划是研发工程师分析索引详情必会的技能",{"2":{"390":1}}],["执行计划等",{"2":{"103":1}}],["执行select",{"2":{"285":1}}],["执行",{"2":{"195":4}}],["执行状态",{"2":{"190":1}}],["执行某些操作",{"2":{"154":1}}],["执行内核空间的系统函数",{"2":{"153":1}}],["执行入口如图所示在那里",{"2":{"153":1}}],["weight",{"2":{"451":2}}],["weixin",{"2":{"285":1,"303":1,"584":3,"587":1}}],["web服务器解析请求",{"2":{"483":1}}],["web",{"2":{"447":2,"483":1}}],["warning",{"2":{"387":1}}],["warning\\t警告实体可能存在的问题\\twarning",{"2":{"387":1}}],["waitgroup",{"0":{"336":1},"2":{"549":1}}],["wait原因",{"0":{"310":1}}],["wait是主动断开连接的一方",{"2":{"292":1}}],["wait",{"0":{"292":3},"2":{"292":1,"572":2}}],["where",{"2":{"273":1,"285":1,"390":3,"434":2,"482":1,"576":1}}],["win32",{"2":{"221":1}}],["windows中线程控制信息对应tcb",{"2":{"153":1}}],["worker有什么区别",{"0":{"178":1}}],["worker",{"0":{"178":1},"2":{"178":1}}],["www",{"0":{"82":1},"2":{"222":1,"285":1,"387":4,"491":2}}],["状态",{"2":{"153":1,"435":1,"572":1,"583":2}}],["上写着",{"2":{"390":1}}],["上面",{"2":{"345":1}}],["上面的参考4做的笔记",{"2":{"153":1}}],["上线前的准备",{"2":{"320":1}}],["上次哔哩哔哩面试问到了",{"2":{"318":1}}],["上加个",{"0":{"316":1}}],["上执行",{"2":{"285":1}}],["上下文切换的细节",{"0":{"271":1,"313":1}}],["上层协程结束了",{"0":{"245":1}}],["上午",{"2":{"134":1}}],["表",{"0":{"574":1}}],["表索引有着更广泛的适用场景的原因",{"2":{"390":1}}],["表不适合做范围查询",{"2":{"390":1}}],["表存储结构的优势",{"2":{"390":1}}],["表示继续处理该请求",{"2":{"439":1}}],["表示数据扫描类型",{"2":{"390":1}}],["表示扫描的数据行数",{"2":{"390":1}}],["表示索引的长度",{"2":{"390":1}}],["表示节点允许的最大子节点个数为",{"2":{"390":1}}],["表示是否需要持久连接",{"2":{"387":1}}],["表示请求或响应消息不能缓存",{"2":{"387":1}}],["表示远程服务器地址",{"2":{"387":1}}],["表示层和应用层的功能合并到一个应用层实现",{"2":{"172":1}}],["表示层",{"2":{"129":1}}],["表现形式就是文件描述符",{"2":{"230":1}}],["表现较差",{"2":{"153":1,"167":1}}],["通知客户端在指定时间之后再次尝试\\tretry",{"2":{"387":1}}],["通知我们的开发人员",{"2":{"320":1}}],["通用信息头",{"2":{"387":1}}],["通常用来解析域名为",{"2":{"560":1}}],["通常使用场景是需要显式返回指针",{"2":{"543":1}}],["通常不太常用内置函数",{"2":{"543":1}}],["通常一个页面很大",{"2":{"451":1}}],["通常",{"2":{"357":1}}],["通常我们说的索引不出意外指的就是",{"2":{"345":1}}],["通常是某个函数的指令入口",{"2":{"153":1}}],["通道",{"2":{"188":1}}],["通信发送方使用私有密钥进行签名",{"2":{"467":1}}],["通信",{"2":{"153":1}}],["通过undo",{"2":{"583":1}}],["通过undo日志构造出历史版本",{"2":{"297":1}}],["通过本地缓存进行解析",{"2":{"560":1}}],["通过",{"2":{"483":1}}],["通过一个队列将所有请求加入进去",{"2":{"407":1}}],["通过设置keep",{"2":{"407":1}}],["通过破坏死锁产生的4个条件之一来避免死锁",{"2":{"405":1}}],["通过仔细分配资源来避免死锁",{"2":{"405":1}}],["通过抢占恢复",{"2":{"405":1}}],["通过http",{"2":{"399":1}}],["通过非主键",{"2":{"390":1}}],["通过索引查询数据比全表扫描要快",{"2":{"357":1}}],["通过主键进行回表来获取对应的记录信息",{"2":{"345":1}}],["通过对内容建立索引形成目录",{"2":{"339":1}}],["通过回滚恢复",{"2":{"405":1}}],["通过回滚",{"2":{"303":1}}],["通过增加内存",{"2":{"233":1}}],["通过kill发送sigterm或者sigkill信号",{"2":{"229":1}}],["通过限制删除操作执行的时长和频率",{"2":{"213":1}}],["通过统计访问频率",{"2":{"202":1}}],["通过特定的代理程序就可以实现对应用层的监督与控制",{"2":{"184":1}}],["通过命令来进行设置",{"2":{"180":2}}],["通过不同的应用层协议为不同的应用提供服务",{"2":{"172":1}}],["通过redis源码中对stream的定义我们可知",{"2":{"154":1}}],["通过寄存器或用户栈来传递其他所需参数",{"2":{"153":1}}],["通过控制信息我们可以知道一个帧的起止比特位置",{"2":{"129":1}}],["通过下标随机访问数组元素又是其非常基础的编程操作",{"2":{"56":1}}],["通过内存的计数器",{"0":{"53":1}}],["通过让多个数据库键共享同一个对象来节约内存",{"2":{"6":1}}],["通过这五种不同类型的对象",{"2":{"6":1}}],["调度算法有哪些",{"2":{"525":1}}],["调度算法是不同的",{"2":{"201":1}}],["调度",{"0":{"424":1},"2":{"153":1}}],["调优技巧",{"2":{"103":1}}],["开发中",{"2":{"543":2}}],["开销很大",{"2":{"587":1}}],["开销太大",{"2":{"213":1}}],["开销比较大",{"2":{"153":1}}],["开始",{"2":{"56":1}}],["开始编号",{"2":{"56":2}}],["开始计数",{"2":{"56":1}}],["资源开销",{"2":{"153":1}}],["都不涉及到挪动其他记录",{"2":{"580":1}}],["都需要进行一次tcp连接",{"2":{"403":1}}],["都检测",{"2":{"213":1}}],["都是追加操作",{"2":{"580":1}}],["都是用作变量初始化",{"2":{"543":1}}],["都是引用传递",{"2":{"516":1}}],["都是引用类型",{"2":{"516":1}}],["都是开区间",{"2":{"482":1}}],["都是在同一个事务",{"2":{"279":1}}],["都是由操作系统来实现",{"2":{"153":1}}],["都是共享的",{"2":{"153":1}}],["都是指对pcb的操作",{"2":{"153":1}}],["都比这个难",{"0":{"9":1}}],["描述堆栈优缺点",{"0":{"436":1}}],["描述",{"2":{"308":1}}],["描述进程的基本信息和运行状态",{"2":{"153":1}}],["描述一下",{"0":{"31":1}}],["描述一下迪杰斯特拉",{"0":{"10":1}}],["正符合了我们前面提到的递增插入的场景",{"2":{"580":1}}],["正确的写法是",{"2":{"552":1}}],["正好满足了对视频传输的要求",{"2":{"364":1}}],["正常提交",{"2":{"584":1}}],["正常情况下每个浏览器的",{"2":{"443":1}}],["正常情况下",{"2":{"439":1}}],["正常的缓存流程",{"2":{"320":1}}],["正常是4次",{"2":{"274":1}}],["正在执行的进程由于某事件而暂时无法继续执行时",{"2":{"190":1}}],["正在执行程序的一个实例",{"2":{"153":1}}],["正则表达式匹配",{"0":{"140":1}}],["偶数降序",{"0":{"208":1}}],["偶数位置降序",{"0":{"197":1}}],["偶数位是降序的",{"0":{"186":1}}],["偶数位降序",{"0":{"147":1}}],["偶数个交点则位于多边形之外",{"0":{"82":1}}],["奇数位置升序",{"0":{"197":1}}],["奇数位是升序的",{"0":{"186":1}}],["奇数位升序",{"0":{"147":1}}],["奇数个交点则位于多边形之内",{"0":{"82":1}}],["插入等很慢",{"0":{"567":1}}],["插入查询操作怎么做的",{"2":{"154":1}}],["插入和查找的细节",{"0":{"142":1}}],["插入到第",{"2":{"35":1}}],["归并",{"0":{"139":1}}],["归并排序算法的细节",{"0":{"101":1}}],["请问在搜索时",{"0":{"547":1}}],["请问是为啥",{"0":{"283":1}}],["请求域名",{"2":{"439":1}}],["请求",{"2":{"439":3,"483":2,"572":1}}],["请求发送给网络进程",{"2":{"439":1}}],["请求只能从客户端开始",{"2":{"407":1}}],["请求响应头未经压缩就发送",{"2":{"407":1}}],["请求获取线程",{"2":{"401":1}}],["请求头有什么内容",{"2":{"572":1}}],["请求头部",{"2":{"483":1}}],["请求头",{"2":{"387":1}}],["请求的方法类型",{"2":{"387":1}}],["请求的地址",{"2":{"387":1}}],["请详细介绍一下tcp的三次握手机制",{"0":{"274":1}}],["请查收",{"2":{"240":1}}],["请给出方法统计出现次数最高的前100条",{"0":{"139":1}}],["请在4g内存条件下",{"0":{"30":1}}],["协商缓存",{"0":{"491":1}}],["协程和线程有什么差别",{"2":{"525":1}}],["协程的调度不需要多线程的锁机制",{"2":{"396":1}}],["协程的栈空间大小有限制吗",{"0":{"372":1}}],["协程无需上下文切换",{"2":{"396":1}}],["协程是轻量级线程",{"2":{"396":1}}],["协程怎么切换的",{"0":{"392":1}}],["协程机制",{"0":{"366":1}}],["协程与并发",{"0":{"294":1},"1":{"300":1,"306":1,"312":1,"318":1,"324":1,"330":1,"336":1,"342":1,"348":1,"354":1,"360":1,"366":1,"372":1,"378":1,"383":1,"388":1,"392":1,"396":1,"400":1,"404":1,"408":1,"412":1}}],["协程以及他们的区别",{"0":{"153":1}}],["协程",{"0":{"137":1,"388":1},"1":{"153":1,"167":1,"179":1,"190":1,"201":1,"212":1,"221":1,"229":1,"237":1,"245":1,"252":1,"259":1,"265":1,"271":1,"277":1,"283":1,"289":1,"295":1,"301":1,"307":1,"313":1,"319":1,"325":1,"331":1,"337":1,"343":1,"349":1,"355":1}}],["协议了解吧",{"0":{"530":1}}],["协议了解吗",{"2":{"274":1}}],["协议吗",{"0":{"479":1}}],["协议需要向",{"2":{"455":1}}],["协议的连接过程",{"0":{"483":1}}],["协议的版本",{"2":{"439":1}}],["协议的头部有哪些属性",{"2":{"387":1}}],["协议号标识上层是什么协议",{"2":{"340":1}}],["协议号",{"2":{"340":3}}],["协议之间的对应关系",{"0":{"217":1}}],["协议外",{"2":{"172":1}}],["协议提供的是一个可靠",{"2":{"172":1}}],["协议能够实现数据包简单",{"2":{"172":1}}],["协议保证了数据的传输可靠性",{"2":{"172":1}}],["协议等",{"2":{"129":1}}],["协议",{"2":{"129":1,"435":1,"479":1,"483":1,"495":1}}],["进行更新时又是怎么处理的",{"0":{"583":1}}],["进行通信",{"2":{"400":1}}],["进行检查",{"2":{"213":1}}],["进行数据淘汰的策略",{"2":{"202":1}}],["进行数据淘汰",{"2":{"202":2}}],["进入网络请求阶段",{"2":{"439":1}}],["进入终止状态的进程不能再执行",{"2":{"190":1}}],["进入redis命令行终端",{"2":{"180":2}}],["进程地址空间布局讲一下",{"2":{"525":1}}],["进程和线程的区别",{"2":{"525":2}}],["进程管理",{"2":{"461":1}}],["进程池",{"0":{"307":1}}],["进程是按照父进程产生子进程",{"2":{"229":1}}],["进程是资源分配的基本单位",{"2":{"153":1,"167":1}}],["进程调度算法",{"0":{"355":1}}],["进程调度",{"0":{"201":1}}],["进程到达自然结束点或者因意外被终结",{"2":{"190":1}}],["进程已获得cpu",{"2":{"190":1}}],["进程已分配到除cpu以外打的所有必要资源",{"2":{"190":1}}],["进程还不能被调度运行",{"2":{"190":1}}],["进程还未进入主存",{"2":{"190":1}}],["进程的生命周期",{"0":{"190":1}}],["进程间有哪些通信方式",{"2":{"525":1}}],["进程间的通信",{"2":{"525":1}}],["进程间怎样通信",{"2":{"179":1}}],["进程间通信",{"2":{"179":1}}],["进程之间如何通信",{"0":{"179":1}}],["进程唤醒",{"2":{"178":1}}],["进程拥有自己的资源空间",{"2":{"167":1}}],["进程与线程区别",{"0":{"167":1}}],["进程在创建子进程时会指定它和自己使用同一套地址空间和句柄表等资源",{"2":{"153":1}}],["进程切换与线程切换的一个最主要区别就在于进程切换涉及到虚拟地址空间的切换而线程切换则不会",{"2":{"153":1}}],["进程中的单条流向",{"2":{"153":1}}],["进程控制块",{"2":{"153":1}}],["进程表的内部列出了每个进程的状态以及每个进程使用的资源等",{"2":{"153":1}}],["进程",{"0":{"137":1,"153":1,"349":1},"1":{"153":1,"167":1,"179":1,"190":1,"201":1,"212":1,"221":1,"229":1,"237":1,"245":1,"252":1,"259":1,"265":1,"271":1,"277":1,"283":1,"289":1,"295":1,"301":1,"307":1,"313":1,"319":1,"325":1,"331":1,"337":1,"343":1,"349":1,"355":1},"2":{"153":1}}],["进阶问题",{"2":{"548":1}}],["进阶",{"2":{"133":1}}],["yirufeng",{"2":{"134":1}}],["yarn",{"2":{"0":2}}],["\\trefresh",{"2":{"387":1}}],["\\tage",{"2":{"387":1}}],["\\tabyte",{"2":{"134":1}}],["\\t\\tid",{"2":{"134":1}}],["\\t\\tname",{"2":{"134":2}}],["\\tdbyte",{"2":{"134":1}}],["\\td",{"2":{"134":1}}],["\\tcontent",{"2":{"387":1}}],["\\tcbyte",{"2":{"134":1}}],["\\tc",{"2":{"134":1}}],["\\tfmt",{"2":{"134":4}}],["\\tbbyte",{"2":{"134":1}}],["\\tb",{"2":{"134":1}}],["\\tvar",{"2":{"134":1}}],["\\tname",{"2":{"134":1}}],["\\tid",{"2":{"134":1}}],["\\t",{"2":{"134":4}}],["需要回滚",{"2":{"583":1}}],["需要先从磁盘读入内存",{"2":{"583":1}}],["需要关注下是否泄露",{"2":{"549":1}}],["需要注意的是唯一索引是不会有间隙索引的",{"2":{"482":1}}],["需要查两次",{"2":{"345":1}}],["需要不同的",{"0":{"316":1}}],["需要通过握手同步序列号确定双方都收到消息",{"2":{"274":1}}],["需要通过路由器中转",{"2":{"195":1}}],["需要在",{"2":{"268":1}}],["需要了解什么是内存泄漏",{"0":{"210":1}}],["需要为本网络指定路由器由该路由器进行转发",{"2":{"195":1}}],["需要另外的一个管道",{"2":{"179":1}}],["需要使用sync",{"2":{"176":1}}],["需要我们加以区分的",{"2":{"134":1}}],["需要有一个后台管理系统随意对某个",{"2":{"133":1}}],["需要封装为",{"2":{"45":1}}],["被表扬回答的不错",{"0":{"422":1}}],["被大部分浏览器支持",{"2":{"387":1}}],["被",{"2":{"248":1}}],["被认为是繁忙",{"2":{"177":1}}],["被压入内核栈中",{"2":{"153":1}}],["被人抢走锁",{"2":{"133":1}}],["被打断",{"0":{"107":1}}],["搜索旋转数组最小值",{"0":{"132":1}}],["项目用到的",{"0":{"569":1}}],["项目调试",{"0":{"448":1}}],["项目宕机之后的处理措施",{"2":{"320":1}}],["项目运行中的准备",{"2":{"320":1}}],["项目运行的过程中发现了这些问题我们是否可以采用限流降级这些处理措施",{"2":{"320":1}}],["项目本身的分布式集群",{"2":{"320":1}}],["项目问题",{"0":{"185":1,"196":1}}],["项目中nginx用来干什么",{"0":{"166":1}}],["项目",{"0":{"130":1,"152":1},"1":{"146":1,"160":1,"166":1,"173":1,"185":1,"196":1,"207":1}}],["使得报文能够加密传输",{"2":{"455":1}}],["使得多个进程可以访问同一块内存空间",{"2":{"179":1}}],["使其标准化",{"2":{"451":1}}],["使其上面的数据链路层不必考虑网络的具体传输介质是什么",{"2":{"129":1}}],["使用自增主键插入的时候可以避免我们b+树的页分裂",{"2":{"580":1}}],["使用注意点",{"0":{"549":1}}],["使用内置函数",{"2":{"543":2}}],["使用情况",{"2":{"525":1}}],["使用非对称密钥加密用于传输对称密钥来保证传输过程的安全性",{"2":{"467":1}}],["使用非对称密钥用于传入对称密钥来保证传输过程的安全性",{"2":{"463":1}}],["使用完后",{"2":{"401":1}}],["使用到",{"2":{"390":1}}],["使用覆盖索引的好处很明显",{"2":{"390":1}}],["使用前缀索引可以帮助我们减小索引项的大小",{"2":{"390":1}}],["使用前缀索引是为了减小索引字段大小",{"2":{"390":1}}],["使用索引查询不一定能提高查询性能",{"2":{"357":1}}],["使用锁以及mvcc",{"2":{"303":1}}],["使用原子性操作",{"2":{"300":1}}],["使用channel进行安全读写共享变量",{"2":{"300":1}}],["使用rr隔离级别",{"2":{"285":1}}],["使用",{"2":{"273":1,"303":1}}],["使用了",{"2":{"268":1}}],["使用确认序号",{"2":{"241":1}}],["使用这些公共资源的线程必须同步",{"2":{"221":1}}],["使用所有进程的内存来建立连接",{"2":{"179":1}}],["使用经常哪些指令",{"0":{"165":1}}],["使用拉链法解决冲突",{"2":{"154":1}}],["使用线程的内核栈",{"2":{"153":1}}],["使用append将会触发扩容机制",{"2":{"108":1}}],["使用对象的另一个好处是",{"2":{"6":1}}],["尽量使用主键查询",{"2":{"580":1}}],["尽最大努力交付",{"2":{"241":1}}],["尽最大努力的数据传输服务",{"2":{"129":1}}],["尽可能屏蔽掉具体传输介质和物理设备的差异",{"2":{"129":1}}],["以索引列为条件更新数据",{"2":{"462":1}}],["以上示例代码表示给",{"2":{"543":2}}],["以上示例代码表示分配一个长度为",{"2":{"543":1}}],["以上面的user表来举例",{"2":{"434":1}}],["以上就是索引的实现原理",{"2":{"390":1}}],["以秒计",{"2":{"387":1}}],["以",{"0":{"377":1}}],["以逆时针到上一个点",{"0":{"359":1}}],["以协助快速查询",{"2":{"339":1}}],["以此可以进行推",{"2":{"335":1}}],["以下答案来自于极客时间的mysql实战45讲",{"2":{"291":1}}],["以释放其遗留在系统中的一些资源",{"2":{"229":1}}],["以及元素的",{"2":{"451":1}}],["以及服务器要在客户端保存的",{"2":{"439":1}}],["以及b+树区别",{"0":{"426":1}}],["以及线程",{"2":{"397":1}}],["以及恢复",{"2":{"303":1}}],["以及快速重传",{"2":{"268":1}}],["以及间隙锁与行锁结合的",{"2":{"267":1}}],["以及",{"0":{"210":1}}],["以及进程切换与线程切换的大致过程",{"2":{"153":1}}],["以及调用其他功能和访问硬件",{"2":{"153":1}}],["以及基础概念",{"2":{"103":1}}],["以避免继续占用网络资源",{"2":{"129":1}}],["链路层",{"0":{"145":1}}],["链路层协议就是为同一链路",{"2":{"129":1}}],["链表相加",{"0":{"161":1}}],["链表合并",{"0":{"131":1}}],["链表合并去重",{"0":{"105":1}}],["链表是否有环",{"0":{"92":1}}],["链表",{"0":{"86":1},"2":{"28":1}}],["可用于初始化任意类型",{"2":{"543":1}}],["可分别释放",{"2":{"500":1}}],["可重读",{"2":{"315":1}}],["可重读实现",{"2":{"279":1}}],["可重复读时",{"2":{"462":1}}],["可重复读",{"2":{"267":1,"273":1,"279":1,"291":1}}],["可串行化",{"2":{"267":1,"273":1,"279":1}}],["可靠传输",{"2":{"241":1}}],["可靠的数据传输服务",{"2":{"129":1}}],["可能第二次比第一次快吗",{"2":{"572":1}}],["可能不准确的地方",{"2":{"345":1}}],["可能会导致脏读",{"2":{"273":1,"279":1}}],["可能会占用相当一部分",{"2":{"213":1}}],["可能之前我们查询的是没有这一条记录",{"2":{"240":1}}],["可选",{"2":{"169":2,"181":2}}],["可以的话从服务发现分析",{"2":{"586":1}}],["可以保证数据未提交的数据",{"2":{"584":1}}],["可以保证过期",{"2":{"213":1}}],["可以避免每次查询需要搜索两棵树",{"2":{"580":1}}],["可以配合uber的leak库检测一下",{"2":{"549":1}}],["可以支持很大量的并发",{"2":{"546":1}}],["可以安全的传输对称密钥",{"2":{"467":1}}],["可以在请求头中携带connection",{"2":{"407":1}}],["可以在内存页中获取更多的键",{"2":{"363":1}}],["可以靠按序申请资源来预防",{"2":{"401":1}}],["可以主动释放它占有的资源",{"2":{"401":1}}],["可以增加一个索引页中存储的索引值",{"2":{"390":1}}],["可以参考",{"2":{"370":1}}],["可以提高",{"2":{"369":1}}],["可以通过",{"2":{"345":1}}],["可以选择哈希索引",{"2":{"345":1}}],["可以生成",{"0":{"287":1}}],["可以查到x列有值为2",{"2":{"285":1}}],["可以阻止脏读和不可重复读",{"2":{"273":1,"279":1}}],["可以阻止脏读",{"2":{"273":1,"279":1}}],["可以知道网络中是不是把",{"2":{"268":1}}],["可以知道是不是",{"2":{"268":1}}],["可以让",{"2":{"268":1}}],["可以读取到数据",{"2":{"213":1}}],["可以同时进行",{"2":{"212":1}}],["可以基于数据源头的地址以及协议类型等标志特征进行分析",{"2":{"184":1}}],["可以说这是最有用的进程间通信方式",{"2":{"179":1}}],["可以实现本机任意两个进程通信",{"2":{"179":1}}],["可以用于不同机器之间的进程通信",{"2":{"179":1}}],["可以用long",{"2":{"154":1}}],["可以直接从索引获取",{"2":{"434":1}}],["可以直接兼容不同的浏览器吗",{"2":{"178":1}}],["可以直接append进行追加元素",{"2":{"108":1}}],["可以看做是不同主机之间的进程进行双向通信的端点",{"2":{"179":1}}],["可以看该文章的最后",{"2":{"176":1}}],["可以看到程序执行时",{"2":{"153":1}}],["可以从",{"0":{"175":1}}],["可以减少冲突可能",{"2":{"154":1}}],["可以认为主线程是进程中的第一个线程",{"2":{"153":1}}],["可以怎么解决这个问题呢",{"2":{"133":1}}],["可以",{"2":{"96":1,"108":1}}],["可以是如下类型",{"2":{"7":1}}],["可以针对不同的使用场景",{"2":{"6":1}}],["因而该算法无法实现",{"2":{"449":1}}],["因此http3",{"2":{"415":1}}],["因此二叉树检索到目标数据所经历的磁盘",{"2":{"390":1}}],["因此访问也更迅速",{"2":{"375":1}}],["因此经常访问的元素可能离根节点更近",{"2":{"375":1}}],["因此在绝大多数需求为单条记录查询的时候",{"2":{"345":1}}],["因此在6",{"2":{"230":1}}],["因此由于历史原因",{"2":{"285":1}}],["因此主从执行的顺序不一致",{"2":{"285":1}}],["因此mysql将rr隔离级别作为默认的隔离级别",{"2":{"285":1}}],["因此性能也最低",{"2":{"273":1}}],["因此当数据库只包含成功事务提交的结果时",{"2":{"261":1}}],["因此当读请求打到主服务器上的时候",{"2":{"213":1}}],["因此只能一对一进行通信",{"2":{"241":1}}],["因此最后是如何解决幻读的呢",{"2":{"240":1}}],["因此这个子进程的生命周期很短",{"2":{"229":1}}],["因此也就需要花费更多的时间",{"2":{"363":1}}],["因此也就不需要传输",{"2":{"172":1}}],["因此也是共享的",{"2":{"221":1}}],["因此new出来的都是共享的",{"2":{"221":1}}],["因此",{"2":{"213":2,"229":1,"363":2,"401":1,"426":1,"473":1}}],["因此复合型防火墙技术综合了其组成部分的优点",{"2":{"184":1}}],["因此同一个进程中的线程进行线程切换时不涉及虚拟地址空间的转换",{"2":{"153":1}}],["因此运输层有复用和分用的功能",{"2":{"129":1}}],["因为简历上",{"0":{"575":1}}],["因为goroutine占用的内存很小",{"2":{"546":1}}],["因为post方法每次新增或提交数据的操作都会修改服务器上的资源",{"2":{"503":1}}],["因为io的速度远远低于cpu和内存的速度",{"2":{"473":1}}],["因为私有密钥无法被其他人获取",{"2":{"467":1}}],["因为udp是不可靠的",{"2":{"415":1}}],["因为争夺资源造成线程之间相互等待",{"2":{"397":1}}],["因为只有一个线程",{"2":{"396":1}}],["因为索引需要额外的存储空间和处理",{"2":{"357":1}}],["因为在查看表索引时",{"2":{"345":1}}],["因为在非线性表中",{"2":{"28":1}}],["因为我们前面有一个线程抢到了锁并将数据缓存到redis里面",{"2":{"320":1}}],["因为自己的修改也是可以读取到的",{"2":{"279":1}}],["因为读已提交是在每次select的时候会生成一个read",{"2":{"279":1}}],["因为读不会加任何锁",{"2":{"279":1}}],["因为关闭一方的连接需要2次握手",{"2":{"274":1}}],["因为建立连接的时候不允许连接处于半打开状态就发送消息",{"2":{"274":1}}],["因为即使锁住所有记录",{"2":{"267":1}}],["因为最糟的情况下每个结点都要访问一次",{"2":{"254":1}}],["因为双方需要提前建立连接",{"2":{"241":1}}],["因为select查询的时候是在可重复读的情况下将会快照读",{"2":{"240":1}}],["因为电脑的寄存器是物理的",{"2":{"221":1}}],["因为需要等待主库删除之后才会删除这个过期的key",{"2":{"213":1}}],["因为需要分配连续的内存空间",{"2":{"45":1}}],["因为没有办法通知主服务器也删除这个key",{"2":{"213":1}}],["因为每次访问时",{"2":{"213":1}}],["因为每个进程都有自己的虚拟地址空间",{"2":{"153":1}}],["因为路由器位于网络核心中",{"2":{"172":1}}],["因为小公司项目",{"2":{"154":1}}],["因为这个原因",{"2":{"154":1}}],["因为redis没有为embstr编码的字符串对象编写任何相应的修改程序",{"2":{"154":1}}],["因为操作系统提供了数百个系统调用",{"2":{"153":1}}],["因为创建线程仅仅需要堆栈空间以及程序计数器就可以了而创建进程需要分配虚拟地址空间",{"2":{"153":1}}],["因为扩容操作涉及内存申请和数据搬移",{"2":{"45":1}}],["因为",{"2":{"45":1,"202":1,"516":1,"543":1,"587":1}}],["作忘了",{"2":{"525":1}}],["作用如下",{"2":{"268":1}}],["作用是使通信的应用程序能够解释交换数据的含义",{"2":{"129":1}}],["作为高级语言编程者",{"2":{"45":1}}],["统计频率最高的",{"0":{"124":1}}],["统计出频次最高的10个单词",{"0":{"30":1}}],["两张表",{"0":{"573":1}}],["两次握手无法放置历史连接的建立",{"2":{"256":1}}],["两者差别不大",{"2":{"230":1}}],["两者都可以通过下标来访问单个元素",{"2":{"120":1}}],["两种策略",{"2":{"213":1}}],["两种策略配和使用",{"2":{"213":1}}],["两类策略",{"2":{"202":1}}],["两台主机之间的数据传输",{"2":{"129":1}}],["两个或两个以上",{"2":{"397":1}}],["两个不同关键字的hash值相同",{"2":{"345":1}}],["两个实现⽅式",{"2":{"297":1}}],["两个区间数组",{"0":{"234":1}}],["两个线程互相不抢占cpu资源",{"2":{"212":1}}],["两个线程交替打印",{"0":{"13":1}}],["两个倒序数组找最第",{"0":{"209":1}}],["两个有序数组怎么求交集",{"0":{"148":1}}],["两个有序数组的中位数",{"0":{"118":1}}],["两个有序数组合成一个有序数组",{"0":{"93":1}}],["两个字符串求相似度",{"0":{"62":1}}],["两个人抛硬币",{"0":{"57":1}}],["两个栈实现一个队列",{"0":{"37":1}}],["改成提交",{"2":{"583":1}}],["改成了",{"0":{"12":1}}],["改",{"2":{"279":1}}],["改启用行级共享锁",{"2":{"279":1}}],["改进",{"2":{"411":1,"415":1}}],["改进使用的数据结构",{"2":{"180":1}}],["改进方向",{"2":{"169":1,"181":1}}],["改为通过特殊指令触发系统调用",{"2":{"153":1}}],["改变slice时会同步修改数组内容",{"2":{"120":1}}],["返回一个长度为",{"2":{"543":1}}],["返回值是指针类型",{"2":{"543":1}}],["返回值是指向新分配该类型的零值的指针",{"2":{"543":1}}],["返回值是",{"2":{"543":1}}],["返回值是一个slice",{"2":{"120":1}}],["返回值取决于传参的类型",{"2":{"543":1}}],["返回类型是指针类型",{"2":{"543":1}}],["返回类型是引用类型",{"2":{"543":1}}],["返回的数据类型",{"2":{"439":1}}],["返回的响应mime类型与编码",{"2":{"387":1}}],["返回这个子串",{"0":{"112":1}}],["会得到两次结果吗",{"2":{"572":1}}],["会报错",{"2":{"552":1}}],["会报错通知禁止写入",{"2":{"202":1}}],["会在goroutine需要的时候动态地分配栈空间",{"2":{"546":1}}],["会在定时器过期之前",{"2":{"268":2}}],["会怎么样",{"2":{"525":1}}],["会将网站支持的证书信息",{"2":{"471":1}}],["会存在间隙锁",{"2":{"462":1}}],["会转成",{"2":{"451":2}}],["会更新浏览器的页面状态",{"2":{"447":1}}],["会和网络进程建立传输数据的",{"2":{"447":1}}],["会对应一个渲染进程",{"2":{"443":1}}],["会直接建立",{"2":{"439":1}}],["会进行",{"2":{"439":1}}],["会占用昂贵的cpu时间",{"2":{"405":1}}],["会选择",{"2":{"390":2}}],["会先检索辅助索引中的",{"2":{"390":1}}],["会把保存在该请求域名下的所有",{"2":{"387":1}}],["会把要调用的系统函数编号存入特定寄存器",{"2":{"153":1}}],["会主动扩展吗",{"0":{"372":1}}],["会单独拿出视频来讲",{"2":{"320":2}}],["会锁住间隙",{"2":{"285":1}}],["会加",{"2":{"273":2,"279":2}}],["会造成双方资源的浪费",{"2":{"256":1}}],["会引起painc异常",{"2":{"235":1}}],["会产生什么后果呢",{"2":{"229":1}}],["会忽略已经过期的key",{"2":{"213":1}}],["会被尽快删除",{"2":{"213":1}}],["会被转换为raw编码的字符串对象",{"2":{"154":1}}],["会导致tlb缓存失效",{"2":{"153":1}}],["会根据之前保存的信息",{"2":{"153":1}}],["会从已经就绪的线程中挑选一个来执行",{"2":{"153":1}}],["会话层就是负责建立",{"2":{"129":1}}],["会话层",{"2":{"129":1}}],["会拷贝全部内容",{"2":{"120":1}}],["会简单一些",{"2":{"87":1}}],["感兴趣的同学也可以看看其他goroutine",{"2":{"549":1}}],["感觉答错",{"2":{"587":1}}],["感觉还在想洗牌的事",{"0":{"209":1}}],["感觉出这个简单题可能是",{"0":{"99":1}}],["感谢放过",{"0":{"119":1}}],["眼尖",{"0":{"119":1}}],["晕乎乎写出了几个",{"0":{"119":1}}],["与索引类型",{"2":{"466":1}}],["与二叉搜索树和平衡二叉树区别",{"0":{"426":1}}],["与此同时",{"2":{"397":1}}],["与这条数据的行指针一并存入hash表的对应位置",{"2":{"345":1}}],["与其他副本没有任何关联也不会互相影响",{"2":{"261":1}}],["与其他通信方式不同",{"2":{"179":1}}],["与redis不同的是",{"2":{"230":1}}],["与管道",{"2":{"179":1}}],["与软中断对应的是硬件中断",{"2":{"153":1}}],["与4层协议",{"0":{"116":1},"1":{"129":1,"145":1,"159":1,"172":1,"184":1,"195":1,"206":1,"217":1,"225":1}}],["与",{"0":{"116":1,"465":1},"1":{"129":1,"145":1,"159":1,"172":1,"184":1,"195":1,"206":1,"217":1,"225":1,"469":1,"473":1},"2":{"329":1,"525":1,"543":2}}],["事实上我们经常会为了性能而妥协数据库的设计",{"2":{"522":1}}],["事件分发器会从套接字队列里面拿到我们的套接字",{"2":{"230":1}}],["事件分派器",{"2":{"230":1}}],["事件和互斥体",{"2":{"221":1}}],["事务回滚",{"2":{"584":1}}],["事务回滚时撤销已经执行成功的sql",{"2":{"303":1}}],["事务相关",{"0":{"327":1}}],["事务隔离实现参考",{"2":{"321":1,"327":1}}],["事务隔离级别为",{"2":{"462":1}}],["事务隔离级别",{"0":{"273":1}}],["事务提交的3",{"2":{"303":1}}],["事务的特性以及对应的问题同上",{"2":{"303":1}}],["事务的特性以及对应的问题",{"0":{"303":1}}],["事务的特点或特性",{"0":{"261":1}}],["事务的几个特性",{"0":{"303":1}}],["事务的实现",{"0":{"297":1}}],["事务的隔离有哪些",{"0":{"285":1}}],["事务的隔离级别相关",{"2":{"466":1}}],["事务的隔离级别为",{"2":{"462":1}}],["事务的隔离级别",{"2":{"273":1}}],["事务是如何保证原子性",{"0":{"327":1}}],["事务是逻辑上的一组操作",{"2":{"255":1}}],["事务是一个不可分割的数据库操作序列",{"2":{"255":1}}],["事务是什么",{"2":{"255":1}}],["事务支持是在引擎层实现的",{"2":{"248":1}}],["事务",{"0":{"115":1,"248":1},"1":{"255":1,"261":1,"267":1,"273":1,"279":1,"285":1,"291":1,"297":1,"303":1,"309":1,"315":1,"321":1,"327":1},"2":{"267":5,"273":2}}],["事先指定数据大小可以省掉很多次内存申请和数据搬移操作",{"2":{"45":1}}],["里面",{"2":{"583":1,"587":1}}],["里面存的是学生姓名",{"0":{"114":1}}],["里面很多字符串并且用空格分隔",{"0":{"111":1}}],["把这个值加上",{"2":{"583":1}}],["把收到的",{"0":{"316":1}}],["把树给建立起来",{"0":{"113":1}}],["把数组元素按照正负序重排列",{"0":{"58":1}}],["把数组越界检查的工作丢给程序员来做",{"2":{"45":1}}],["相对于二叉树索引结构的优势",{"2":{"390":1}}],["相对于",{"2":{"390":2}}],["相对随机",{"2":{"274":1}}],["相比于其他常见索引结构",{"2":{"390":1}}],["相比于",{"2":{"390":1}}],["相比之下",{"2":{"45":1}}],["相邻的元素可能在内存中不相邻",{"2":{"375":1}}],["相等且为",{"2":{"329":1}}],["相同就在同一个网络",{"2":{"195":1}}],["相同",{"2":{"159":1,"543":1}}],["相同大小数组可以赋值",{"2":{"120":1}}],["相当于手撕快排",{"0":{"293":1}}],["相当于五层协议中数据链路层和物理层合并为网络接口层",{"2":{"172":1}}],["相当于取得了这个数组的指针",{"2":{"120":1}}],["相当于一个nil",{"2":{"108":1}}],["×",{"0":{"107":1,"119":1}}],["计数据库表应该怎么设计",{"0":{"577":1}}],["计数排序",{"2":{"73":1}}],["计算机在设置ip的时候会设置哪些参数",{"0":{"548":1}}],["计算机内部的存储结构",{"2":{"525":1}}],["计算机为什么要用补码",{"2":{"525":1}}],["计算机网络",{"0":{"104":1},"1":{"116":1,"129":1,"145":1,"159":1,"172":1,"184":1,"195":1,"206":1,"217":1,"225":1,"233":1,"241":1,"249":1,"256":1,"262":1,"268":1,"274":1,"280":1,"286":1,"292":1,"298":1,"304":1,"310":1,"316":1,"322":1,"328":1,"334":1,"340":1,"346":1,"352":1,"358":1,"364":1,"370":1,"376":1,"382":1,"387":1,"391":1,"395":1,"399":1,"403":1,"407":1,"411":1,"415":1,"419":1,"423":1,"427":1,"431":1,"435":1,"439":1,"443":1,"447":1,"451":1,"455":1,"459":1,"463":1,"467":1,"471":1,"475":1,"479":1,"483":1,"487":1,"491":1,"495":1,"499":1,"503":1,"507":1,"511":1,"515":1,"519":1,"523":1,"527":1,"530":1,"533":1,"536":1,"539":1,"542":1,"545":1,"548":1,"551":1,"554":1,"556":1,"558":1,"560":1,"562":1,"564":1,"566":1,"568":1,"570":1,"572":1},"2":{"104":1}}],["计算密集型任务需要大量的计算",{"2":{"473":1}}],["计算出最多能听几",{"0":{"377":1}}],["计网转发分组的详细过程",{"0":{"195":1}}],["怎样写才能更好利用索引",{"2":{"103":1}}],["怎么扩",{"2":{"587":1}}],["怎么建索引",{"2":{"587":1}}],["怎么用",{"2":{"572":1}}],["怎么排查",{"2":{"572":1}}],["怎么排序",{"0":{"73":1}}],["怎么优化",{"2":{"525":1}}],["怎么都想不起来orz",{"2":{"400":1}}],["怎么理解的",{"0":{"332":1}}],["怎么办",{"0":{"296":1}}],["怎么保证可用的",{"0":{"284":1}}],["怎么保护",{"2":{"59":1}}],["怎么求",{"0":{"275":1}}],["怎么判断上传完成",{"0":{"207":1}}],["怎么上传的",{"0":{"207":1}}],["怎么处理请求",{"2":{"178":1}}],["怎么解决线程安全问题",{"0":{"330":1}}],["怎么解决并发安全问题",{"0":{"176":1}}],["怎么解决",{"2":{"133":1,"572":1}}],["怎么抢锁",{"2":{"133":1}}],["怎么做限流",{"2":{"308":1}}],["怎么做持久化",{"0":{"253":1}}],["怎么做",{"0":{"133":1,"149":1,"216":1},"2":{"133":2}}],["怎么实现查表时候的内连接",{"2":{"587":1}}],["怎么实现对主播与主播之间的重合数",{"2":{"578":1}}],["怎么实现的",{"0":{"284":1}}],["怎么实现",{"2":{"59":1,"587":2}}],["怎么分",{"2":{"59":1}}],["怎么找到虫子",{"2":{"29":1}}],["怎么返回固定长度的",{"0":{"26":1}}],["掌握这些知识点",{"2":{"390":1}}],["掌握针对高并发等特定场景中的解决方案",{"2":{"103":1}}],["掌握基础的",{"2":{"103":1}}],["掌握",{"2":{"103":1}}],["掌握数据库的数据类型的使用",{"2":{"103":1}}],["掌握数据库设计中的基本范式",{"2":{"103":1}}],["清楚业务实体关系与数据库结构的映射",{"2":{"103":1}}],["外键",{"2":{"103":1}}],["考察的是联合索引与列选择性的知识",{"2":{"587":1}}],["考察点如下",{"2":{"103":1}}],["考试安排",{"0":{"577":1}}],["考虑到查询效率问题",{"2":{"390":1}}],["考虑磁盘io的影响",{"2":{"375":1}}],["考虑一个业务场景",{"2":{"59":1}}],["考虑线程安全",{"0":{"42":1}}],["索引为什么用ｂ＋树而不是二叉树",{"2":{"587":1}}],["索引失效",{"2":{"587":1}}],["索引是如何实现的",{"0":{"450":1}}],["索引是一个文件",{"2":{"339":1}}],["索引是一种数据结构",{"2":{"339":1}}],["索引是一种特殊的文件",{"2":{"339":1}}],["索引慢分析",{"0":{"422":1}}],["索引范围扫描",{"2":{"390":1}}],["索引范围查询",{"2":{"357":1}}],["索引优化",{"2":{"390":1}}],["索引要比",{"2":{"390":1}}],["索引结构的优势",{"2":{"390":1}}],["索引结构的优势在哪儿",{"2":{"390":1}}],["索引相比于其他索引类型的优势",{"2":{"390":1}}],["索引本身也会被修改",{"2":{"357":1}}],["索引需要空间来存储",{"2":{"357":1}}],["索引越多越好么",{"0":{"357":1}}],["索引下推",{"2":{"345":1}}],["索引覆盖",{"2":{"345":1}}],["索引树和二级索引树",{"2":{"345":1}}],["索引和hash索引",{"2":{"345":1}}],["索引就相当于目录",{"2":{"339":1}}],["索引的底层实现",{"0":{"587":1}}],["索引的数据结构和具体存储引擎的实现有关",{"2":{"345":1}}],["索引的实现通常使用b数及其变种b+数",{"2":{"339":1}}],["索引的结构以及概念",{"0":{"339":1}}],["索引",{"0":{"158":1,"333":1},"1":{"339":1,"345":1,"351":1,"357":1,"363":1,"369":1,"375":1,"381":1,"386":1,"390":1,"394":1,"398":1,"402":1,"406":1,"410":1,"414":1,"418":1,"422":1,"426":1,"430":1,"434":1,"438":1,"442":1,"446":1,"450":1},"2":{"103":2,"345":2,"390":1}}],["索引如何设计",{"2":{"59":1}}],["锁加的区域能不能更小点",{"0":{"157":1}}],["锁怎么释放",{"2":{"133":1}}],["锁",{"0":{"144":1,"454":1},"1":{"458":1,"462":1,"466":1,"470":1,"474":1,"478":1,"482":1},"2":{"103":1,"267":1}}],["安全是指请求方法不会破坏服务器上的资源",{"2":{"503":1}}],["安全协议",{"2":{"455":1}}],["安慰我的",{"0":{"99":1}}],["安装",{"0":{"0":1}}],["输出总共有多少种重新排列的方法",{"0":{"162":1}}],["输出",{"0":{"99":1}}],["输入url发生了什么",{"2":{"431":1}}],["输入",{"0":{"99":1}}],["系统运作",{"2":{"473":1}}],["系统运作大部分的状况是cpu",{"2":{"469":1}}],["系统运行上一段时间之后",{"2":{"229":1}}],["系统运行时间",{"2":{"177":1}}],["系统",{"0":{"236":1},"1":{"244":1}}],["系统中就会存在很多的僵尸进程",{"2":{"229":1}}],["系统中常用命令操作",{"2":{"97":1}}],["系统就可能无法创建新的进程",{"2":{"229":1}}],["系统进程表是一项有限资源",{"2":{"229":1}}],["系统调用取得子进程的终止状态",{"2":{"229":1}}],["系统调用中断对应的编号为0x80",{"2":{"153":1}}],["系统已为其分配了pcb",{"2":{"190":1}}],["系统负载升高原因",{"2":{"177":1}}],["系统负载",{"2":{"177":1}}],["系统当前时间",{"2":{"177":1}}],["系统平均负载",{"2":{"177":1}}],["系统设计",{"0":{"71":1},"1":{"83":1,"95":1,"107":1,"119":1,"133":1,"149":1,"163":1}}],["先将",{"2":{"587":1}}],["先从",{"2":{"586":1}}],["先进先出页面置换算法",{"2":{"449":1}}],["先去本地缓存中查找是否有缓存资源",{"2":{"439":1}}],["先插入了一行",{"2":{"267":1}}],["先前的事务在接下来的查询中",{"2":{"267":1}}],["先读取一条数据",{"2":{"267":1}}],["先回一个ack应答报文",{"2":{"256":1}}],["先执行的操作就会阻塞等待",{"2":{"235":1}}],["先来先服务",{"2":{"201":1}}],["先后手策略",{"0":{"94":1}}],["先递归",{"0":{"12":1}}],["范围",{"0":{"94":1}}],["范围都是",{"0":{"73":1}}],[">>",{"2":{"91":2}}],[">",{"2":{"91":3}}],["包头阻塞",{"2":{"572":1}}],["包丢了",{"2":{"268":1}}],["包括学生信息",{"0":{"577":1}}],["包括主键索引",{"2":{"462":1}}],["包括了安全状态",{"2":{"447":1}}],["包括了建立检查点和恢复方案的方法",{"2":{"129":1}}],["包括",{"0":{"445":1}}],["包括协议版本和状态码",{"2":{"439":1}}],["包括程序计数器pc",{"2":{"221":1}}],["包括信号",{"2":{"221":1}}],["包括信号量等也不行",{"0":{"107":1}}],["包括random域也要复制新的链新的",{"0":{"174":1}}],["包括字符串对象",{"2":{"6":1}}],["包含了一些信息",{"2":{"439":1}}],["包含",{"0":{"91":1}}],["+",{"0":{"89":1,"395":1,"459":2},"2":{"297":1,"435":1,"458":1,"584":1}}],["=60",{"0":{"187":1}}],["=0",{"0":{"162":1}}],["=",{"0":{"89":1},"2":{"91":5,"134":7,"285":1,"329":1,"335":2,"543":3,"552":1,"584":1}}],["迭代解析",{"2":{"560":1}}],["迭代",{"0":{"88":1}}],["其它两个是引擎层的",{"2":{"584":1}}],["其搜索复杂度为o",{"2":{"390":1}}],["其余大部分场景",{"2":{"345":1}}],["其他问题",{"0":{"535":1,"545":1},"1":{"538":1,"541":1,"544":1,"547":1,"548":1,"550":1,"551":1,"553":1,"554":1,"555":1,"556":1,"557":1,"558":1,"559":1,"560":1,"561":1,"562":1,"563":1,"564":1,"565":1,"566":1,"567":1,"569":1,"571":1,"573":1,"574":1,"575":1,"576":1,"577":1,"578":1,"579":1,"580":1,"581":1,"582":1,"583":1,"584":1,"585":1}}],["其他内置函数可以参考golang包中的builtin",{"2":{"496":1}}],["其他",{"0":{"457":1},"1":{"461":1,"465":1,"469":1,"473":1,"477":1,"481":1,"485":1,"489":1,"493":1,"497":1,"501":1,"505":1,"509":1,"513":1,"517":1}}],["其他没有抢到锁的线程让它先睡几毫秒",{"2":{"320":1}}],["其他事务只能读",{"2":{"285":1}}],["其他同上",{"2":{"285":1}}],["其次使用3次连接可以节省一次连接建立的过程",{"2":{"274":1}}],["其执行的结果必须使数据库从一种一致性状态变到另一种一致性状态",{"2":{"255":1}}],["其主要的特征是可以完全隔离网络通信流",{"2":{"184":1}}],["其中每一个节点的左右子树的高度差至多等于1",{"2":{"426":1}}],["其中每一个节点都具有两个孩子及到什么是b树",{"0":{"426":1}}],["其中",{"2":{"390":1}}],["其中保存状态码和一些计时统计数据",{"2":{"190":1}}],["其中面向连接的",{"2":{"172":1}}],["其中应用层对应",{"2":{"159":1}}],["其子串有",{"2":{"87":1}}],["其实我也不懂",{"2":{"587":1}}],["其实还有",{"2":{"560":1}}],["其实都是值传递",{"2":{"516":1}}],["其实在考察你两个方面",{"2":{"390":1}}],["其实是由额外的线程执行的",{"2":{"222":1}}],["其实线程里存放的是副本",{"2":{"221":1}}],["其实就是想问下面的kmp懂吗",{"0":{"31":1}}],["其实除了数组",{"2":{"28":1}}],["其实日常工作中我们使用的都是redis对象的操作命令",{"2":{"6":1}}],["三句查询",{"2":{"587":1}}],["三数之和",{"0":{"269":1}}],["三次握手和四次挥手的描述",{"2":{"572":1}}],["三次握手之后",{"2":{"455":1}}],["三次握手之后便可进行",{"2":{"455":1}}],["三次握手与服务器建立连接",{"2":{"439":1}}],["三次握手可以携带数据吗",{"0":{"346":1}}],["三次握手就已经理论上最少可靠连接建立",{"2":{"256":1}}],["三次握手才可以避免资源浪费",{"2":{"256":1}}],["三次握手才可以同步双方的初始化序列号",{"2":{"256":1}}],["三次握手才可以阻止重复历史连接的初始化",{"2":{"256":1}}],["三种字符",{"0":{"87":1}}],["三个要点",{"2":{"154":1}}],["三个方法",{"0":{"91":1}}],["三个元素",{"2":{"35":1}}],["三个线程交替输出123",{"0":{"20":1}}],["千万级别的数据量",{"0":{"86":1}}],["封闭图形所有点坐标都给出",{"0":{"82":1}}],["判断两个是否相同",{"2":{"195":1}}],["判断二叉树是否对称",{"0":{"88":1}}],["判断一个点是否在封闭图形里边",{"0":{"82":1}}],["判断是否为完美二叉树",{"0":{"51":1}}],["反转一个单链表第i到j的部分",{"0":{"79":1}}],["呢",{"0":{"78":1,"316":2},"2":{"525":1,"572":1}}],["操作就能查询到目标数据",{"2":{"390":1}}],["操作数据库时",{"2":{"273":1}}],["操作来说的",{"2":{"267":1}}],["操作命令",{"0":{"109":1},"1":{"121":1,"135":1,"151":1,"165":1,"177":1,"189":1,"200":1,"211":1,"220":1,"228":1}}],["操作",{"0":{"107":1},"2":{"267":1,"390":1}}],["操作具体实现",{"2":{"77":1}}],["操作系统在",{"2":{"525":1}}],["操作系统你了解多少",{"2":{"525":1}}],["操作系统中的锁",{"0":{"493":1}}],["操作系统中有一个叫做调度程序",{"2":{"201":1}}],["操作系统组成",{"0":{"461":1}}],["操作系统死锁的问题",{"0":{"409":1}}],["操作系统重启",{"2":{"179":1}}],["操作系统会按照cpu硬件要求",{"2":{"153":1}}],["操作系统会在用户空间和内核空间分别分配两段栈",{"2":{"153":1}}],["操作系统也会记录每个线程的控制信息",{"2":{"153":1}}],["操作系统保存的进程控制信息自然是在内核空间",{"2":{"153":1}}],["操作系统运行在内核空间",{"2":{"153":1}}],["操作系统为了跟踪每个进程的活动状态",{"2":{"153":1}}],["操作系统",{"0":{"123":1},"1":{"137":1,"153":1,"167":1,"179":1,"190":1,"201":1,"212":1,"221":1,"229":1,"237":1,"245":1,"252":1,"259":1,"265":1,"271":1,"277":1,"283":1,"289":1,"295":1,"301":1,"307":1,"313":1,"319":1,"325":1,"331":1,"337":1,"343":1,"349":1,"355":1,"361":1,"367":1,"373":1,"379":1,"384":1,"389":1,"393":1,"397":1,"401":1,"405":1,"409":1,"413":1,"417":1,"421":1,"425":1,"429":1,"433":1,"437":1,"441":1,"445":1,"449":1,"453":1,"457":1,"461":1,"465":1,"469":1,"473":1,"477":1,"481":1,"485":1,"489":1,"493":1,"497":1,"501":1,"505":1,"509":1,"513":1,"517":1,"521":1,"525":1},"2":{"77":1,"123":1}}],["原则",{"2":{"580":1}}],["原语写个生产者消费者模型",{"2":{"525":1}}],["原子性",{"2":{"261":1,"303":1}}],["原理",{"0":{"537":1},"2":{"77":1}}],["原因就是因为计算不是短板",{"2":{"473":1}}],["原因其实就是",{"2":{"285":1}}],["原因",{"0":{"2":1},"2":{"285":1}}],["多协程竞争",{"2":{"549":1}}],["多进程和多线程的区别",{"2":{"525":1}}],["多种引擎的实现区别",{"0":{"450":1}}],["多种应用可以使用同一个运输层服务",{"2":{"129":1}}],["多个服务器怎么保存session一致性",{"0":{"519":1}}],["多个请求进行复用",{"2":{"411":1}}],["多个线程不能同时使用一个资源",{"2":{"401":1}}],["多个线程共享同一进程内的资源",{"2":{"167":1}}],["多个协程可以由一个或多个线程管理",{"2":{"396":1}}],["多叉搜索树",{"2":{"345":1}}],["多版本的并发控制",{"2":{"297":1}}],["多版本并发控制",{"2":{"279":1}}],["多对多通信",{"2":{"241":1}}],["多对一",{"2":{"241":1}}],["多路复用程序",{"2":{"230":1}}],["多路复用",{"2":{"222":1}}],["多路归并",{"0":{"76":1}}],["多级队列",{"2":{"201":1}}],["多线程线程的弊端",{"0":{"325":1}}],["多线程中会对全局变量进行pad操作",{"0":{"283":1}}],["多线程怎么应付同样的问题",{"2":{"178":1}}],["多线程服务器和",{"2":{"178":1}}],["多少",{"0":{"19":1}}],["匹马",{"0":{"70":1}}],["匹马要怎么做呢",{"0":{"70":1}}],["匹马要决出最快的",{"0":{"70":1}}],["匹马五条赛道怎么最快选出前三个",{"0":{"36":1}}],["总是淘汰最先进入内存的页面",{"2":{"449":1}}],["总是在一段一段的链路上传送的",{"2":{"129":1}}],["总的来说",{"2":{"390":1}}],["总长度为",{"2":{"154":1}}],["总会变成一个raw编码的字符串对象",{"2":{"154":1}}],["总之",{"2":{"134":1}}],["总结就是",{"2":{"213":1,"230":1}}],["总结",{"0":{"69":1},"2":{"154":1,"390":1,"473":1,"543":1}}],["总能找到某些算法和数据结构的影子",{"2":{"35":1}}],["贪心可能会存在什么问题",{"0":{"68":1}}],["分一以上的人的名字",{"2":{"577":1}}],["分配的内存空间大小",{"2":{"543":1}}],["分配内存空间",{"2":{"543":1}}],["分块式的栈是最初go语言组织栈的方式",{"2":{"546":1}}],["分块",{"2":{"451":1}}],["分段分页是啥",{"2":{"525":1}}],["分段",{"0":{"445":1}}],["分页系统地址映射",{"0":{"445":1}}],["分页",{"0":{"445":1}}],["分析了栈帧",{"0":{"436":1}}],["分多钟",{"0":{"334":1}}],["分为悲观锁和乐观锁",{"2":{"309":1}}],["分别对应原子性atomicity",{"2":{"261":1}}],["分别有哪些例子",{"2":{"179":1}}],["分层",{"2":{"451":2}}],["分层可以将庞大而复杂的问题转化为若干较小的局部问题",{"2":{"206":1}}],["分层概念",{"2":{"172":1}}],["分钟才做的算法题",{"2":{"182":1}}],["分用和复用相反",{"2":{"129":1}}],["分库分表",{"0":{"559":1}}],["分库分表等",{"2":{"103":1}}],["分库分表后怎么保证主键仍然是递增的",{"2":{"59":1}}],["分库分表后怎么查询分页",{"2":{"59":1}}],["分治",{"0":{"98":1}}],["分布式id",{"0":{"569":1}}],["分布式锁实现方式比较多",{"2":{"320":1}}],["分布式锁原理",{"2":{"320":1}}],["分布式锁大概有哪几种实现方式",{"2":{"185":1}}],["分布式算法知道哪些",{"0":{"90":1}}],["分布式",{"0":{"65":1},"1":{"77":1,"90":1,"102":1}}],["手撕数据库连接池",{"2":{"587":1}}],["手撕顺时针打印二维矩阵",{"0":{"81":1}}],["手撕堆排",{"0":{"64":1}}],["手写快排",{"0":{"41":1}}],["手写了数学",{"2":{"29":1}}],["手写代码",{"0":{"15":1,"107":1,"119":1,"317":1}}],["然而面试官在给出题目的时候不像平时做题时给出一个要求的函数签名",{"2":{"63":1}}],["然后每个",{"2":{"587":1}}],["然后每次加载rdb的时候我们就不会加载过期的k",{"2":{"213":1}}],["然后从常用的",{"2":{"586":1}}],["然后告知执行器执行完成了",{"2":{"583":1}}],["然后任意session连接服务器",{"2":{"519":1}}],["然后解析每一个响应头",{"2":{"483":1}}],["然后利用网站的公钥将会话秘钥加密并传送给网站",{"2":{"471":1}}],["然后将该命令提交给浏览器进程",{"2":{"451":1}}],["然后将要插入的元素放置到插入位置即可",{"2":{"35":1}}],["然后进行数据的传输",{"2":{"439":1}}],["然后通过进程间通信",{"2":{"439":1}}],["然后通过链进行o",{"2":{"363":1}}],["然后做一些查询试试",{"2":{"434":1}}],["然后仔细分析explain",{"0":{"422":1}}],["然后获取整行数据",{"2":{"390":1}}],["然后看见面试官一脸诧异的看着我才反应过来orz",{"2":{"387":1}}],["然后问我如果",{"2":{"587":1}}],["然后问知道哪些http方法",{"0":{"475":1}}],["然后问对磁盘有什么优势夺命追问",{"2":{"345":1}}],["然后问怎么排序的",{"2":{"154":1}}],["然后面试官稍微提醒了下",{"0":{"311":1}}],["然后面试官提醒我一种思路就是先正常层次遍历",{"2":{"87":1}}],["然后sessiona执行commit",{"2":{"285":1}}],["然后开启事务",{"2":{"285":1}}],["然后事务",{"2":{"267":1}}],["然后读了一下最新的",{"2":{"267":1}}],["然后执行逻辑的过程中",{"2":{"267":1}}],["然后现场面",{"0":{"257":1}}],["然后主线程根据命令找到对应的事件处理器",{"2":{"230":1}}],["然后找到一个io线程去读取数据",{"2":{"230":1}}],["然后使用经典案例",{"2":{"214":1}}],["然后遍历奇数位与这个栈进行",{"0":{"186":1}}],["然后分布式锁性能有点差",{"2":{"185":1}}],["然后又问有序集合zset的时间复杂度",{"2":{"154":1}}],["然后又加难度",{"0":{"19":1}}],["然后再返回",{"2":{"583":1}}],["然后再介绍二者的区别",{"2":{"543":1}}],["然后再根据布局树的每个节点计算出其具体位置和尺寸大小",{"2":{"451":1}}],["然后再说自己是怎么做",{"2":{"390":1}}],["然后再引入索引原理的查询过程",{"2":{"390":1}}],["然后再通过主键索引中的",{"2":{"390":1}}],["然后再去redis里面查询",{"2":{"320":1}}],["然后再执行修改命令",{"2":{"154":1}}],["然后再将执行操作所得的浮点数值转换回字符串值",{"2":{"154":1}}],["然后再将新的数据插入",{"2":{"45":1}}],["然后去中断向量表这里查询0x80对应的系统调用派发程序入口",{"2":{"153":1}}],["然后用int",{"2":{"153":1}}],["然后打印的",{"2":{"87":1}}],["然后写函数",{"2":{"63":1}}],["然后就扯到",{"0":{"62":1}}],["然后",{"0":{"55":1},"2":{"587":2}}],["然后在每个方格加一个权值",{"0":{"19":1}}],["然后让优化",{"0":{"12":1}}],["然后相邻两个数只能选一个",{"0":{"9":1}}],["函数",{"0":{"368":1},"2":{"63":1}}],["线上开启slowlog",{"0":{"422":1}}],["线上ide只有一个默认的",{"2":{"63":1}}],["线程独立拥有哪些资源",{"2":{"525":1}}],["线程之间的通信",{"2":{"525":1}}],["线程之间的通信方式",{"0":{"301":1}}],["线程和进程之间哪个快",{"2":{"525":1}}],["线程和协程推荐在io密集型的任务",{"2":{"153":1,"167":1}}],["线程间共享的有哪些东西",{"2":{"525":1}}],["线程究竟是由什么组成的",{"0":{"349":1}}],["线程池",{"0":{"307":1}}],["线程的区别",{"0":{"396":1}}],["线程的上下文切换",{"0":{"259":1,"331":1}}],["线程的调度与切换比进程快很多",{"2":{"167":1}}],["线程负责读写数据并且执行命令",{"2":{"230":1}}],["线程模型",{"0":{"222":1}}],["线程共享的有什么",{"0":{"221":1}}],["线程安全的map锁分段的细节",{"0":{"219":1}}],["线程可以运行",{"2":{"201":1}}],["线程可以通过直接读写同一进程中的数据进行通信",{"2":{"153":1}}],["线程处于就绪状态时",{"2":{"201":1}}],["线程与cpu资源分配无关",{"2":{"167":1}}],["线程免不了要调用os提供的系统服务",{"2":{"153":1}}],["线程中发生函数调用时就会在线程栈中分配函数调用栈",{"2":{"153":1}}],["线程id",{"2":{"153":1}}],["线程栈",{"2":{"153":1}}],["线程切换到内核态执行时会使用内核栈",{"2":{"153":1}}],["线程执行时要使用从进程虚拟地址空间中分配的栈空间来存储数据",{"2":{"153":1}}],["线程就是进程中的执行体",{"2":{"153":1}}],["线程是独立运行和独立调度的基本单位",{"2":{"153":1,"167":1}}],["线程",{"0":{"137":1,"153":1},"1":{"153":1,"167":1,"179":1,"190":1,"201":1,"212":1,"221":1,"229":1,"237":1,"245":1,"252":1,"259":1,"265":1,"271":1,"277":1,"283":1,"289":1,"295":1,"301":1,"307":1,"313":1,"319":1,"325":1,"331":1,"337":1,"343":1,"349":1,"355":1},"2":{"153":1,"397":2,"401":2}}],["线性表就是数据排成像一条线一样的结构",{"2":{"28":1}}],["则是",{"2":{"580":1}}],["则只要",{"2":{"580":1}}],["则往往不容易保证有序插入",{"2":{"580":1}}],["则怎么办",{"2":{"572":1}}],["则该连接会保持一段时间",{"2":{"483":1}}],["则服务器主动关闭tcp连接",{"2":{"483":1}}],["则解决",{"2":{"455":1}}],["则表示重定向",{"2":{"439":1}}],["则还需要发送请求体",{"2":{"439":1}}],["则右子树上所有节点的值均大于它的根节点的值",{"2":{"426":1}}],["则右子树上所有结点的值均大于它的根结点的值",{"2":{"63":1}}],["则左子树上所有节点的值均小于它的根节点的值",{"2":{"426":1}}],["则左子树上所有结点的值均小于它的根结点的值",{"2":{"63":1}}],["则在对应hash键下以链表形式存储",{"2":{"345":1}}],["则",{"2":{"335":2,"543":1}}],["则后一个事务所读取的数据就会是不正确的",{"2":{"267":1}}],["则一概不闻不问",{"2":{"229":1}}],["则把数据报传送给路由表中所指明的默认路由器",{"2":{"195":1}}],["则把数据报传送给路由表中所指明的下一跳路由器",{"2":{"195":1}}],["则把数据报传送给路由表指明的下一跳路由器",{"2":{"195":1}}],["则把数据报直接交付目的主机d",{"2":{"195":1}}],["则最大的",{"0":{"187":1}}],["则有一定的性能消耗",{"2":{"45":1}}],["了解icmp",{"2":{"572":1}}],["了解ping",{"2":{"572":1}}],["了解pasox算法吗",{"0":{"102":1}}],["了解dns",{"2":{"572":1}}],["了解quic",{"2":{"572":1}}],["了解过拥塞控制吗",{"2":{"572":1}}],["了解多少",{"2":{"572":1}}],["了解吗",{"2":{"572":1}}],["了解中间件吗",{"0":{"534":1}}],["了解虚拟内存吗",{"0":{"433":1}}],["了解mysql中的索引",{"0":{"426":1}}],["了解内存泄漏吗",{"0":{"282":1}}],["了解锁么",{"0":{"237":1}}],["了解",{"0":{"419":1,"479":1},"2":{"178":1}}],["了解golang的渐进式哈希的过程",{"2":{"154":1}}],["了解原理吗",{"0":{"31":1}}],["了",{"0":{"62":1},"2":{"390":1,"587":1}}],["问一个数据是怎么写到磁盘上去的",{"2":{"525":1}}],["问我502",{"2":{"382":1}}],["问我实际场景什么时候用302",{"2":{"382":1}}],["问为什么",{"2":{"345":1}}],["问题定位",{"0":{"505":1}}],["问题",{"2":{"195":1,"583":1}}],["问了",{"2":{"587":1}}],["问了网络的协议栈",{"0":{"206":1}}],["问了下实习的工作",{"2":{"185":1}}],["问了大概",{"2":{"182":1}}],["问还有吗",{"0":{"62":1}}],["问第一个抛的人赢的概率",{"0":{"57":1}}],["瞬时写入量很大可能会打挂存储",{"2":{"59":1}}],["翻页的方式",{"2":{"59":1}}],["量有多大",{"2":{"59":1}}],["吗",{"0":{"419":1},"2":{"59":1}}],["杂度有点大",{"2":{"58":1}}],["空行和响应数据组成",{"2":{"483":1}}],["空行和请求数据组成",{"2":{"483":1}}],["空闲的",{"2":{"177":1}}],["空树或者具有如下性质的二叉树",{"2":{"63":1}}],["空间复杂度要求",{"2":{"58":1}}],["空转时长较大的那些键可能会优先被服务器删除",{"2":{"6":1}}],["98",{"0":{"524":1}}],["99",{"2":{"473":1}}],["90235335",{"2":{"279":1,"297":1,"321":1}}],["9",{"0":{"359":1},"2":{"58":2}}],["700",{"2":{"451":1}}],["737060cd8c284d8af7ad3082f209582d",{"2":{"387":1}}],["7层协议",{"0":{"116":1,"129":1},"1":{"129":1,"145":1,"159":1,"172":1,"184":1,"195":1,"206":1,"217":1,"225":1}}],["7",{"0":{"175":3},"2":{"58":2,"572":1}}],["例如每个语句最后不需要加上分号",{"2":{"546":1}}],["例如一个计算圆周率至小数点一千位以下的程序",{"2":{"469":1}}],["例如事务的隔离是如何实现的",{"0":{"327":1}}],["例如server说要关闭之后",{"2":{"274":1}}],["例如有一个事务查询了几列",{"2":{"267":1}}],["例如根节点到叶子节点的一条路径是",{"2":{"182":1}}],["例如接下来要从线程a1切换到线程a2",{"2":{"153":1}}],["例如x86的sysenter",{"2":{"153":1}}],["例如linux系统中",{"2":{"153":1}}],["例如执行入口",{"2":{"153":1}}],["例如进程和父进程id",{"2":{"153":1}}],["例如域名系统",{"2":{"129":1}}],["例如表锁",{"0":{"482":1}}],["例如表",{"2":{"103":1}}],["例如字符串",{"2":{"87":1}}],["例如",{"2":{"58":1,"96":1,"103":1,"172":1,"390":1}}],["符号相同的数字相对顺序不变",{"2":{"58":1}}],["抛到正面的人赢",{"0":{"57":1}}],["抛到正面为止",{"0":{"57":1}}],["效率的优化就要尽可能做到极致",{"2":{"56":1}}],["那应该用身份证号做主键",{"2":{"580":1}}],["那链路层的协议有哪些啊",{"0":{"564":1}}],["那线程",{"2":{"401":1}}],["那些不必要的索引反而会使查询反应时间变慢",{"2":{"357":1}}],["那为什么它们的",{"0":{"316":1}}],["那可重复读能解决什么",{"2":{"315":1}}],["那每一个事务隔离级别分别解决了什么问题呢",{"0":{"315":1}}],["那悲观锁和乐观锁在基于",{"2":{"309":1}}],["那acid靠什么保证的呢",{"2":{"303":1}}],["那就出现了不可重复读",{"2":{"279":1}}],["那样数据库也失去了并发处理能力",{"2":{"267":1}}],["那来谈谈事务的实现原理吧",{"2":{"240":1}}],["那又和惰性删除一样了",{"2":{"213":1}}],["那么每个二级索引的叶子节点占用约",{"2":{"580":1}}],["那么从输入一个",{"2":{"572":1}}],["那么就可以做到window系统编译linux的应用",{"2":{"546":1}}],["那么一个子进程",{"2":{"525":1}}],["那么因为表的间隙mysql自动帮我们生成了区间",{"2":{"482":1}}],["那么新页面会复用父页面的渲染进程",{"2":{"443":1}}],["那么其中",{"2":{"439":1}}],["那么其通信就会无阻塞地进行",{"2":{"235":1}}],["那么下一个请求就不发送",{"2":{"403":1}}],["那么具体怎么做呢",{"2":{"401":1}}],["那么线程",{"2":{"397":1}}],["那么查询过程又是怎样的呢",{"2":{"390":1}}],["那么问题来了",{"2":{"390":1}}],["那么对于mysql来说为什么采用b+树而不采用b树",{"0":{"369":1}}],["那么我们就会存储一个delete在undo",{"2":{"267":1}}],["那么通道就是异步的",{"2":{"235":1}}],["那么redis的io多路复用就可以答出来了",{"2":{"230":1}}],["那么应该由谁来处理孤儿进程的善后事宜呢",{"2":{"229":1}}],["那么",{"2":{"229":2}}],["那么只要这个过期",{"2":{"213":1}}],["那么必须选择接下来哪个进程",{"2":{"201":1}}],["那么路由器收到数据报后如何转发呢",{"2":{"195":1}}],["那么可以针对报文的报头部分进行访问控制",{"2":{"184":1}}],["那么这个子进程",{"2":{"525":1}}],["那么这个进程将会一直等待下去",{"2":{"485":1}}],["那么这个时候只有一个线程能抢到这个锁",{"2":{"320":1}}],["那么这条路径就用",{"2":{"182":1}}],["那么这就涉及到线程切换",{"2":{"153":1}}],["那么字符串对象会将整数值保存在字符串对象结构的ptr",{"2":{"154":1}}],["那么除了线程切换外还有涉及到进程切换",{"2":{"153":1}}],["那么程序就可能不会报任何错误",{"2":{"45":1}}],["那我们计算数组元素",{"2":{"56":1}}],["05",{"2":{"543":1}}],["04",{"2":{"543":1}}],["03",{"2":{"543":1}}],["02",{"2":{"543":1}}],["0将下面的传输层从tcp改成了udp",{"2":{"415":1}}],["0规定下一个请求必须在前一个请求响应到达之后才能发送",{"2":{"403":1}}],["0各自的优缺点",{"0":{"399":1},"1":{"403":1,"407":1,"411":1,"415":1}}],["06",{"2":{"397":1}}],["00",{"2":{"387":4}}],["08",{"2":{"387":1}}],["01",{"0":{"299":1},"2":{"387":3}}],["0以前binlog的格式",{"2":{"285":1}}],["0中引入了异步io线程",{"2":{"230":1}}],["0的多线程模型去讲解",{"2":{"230":1}}],["07",{"2":{"229":2}}],["0之前也不是真正的单线程",{"2":{"222":1,"230":1}}],["0之后",{"2":{"202":1,"230":1}}],["0−9",{"0":{"182":1}}],["0引入的全新数据结构",{"2":{"154":1}}],["0引入的数据结构",{"2":{"154":1}}],["0x80来触发系统调用中断",{"2":{"153":1}}],["0x80",{"2":{"91":2}}],["0",{"0":{"61":1,"162":3,"287":1,"311":1,"323":1,"359":3,"399":2,"403":1,"411":1,"415":1,"487":1},"1":{"403":2,"407":2,"411":2,"415":2},"2":{"56":3,"91":1,"180":9,"202":3,"329":1,"335":1,"387":1,"451":2,"491":1,"543":2,"572":1}}],["下四层和",{"2":{"159":1}}],["下标",{"2":{"56":1}}],["下载安装程序",{"0":{"4":1}}],["从业务场景出发",{"2":{"586":1}}],["从性能和存储空间方面考量",{"2":{"580":1}}],["从自己理解的角度看",{"2":{"546":1}}],["从辅助索引中查询得到记录",{"2":{"390":1}}],["从长序列中找出前",{"0":{"317":1}}],["从而不能处理其他的请求",{"2":{"397":1}}],["从而避免回表",{"2":{"390":1}}],["从而避免了互斥等待",{"2":{"297":1}}],["从而优化对象在不同场景下的使用效率",{"2":{"6":1}}],["从多版本和锁机制来讲",{"2":{"267":1}}],["从上面无缓冲的通道定义来看",{"2":{"235":1}}],["从redis6",{"2":{"230":1}}],["从redis",{"2":{"230":1}}],["从头到尾",{"2":{"213":1}}],["从库一直都是等主库的删除才删除",{"2":{"213":1}}],["从库虽然对于过期的key返回null",{"2":{"213":1}}],["从库发现过期也会直接返回",{"2":{"213":1}}],["从服务器上不可能删除自己的key的",{"2":{"213":1}}],["从服务器永远不会删除自己的key",{"2":{"213":1}}],["从数据结构的角度看",{"2":{"390":1}}],["从数据库中取出一定数量的",{"2":{"213":1}}],["从数组存储的内存模型上来看",{"2":{"56":1}}],["从路由表",{"2":{"195":1}}],["从底层数据结构来讲",{"2":{"154":1}}],["从value的类型来讲",{"2":{"154":1}}],["从专用寄存器拿到派发入口的地址",{"2":{"153":1}}],["从根节点出发",{"0":{"100":1}}],["从",{"0":{"359":1},"2":{"56":1,"285":1}}],["洗一次播一首非要再洗一次来手动提升复杂度",{"0":{"55":1}}],["洗一次直接输出就完了",{"0":{"55":1}}],["洗牌算法",{"0":{"55":1}}],["说详细具体过程",{"0":{"290":1}}],["说一下url的格式",{"0":{"495":1}}],["说一下每个隔离的区别",{"0":{"285":1}}],["说一下归并排序和复杂度",{"0":{"52":1}}],["说说你所知道的网络定时器的机制",{"0":{"556":1}}],["说说你用过的设计模式",{"0":{"143":1}}],["说说子网掩码以及网关的作用",{"2":{"548":1}}],["说说数据库事务的特性",{"2":{"261":1}}],["说这是运维的工作",{"0":{"246":1}}],["说了",{"2":{"185":1,"345":1}}],["说了分布式锁",{"2":{"185":1}}],["说了力扣编辑距离",{"0":{"62":1}}],["说特定的",{"0":{"107":1}}],["说思路",{"0":{"82":1}}],["说",{"2":{"58":1}}],["说下常见的排序稳定性和复杂度",{"0":{"24":1}}],["找个",{"2":{"572":1}}],["找名人",{"0":{"335":1}}],["找到对应的叶子节点",{"2":{"390":1}}],["找到对应的系统函数入口",{"2":{"153":1}}],["找到不同的字符串数量",{"0":{"111":1}}],["找到s中最长的回文子串",{"0":{"50":1}}],["找出数组b里面比数组a大的所有数",{"0":{"218":1}}],["找出二叉树中从根节点到叶子节点的路径和等于那个值的路径",{"0":{"204":1}}],["找出根节点到叶子节点的所有路径表示的数字之和",{"2":{"182":1}}],["找出一个数组中长度等于k且阈值大于等于threshold的所有连续的子数组",{"0":{"106":1}}],["找出前100个最大的",{"0":{"49":1}}],["找虫子",{"0":{"29":1}}],["口述",{"0":{"49":1}}],["口述快排并实现",{"0":{"41":1}}],["给出应该有哪些数据表",{"2":{"587":1}}],["给你一个数字",{"0":{"365":1}}],["给两个数组",{"0":{"329":1}}],["给消息进行一个编号叫序列号",{"2":{"274":1}}],["给一个数组",{"0":{"187":1}}],["给一个出栈序列长度为",{"0":{"47":1}}],["给定一张表",{"0":{"576":1}}],["给定一个值",{"0":{"204":1}}],["给定一个仅包含数字",{"0":{"182":1}}],["给定一个二叉树",{"0":{"100":1}}],["给定一个字符串",{"0":{"87":1}}],["给定一个字符串s",{"0":{"50":1}}],["给定一个数组",{"2":{"58":1}}],["给定",{"0":{"44":1},"2":{"335":1}}],["给定时间和任务",{"0":{"33":1}}],["6844903763665240072",{"2":{"491":1}}],["69代表tftp",{"2":{"340":1}}],["600",{"0":{"323":1}}],["6+4+5",{"0":{"187":1}}],["6379>",{"2":{"180":4}}],["64",{"0":{"70":1}}],["6",{"0":{"94":1,"175":3,"187":1},"2":{"58":2,"154":1,"195":1,"222":1,"230":2,"390":1,"439":1,"525":1}}],["6个跑道",{"0":{"46":1}}],["67",{"0":{"9":1}}],["毕竟损耗一丢丢性能",{"2":{"45":1}}],["提到了通过系统调用与中断来进入内核",{"2":{"525":1}}],["提示资源加载速度",{"2":{"439":1}}],["提取慢查询",{"0":{"422":1}}],["提取两个海量",{"0":{"98":1}}],["提高了网络的利用率",{"2":{"407":1}}],["提交事务时",{"2":{"587":1}}],["提交文档",{"2":{"447":1}}],["提交文档阶段",{"0":{"447":1}}],["提交读和可重复读的实现原理",{"0":{"291":1}}],["提交成功",{"2":{"285":2}}],["提交信息",{"2":{"2":1}}],["提出了有名管道",{"2":{"179":1}}],["提供了几种同步资源的方式",{"2":{"221":1}}],["提供无连接",{"2":{"129":1}}],["提供面向连接",{"2":{"129":1}}],["提供的大部分方法",{"2":{"45":1}}],["用你刚刚设计的表来给我查询出全校所有高数在",{"2":{"577":1}}],["用你最熟悉的语言把这个算法实现",{"0":{"377":1}}],["用什么数据结构",{"2":{"572":1}}],["用什么语句实现数据库锁",{"0":{"474":1}}],["用运行速度极快的c语言替换用python这样运行速度极低的脚本语言",{"2":{"473":1}}],["用来记录一个页面自上次被访问以来所经历的时间",{"2":{"449":1}}],["用来把各个中断编号映射到相应的处理程序",{"2":{"153":1}}],["用法",{"0":{"336":1}}],["用栈先序遍历二叉树",{"0":{"223":1}}],["用一个数字表示",{"0":{"182":1}}],["用一句话概括streams就是redis实现的内存版kafka",{"2":{"154":1}}],["用套接字中的相关函数来完成通信过程",{"2":{"179":1}}],["用于",{"2":{"584":1}}],["用于日志重放",{"2":{"584":1}}],["用于当内存快要满的时候如何释放部分内存",{"2":{"202":1}}],["用于多进程对共享数据的访问",{"2":{"179":1}}],["用于通知接收进程某个事件已经发生",{"2":{"179":1}}],["用于通过系统调用编号",{"2":{"153":1}}],["用于具有亲缘关系的父子进程间或者兄弟进程之间的通信",{"2":{"179":1}}],["用于为多个进程提供对共享数据对象的访问",{"2":{"179":1}}],["用于两个相关进程间通信",{"2":{"179":1}}],["用的是redis的3",{"2":{"213":1}}],["用的是",{"2":{"154":1}}],["用过",{"2":{"154":1}}],["用这种方法来实现多线程的效果",{"2":{"153":1}}],["用户名",{"2":{"495":1}}],["用户输入完内容",{"2":{"435":1}}],["用户输入",{"2":{"435":1}}],["用户输入阶段",{"0":{"435":1}}],["用户在浏览器输入网址后到呈现页面的详细步骤",{"2":{"431":1}}],["用户为了让本网络中的主机与其他网络中的主机进行通信",{"2":{"195":1}}],["用户态和内核态",{"0":{"252":1,"337":1}}],["用户态",{"2":{"153":1}}],["用户记录当前程序是在用户态还是内核态",{"2":{"153":1}}],["用户程序运行在用户空间",{"2":{"153":1}}],["用户数据报协议",{"2":{"129":1}}],["用了堆",{"0":{"76":1}}],["用",{"0":{"287":1},"2":{"59":1,"77":1}}],["用得怎么样",{"2":{"59":1}}],["用数组往往会更加直观",{"2":{"45":1}}],["用数组会更合适些",{"2":{"45":1}}],["用不到",{"2":{"45":1}}],["类型的对象",{"2":{"543":1}}],["类型",{"2":{"443":1}}],["类似二叉搜索树",{"2":{"345":1}}],["类似于数据结构中简单实现的hash表",{"2":{"345":1}}],["类似的语句",{"2":{"309":1}}],["类似b",{"2":{"169":1}}],["类似问题",{"2":{"120":1,"150":2,"154":2,"164":1,"179":2,"225":1,"235":1,"261":2,"273":3,"274":1,"292":1,"297":1,"315":1,"345":10,"375":1,"382":1,"387":1,"431":1,"560":1}}],["类",{"2":{"45":1}}],["无状态",{"2":{"403":2}}],["无法复用连接",{"2":{"403":1}}],["无法把前缀索引用作覆盖索引",{"2":{"390":1}}],["无法存储基本类型",{"2":{"45":1}}],["无论查找是否成功",{"2":{"375":1}}],["无序中位数找第",{"0":{"263":1}}],["无序数组中找出连续的数中第一个缺失的数字",{"0":{"198":1}}],["无连接",{"2":{"241":1,"403":2}}],["无连接的数据报传递服务",{"2":{"172":1}}],["无缓冲的通道指的是通道的大小为0",{"2":{"235":1}}],["无缓冲",{"0":{"235":1}}],["无疑会对服务器的响应时间和吞吐量造成影响",{"2":{"213":1}}],["无名管道",{"2":{"179":2}}],["无限的任意点开始爬",{"2":{"29":1}}],["juejin",{"2":{"491":1}}],["jd",{"2":{"390":1}}],["j",{"2":{"335":7}}],["jingyan",{"2":{"177":1}}],["json",{"2":{"134":5,"439":1}}],["java线程区别",{"0":{"312":1}}],["javaguide",{"2":{"179":1}}],["java",{"0":{"396":1},"2":{"45":1}}],["jvm",{"2":{"35":2}}],["有这样一个查询",{"2":{"576":1}}],["有写",{"0":{"575":1}}],["有哪几",{"0":{"570":1}}],["有哪些组成",{"2":{"525":1}}],["有哪些数据",{"0":{"349":1}}],["有哪些数据被重复接收了",{"2":{"268":1}}],["有没有什么场景适合用业务字段直接做主键的呢",{"2":{"580":1}}],["有没有搭过mysql",{"0":{"553":1}}],["有没有别的方法",{"2":{"185":1}}],["有",{"2":{"525":1}}],["有两个作用",{"2":{"467":1}}],["有两个字符串",{"0":{"125":1}}],["有个机制",{"2":{"439":1}}],["有则直接返回",{"2":{"439":1}}],["有效提高索引的查询速度",{"2":{"390":1}}],["有一种特殊的索引是联合索引你知道么",{"2":{"369":1}}],["有一个私有密钥和公有密钥",{"2":{"467":1}}],["有一个高并发的场景该怎么处理",{"0":{"360":1}}],["有一个序列",{"0":{"311":1}}],["有一个单链表",{"0":{"186":1}}],["有利于更快地缩小查找范围",{"2":{"363":1}}],["有零钱1",{"0":{"347":1}}],["有序",{"2":{"345":1}}],["有序集合是什么",{"2":{"154":1}}],["有多少个进程",{"2":{"525":1}}],["有多少个名人",{"2":{"335":1}}],["有多少种入栈的可能",{"0":{"47":1}}],["有多少种做法",{"0":{"19":1}}],["有几种插入方法",{"0":{"323":1}}],["有些业务的场景需求是这样的",{"2":{"580":1}}],["有些事务尚未完成就被迫中断",{"2":{"261":1}}],["有些时候",{"2":{"45":1}}],["有的不支持事务",{"2":{"248":1}}],["有的存储引擎支持事务",{"2":{"248":1}}],["有缓冲无缓冲如何定义",{"2":{"235":1}}],["有缓冲通道内部有一个类似于队列机制的缓冲区",{"2":{"235":1}}],["有缓冲",{"0":{"235":1}}],["有点类似于分治",{"2":{"206":1}}],["有更早过期时间的",{"2":{"202":1}}],["有如下3种情况",{"2":{"201":1}}],["有名管道以磁盘文件的方式存在",{"2":{"179":1}}],["有名管道严格遵循先进先出",{"2":{"179":1}}],["有名管道",{"2":{"179":1}}],["有什么缺点",{"2":{"572":1}}],["有什么好处",{"0":{"534":1}}],["有什么差别",{"2":{"525":1}}],["有什么区别",{"0":{"530":1,"533":1},"2":{"525":1}}],["有什么方式可以避免回表呢",{"2":{"390":1}}],["有什么方法可以避免",{"0":{"292":1}}],["有什么危害",{"0":{"282":1}}],["有什么特色",{"2":{"154":1}}],["有什么用",{"2":{"154":1,"572":1}}],["是针对",{"2":{"587":1}}],["是怎么利用索引的",{"2":{"587":1}}],["是怎么实现的",{"2":{"154":1}}],["是保证强一致性",{"2":{"586":1}}],["是域名系统",{"2":{"560":1}}],["是必用的",{"2":{"543":1}}],["是超文本传输协议",{"2":{"455":1,"479":1}}],["是每一个叶子节点最终都保留了一整行的记录信息",{"2":{"345":1}}],["是数据库管理系统中一个排序的数据结构",{"2":{"339":1}}],["是如何实现的呢",{"2":{"309":1}}],["是主动断开连接的一方还是被动断开的一方",{"0":{"292":1}}],["是发出去的包丢了",{"2":{"268":1}}],["是",{"2":{"267":2,"584":2}}],["是指一个事务的执行不能被其他事务干扰",{"2":{"261":1}}],["是指一个事务操作不可分割",{"2":{"261":1}}],["是指这些数据在事务执行完成这个时间点之前",{"2":{"261":1}}],["是什么关系",{"0":{"572":1}}],["是什么",{"0":{"560":1},"2":{"261":1}}],["是客户端向服务端首先发送fin报文",{"2":{"256":1}}],["是通过序列号",{"2":{"249":1}}],["是没问题的",{"2":{"233":1}}],["是共享的",{"2":{"221":1}}],["是否了解过b+树之外的索引结构",{"0":{"587":1}}],["是否了解",{"2":{"572":1}}],["是否有丢失",{"2":{"572":1}}],["是否可以集成报警系统",{"2":{"320":1}}],["是否过期",{"2":{"213":2}}],["是否是",{"2":{"212":1}}],["是否包含",{"0":{"125":1}}],["是最快的ipc方式",{"2":{"179":1}}],["是一个计数器",{"2":{"179":1}}],["是一种二叉排序树",{"2":{"426":1}}],["是一种半双工的通信方式",{"2":{"179":1}}],["是一种什么存储结构",{"2":{"59":1}}],["是一种线性表数据结构",{"2":{"28":1}}],["是并发安全的吗",{"0":{"157":1}}],["是为了平摊我们的耗时",{"2":{"154":1}}],["是程序独立调度的基本单位",{"2":{"153":1}}],["是资源分配的基本单位",{"2":{"153":1}}],["是运输层把收到的信息分别交付上面应用层中的相应进程",{"2":{"129":1}}],["是对数组的封装",{"2":{"120":1}}],["是不是数组就无用武之地了呢",{"2":{"45":1}}],["是比较耗时的",{"2":{"45":1}}],["倍大小",{"2":{"45":1}}],["将要退化为表锁",{"2":{"466":1}}],["将四次挥手断开连接",{"2":{"439":1}}],["将数据库字段数据转换成定长的hash值",{"2":{"345":1}}],["将数据库查出的结果保存到redis缓存中",{"2":{"320":1}}],["将binlog的格式binlog",{"2":{"285":1}}],["将",{"2":{"213":1,"439":1,"451":1}}],["将最近最少使用的数据淘汰",{"2":{"202":1}}],["将访问频率最少得键值对淘汰",{"2":{"202":1}}],["将这个链表调整为整体升序",{"0":{"197":1}}],["将目的地址与路由表中的子网掩码相与",{"2":{"195":1}}],["将进入终止状态",{"2":{"190":1}}],["将void",{"2":{"154":1}}],["将会重新导航",{"2":{"439":1}}],["将会在响应头的",{"2":{"439":1}}],["将会是当前读",{"2":{"240":1}}],["将会触发扩容",{"2":{"108":1}}],["将会赋对应类型的零值",{"2":{"96":1}}],["将原来的数据复制过去",{"2":{"45":1}}],["将a",{"2":{"35":1}}],["它代表",{"2":{"543":1}}],["它包含了请求方法",{"2":{"439":1}}],["它或者是一颗空树",{"2":{"426":1}}],["它更适合做等值的查询",{"2":{"390":1}}],["它可应用到响应链上的任何接收方\\tpragma",{"2":{"387":1}}],["它相对于内存来说是很慢的",{"2":{"375":1}}],["它是要占据物理空间的",{"2":{"339":1}}],["它是与具体某一函数无关的",{"2":{"221":1}}],["它们包含着对数据表里所有记录的引用指针",{"2":{"339":1}}],["它记录了需要回滚的日志信息",{"2":{"303":1}}],["它对数据库中数据的改变是持久的",{"2":{"261":1}}],["它产生的僵尸进程就变成了孤儿进程",{"2":{"229":1}}],["它定期的产生一个子进程",{"2":{"229":1}}],["它的使用场景一般是需要显式返回指针",{"2":{"543":1}}],["它的值",{"2":{"543":1}}],["它的已经退出的子进程",{"2":{"229":1}}],["它的父进程就已经退出了",{"2":{"229":1}}],["它的父进程需要调用wait",{"2":{"229":1}}],["它的左右子树也分别为二叉排序树",{"2":{"426":1}}],["它的左",{"2":{"63":1}}],["它在代码中是",{"2":{"221":1}}],["它会调用morestack函数",{"2":{"546":1}}],["它会分配一个8kb的内存空间来给goroutine的栈使用",{"2":{"546":1}}],["它会等到主服务器删除自己的key之后将命令同步到从服务器",{"2":{"213":1}}],["它会告诉我们返回的是一个列表",{"2":{"134":2}}],["它所占用的内存就不会释放",{"2":{"213":1}}],["它表示当运行内存超过最大设置内存时",{"2":{"202":1}}],["它由消息队列标识符进行标识",{"2":{"179":1}}],["它只有四层",{"2":{"172":1}}],["它负责监视数据在主机和网络之间的交换",{"2":{"172":1}}],["它负责接收中断信号",{"2":{"153":1}}],["它要求发送goroutine和接收goroutine同时准备好",{"2":{"235":1}}],["它要从这个线程开始执行",{"2":{"153":1}}],["它要有指定的执行入口",{"2":{"153":1}}],["它描述一个数组的片段",{"2":{"120":1}}],["它都会将空间自动扩容为",{"2":{"45":1}}],["它还有一个优势",{"2":{"45":1}}],["它用一组连续的内存空间",{"2":{"28":1}}],["另一个指向关键字最小的叶节点",{"2":{"375":1}}],["另一个事务在此时读取了同一份数据",{"2":{"267":1}}],["另一个cpu处理b线程",{"2":{"212":1}}],["另一个对象用作键值对的值",{"2":{"7":1}}],["另外还会发送请求头",{"2":{"439":1}}],["另外",{"2":{"45":1,"390":2}}],["删除",{"2":{"267":1,"482":1}}],["删除过期",{"2":{"213":1}}],["删除操作也因此变得比较低效",{"2":{"69":1}}],["删除有序链表中重复元素",{"0":{"67":1}}],["删除数据时需要搬移其他数据等",{"2":{"45":1}}],["删除的效率是不是会提高很多呢",{"2":{"35":1}}],["所有非叶节点起到索引作用",{"2":{"375":1}}],["所有节点组成这棵树",{"2":{"375":1}}],["所有人都认识",{"2":{"335":1}}],["所有的http请求都必须等待这个丢了的包重传回来",{"2":{"415":1}}],["所有的服务器都会决定",{"2":{"399":1}}],["所有的叶子结点使用链表相连",{"2":{"375":2}}],["所有的叶子结点中包含了全部关键字的信息",{"2":{"345":1}}],["所有的非终端结点可以看成是索引部分",{"2":{"345":1}}],["所有的事务依次逐个执行",{"2":{"273":1,"279":1}}],["所有的讲解参考",{"2":{"188":1}}],["所有的内存空间都是可以自由访问的",{"2":{"45":1}}],["所有进程的内核空间",{"2":{"153":1}}],["所谓的建立连接以及套接字之类的",{"2":{"230":1}}],["所谓的创建和撤销进程",{"2":{"153":1}}],["所谓软中断",{"2":{"153":1}}],["所谓复用就是指多个应用层进程可同时使用下面运输层的服务",{"2":{"129":1}}],["所以是先写",{"2":{"587":1}}],["所以是不安全的",{"2":{"503":1}}],["所以不是幂等的",{"2":{"503":1}}],["所以不需要使用更多的通信次数",{"2":{"256":1}}],["所以提高io才会显著提升性能",{"2":{"473":1}}],["所以要高效利用cpu",{"2":{"473":1}}],["所以如果访问没有命中索引",{"2":{"466":1}}],["所以如果特别关注性能",{"2":{"45":1}}],["所以前期交换秘钥必须使用非对称加密算法",{"2":{"463":1}}],["所以合成线程会按照视口附近的图块来优先生成位图",{"2":{"451":1}}],["所以又会生成一棵只包含可见元素的布局树",{"2":{"451":1}}],["所以将分为多个子阶段",{"2":{"451":1}}],["所以线程",{"2":{"401":1}}],["所以更提倡使用",{"2":{"400":1}}],["所以接下来我们就来了解这部分内容",{"2":{"397":1}}],["所以你在面试时也要知道执行计划核心参数的含义",{"2":{"390":1}}],["所以缓存命中性没有b+树好",{"2":{"375":1}}],["所以b+树会比b树占用内存小",{"2":{"369":1}}],["所以简称为b树索引",{"2":{"345":1}}],["所以其他线程访问redis的时候直接可以获取到",{"2":{"320":1}}],["所以也就不用考虑其他索引的叶子节点大小的问题",{"2":{"580":1}}],["所以也就只有一个线程能操作这个数据库",{"2":{"320":1}}],["所以也与特定线程无关",{"2":{"221":1}}],["所以同一个事务select之间可能有其他事务修改了数据",{"2":{"279":1}}],["所以每次select的时候读的不是一个副本而是不同的副本",{"2":{"279":1}}],["所以会造成脏读",{"2":{"279":1}}],["所以写操作在读的过程中修改数据",{"2":{"279":1}}],["所以写代码的时候一定要警惕数组越界",{"2":{"45":1}}],["所以在面试中",{"2":{"267":1}}],["所以叫幻读",{"2":{"267":1}}],["所以这种基于修改的幻读情况在rr隔离级别是无法避免的",{"2":{"240":1}}],["所以它是理所当然地被共享的",{"2":{"221":1}}],["所以此策略只会使用很少的系统资源",{"2":{"213":1}}],["所以我们要减少io次数",{"2":{"375":1}}],["所以我们要先写出树的数据结构",{"2":{"63":1}}],["所以我认为它们最关键的点就是",{"2":{"212":1}}],["所以用a解决了x",{"2":{"181":1}}],["所以用户感觉不到程序的切换过程",{"2":{"153":1}}],["所以用户程序这里",{"2":{"153":1}}],["所以选a",{"2":{"169":1}}],["所以embstr编码的字符串对象实际上是只读的",{"2":{"154":1}}],["所以进程切换与线程切换的区别就是进程切换会导致地址空间等进程资源发生变化",{"2":{"153":1}}],["所以即使很短的时间片",{"2":{"153":1}}],["所以操作系统又实现了一张系统调用表",{"2":{"153":1}}],["所以系统调用发生时就得切换到内核态",{"2":{"153":1}}],["所以才说线程是操作系统调度和执行的基本单位",{"2":{"153":1}}],["所以栈基和栈指针寄存器会记录用户栈的位置",{"2":{"153":1}}],["所以想的解法时间复",{"2":{"58":1}}],["所以为了减少一次减法操作",{"2":{"56":1}}],["所以计算",{"2":{"56":1}}],["所以",{"2":{"45":1,"153":1,"213":2,"222":1,"390":3,"482":1,"580":1}}],["来",{"2":{"572":1}}],["来保证服务器的身份是可信的",{"2":{"455":1}}],["来保护访问",{"2":{"179":1}}],["来判断响应数据的类型",{"2":{"443":1}}],["来做索引",{"2":{"390":1}}],["来应答",{"2":{"387":1}}],["来告诉",{"2":{"268":1}}],["来减少删除操作对",{"2":{"213":1}}],["来代替",{"2":{"182":1}}],["来存储相同类型的一组数据",{"2":{"69":1}}],["来存储一组具有相同类型的数据",{"2":{"28":1}}],["来说",{"2":{"56":1}}],["来表示数组的首地址",{"2":{"56":1}}],["来攻击系统",{"2":{"45":1}}],["就瞎扯了",{"2":{"587":1}}],["就直接返回给执行器",{"2":{"583":1}}],["就随便说了一下",{"2":{"572":1}}],["就像",{"2":{"516":1}}],["就像我们刚刚举的那个例子",{"2":{"45":1}}],["就通知浏览器进程获取到的是",{"2":{"443":1}}],["就将该请求交给下载管理器",{"2":{"443":1}}],["就将搜索内容",{"2":{"435":1}}],["就处理了相互等待的死锁状态",{"2":{"397":1}}],["就无法匹配上联合索引",{"2":{"390":1}}],["就无法使用前缀索引",{"2":{"390":1}}],["就能查询更多的节点",{"2":{"390":1}}],["就自己产生一个隐藏的",{"2":{"390":1}}],["就不能把整个索引全部加载到内存了",{"2":{"375":1}}],["就求出",{"2":{"329":1}}],["就行了",{"2":{"329":1}}],["就要输出",{"2":{"329":1}}],["就容易产生死锁",{"2":{"285":1}}],["就会根据21定位到",{"2":{"482":1}}],["就会一直保持连接",{"2":{"439":1}}],["就会一直处于相互等待的状态",{"2":{"397":1}}],["就会处于等待状态",{"2":{"401":1}}],["就会去数据库请求数据",{"2":{"320":1}}],["就会返回给用户",{"2":{"320":1}}],["就会出现主从不一致",{"2":{"285":1}}],["就会出现问题",{"2":{"267":1}}],["就会发现有几列数据是它先前所没有的",{"2":{"267":1}}],["就会看到很多状态为z的进程",{"2":{"229":1}}],["就说数据库处于一致性状态",{"2":{"261":1}}],["就绪状态",{"2":{"190":1}}],["就可以匹配上联合索引",{"2":{"390":1}}],["就可以只重传丢失的",{"2":{"268":1}}],["就可以针对报文的内容数据进行访问控制",{"2":{"184":1}}],["就可以选用数组",{"2":{"45":1}}],["就数据结构",{"2":{"138":1}}],["就表示偏移",{"2":{"56":1}}],["就是从客户端发回来的字节中怎么区分",{"2":{"523":1}}],["就是传文件",{"2":{"399":1}}],["就是b树的特征之一",{"2":{"375":1}}],["就是设置隔离级别为rr",{"2":{"285":1}}],["就是通过指令模拟中断",{"2":{"153":1}}],["就是我们通常所说的用户栈和内核栈",{"2":{"153":1}}],["就是多了一次减法指令",{"2":{"56":1}}],["就是偏移为",{"2":{"56":1}}],["就是支持动态扩容",{"2":{"45":1}}],["就比较简单",{"2":{"29":1}}],["并把",{"2":{"583":1}}],["并不常用",{"2":{"543":1}}],["并不是因为引用传递",{"2":{"516":1}}],["并不会保存其他列的记录信息",{"2":{"369":1}}],["并不会对数据加锁",{"2":{"309":1}}],["并在浏览器窗口中显示",{"2":{"483":1}}],["并在光栅化线程池中将图块转换成位图",{"2":{"451":1}}],["并将其提交到合成线程",{"2":{"451":1}}],["并将字符串对象的编码设置为int",{"2":{"154":1}}],["并生成一棵对应的图层树",{"2":{"451":1}}],["并更新",{"2":{"447":1}}],["并执行命令",{"2":{"230":1}}],["并删除其中的过期key",{"2":{"213":1}}],["并行的关键是你有同时处理多个任务的能力",{"2":{"212":1}}],["并行",{"2":{"212":1}}],["并进行合并就行了",{"0":{"186":1}}],["并进一步了解",{"2":{"103":1}}],["并重新启动",{"2":{"180":2}}],["并发量大的用rc",{"2":{"584":1}}],["并发量非常大",{"0":{"149":1}}],["并发场景下一旦死锁",{"2":{"401":1}}],["并发执行的各个事务之间不能互相干扰",{"2":{"261":1}}],["并发的关键是你有处理多个任务的能力",{"2":{"212":1}}],["并发",{"2":{"212":1}}],["并发与并行",{"0":{"212":1}}],["并发安全否",{"2":{"164":1}}],["并继续保存在字符串对象里面",{"2":{"154":1}}],["并且使用到覆盖索引",{"2":{"576":1}}],["并且对比归纳了二者的区别",{"2":{"543":1}}],["并且对数据的操作非常简单",{"2":{"45":1}}],["并且头部压缩算法升级成了qpack",{"2":{"415":1}}],["并且内容量很大造成臃肿",{"2":{"407":1}}],["并且具有n个关键字的节点包含",{"2":{"375":1}}],["并且关闭一方之后另一方仍然可以长时间发送消息",{"2":{"274":1}}],["并且命令的执行也是多线程的",{"2":{"230":1}}],["并且还是在从服务器上",{"2":{"213":1}}],["并且重写的时候",{"2":{"213":1}}],["并且redis采用murmurhash2",{"2":{"154":1}}],["并且冲突的时候会将元素加入到表头",{"2":{"154":1}}],["并且这个整数值可以用long类型来表示",{"2":{"154":1}}],["并且可以创建其它分支",{"2":{"2":1}}],["并非所有语言都像c语言一样",{"2":{"45":1}}],["并没有规定数组访问越界时编译器应该如何处理",{"2":{"45":1}}],["警惕数组越界",{"2":{"45":1}}],["注意点",{"2":{"212":1,"235":1}}],["注意",{"2":{"108":1,"172":2,"195":1,"267":1}}],["注意事项",{"0":{"45":1},"2":{"202":1}}],["注意安装到系统path中",{"2":{"4":1}}],["的聚簇索引和非聚簇索引有什么区别",{"2":{"587":1}}],["的聚簇索引的查询过程",{"2":{"390":1}}],["的存储引擎用的是什么",{"2":{"587":1}}],["的主从",{"2":{"587":1}}],["的主从同步是最终一致性将其",{"2":{"586":1}}],["的主机提供数据传输服务",{"2":{"129":1}}],["的自增主键和随机生成主键的区别",{"0":{"580":1}}],["的连接",{"2":{"572":1}}],["的意义在哪",{"2":{"572":1}}],["的状态是什么情况",{"2":{"572":1}}],["的四次握手",{"2":{"572":1}}],["的优缺点",{"2":{"572":1}}],["的优势",{"2":{"390":1}}],["的不可靠传输",{"2":{"572":1}}],["的查询过程",{"0":{"560":1}}],["的缓冲区使用指定的值初始化缓冲容量",{"2":{"543":1}}],["的容量与长度相同",{"2":{"543":1}}],["的容量",{"2":{"543":1}}],["的长度",{"2":{"543":1}}],["的切片",{"2":{"543":1}}],["的底层数组",{"2":{"543":1}}],["的底层数据是数组",{"2":{"120":1}}],["的返回类型与其参数的类型相同",{"2":{"543":1}}],["的发起和接受者是谁",{"2":{"525":1}}],["的原理",{"0":{"517":1,"570":1}}],["的默认参数传递方式以及哪些是引用传递",{"0":{"516":1}}],["的区别",{"0":{"487":1,"539":1,"575":1},"2":{"543":1,"572":1,"587":1}}],["的区间",{"2":{"482":1}}],["的回答",{"2":{"483":1}}],["的语言",{"2":{"473":1}}],["的时机只有",{"2":{"572":1}}],["的时间都花在io上",{"2":{"473":1}}],["的时候",{"2":{"587":1}}],["的时候跳出",{"2":{"329":1}}],["的时候事先指定数据大小",{"2":{"45":1}}],["的读",{"2":{"473":1}}],["的行锁是实现在索引上的",{"2":{"466":1}}],["的锁",{"2":{"466":1}}],["的问题",{"0":{"460":1}}],["的端口号是",{"2":{"455":2}}],["的握手过程",{"2":{"455":1}}],["的报文传输",{"2":{"455":1}}],["的缺陷",{"2":{"455":1}}],["的继承和层叠规则计算出",{"2":{"451":1}}],["的消息后",{"2":{"447":1}}],["的消息给浏览器进程",{"2":{"447":1}}],["的消息给渲染进程",{"2":{"447":1}}],["的消费者如何做消息去重",{"2":{"59":1}}],["的索引类型",{"2":{"587":1}}],["的索引",{"0":{"442":1}}],["的索引原理",{"2":{"390":2}}],["的具体流程",{"0":{"423":1}}],["的同时并不会释放自己已经获取的资源",{"2":{"401":1}}],["的协程间通讯方式有哪些",{"0":{"400":1}}],["的协程与",{"0":{"396":1}}],["的情况下",{"2":{"397":2}}],["的叶子节点上都能找得到的那些索引",{"2":{"390":1}}],["的所有字段",{"2":{"390":1}}],["的高度依然维持在",{"2":{"390":1}}],["的单个节点的数据量更小",{"2":{"390":1}}],["的单链表元素删除",{"0":{"43":1}}],["的非叶子节点也要存储数据",{"2":{"390":1}}],["的形式给出",{"0":{"377":1}}],["的顺序遍历即可",{"2":{"363":1}}],["的人用的就是innodb了",{"2":{"345":1}}],["的总体结构",{"0":{"338":1}}],["的二维数组",{"2":{"335":1}}],["的二叉树",{"0":{"182":1}}],["的实现原理",{"0":{"327":1}}],["的复杂度下",{"0":{"311":1}}],["的事务锁了解吗",{"0":{"309":1}}],["的事务隔离级别有几种啊",{"2":{"273":1}}],["的特性增加了update操作的并发性",{"2":{"285":1}}],["的特定主机路由",{"2":{"195":1}}],["的方式",{"2":{"279":1}}],["的东西",{"2":{"268":1}}],["的路径",{"0":{"254":1}}],["的路由",{"2":{"195":1}}],["的孤儿进程就能瞑目而去了",{"2":{"229":1}}],["的影响",{"2":{"213":1}}],["的删除操作",{"2":{"213":1}}],["的过程叫做",{"2":{"345":1}}],["的过程中",{"0":{"296":1}}],["的过程中踩过哪些坑",{"2":{"59":1}}],["的过期时间时",{"2":{"213":1}}],["的源码分析以及slice内存泄漏",{"0":{"210":1}}],["的角色存在就是做这件事的",{"2":{"201":1}}],["的网络通信的基本操作单元",{"2":{"179":1}}],["的解决方案吗",{"2":{"178":1}}],["的负载均衡",{"2":{"178":2}}],["的额外成本主要在哪",{"2":{"178":1}}],["的中位数",{"0":{"175":1}}],["的上三层",{"2":{"159":1}}],["的数",{"0":{"287":1}}],["的数据包给复制了",{"2":{"268":1}}],["的数据包被网络延迟了",{"2":{"268":1}}],["的数据怎么办",{"0":{"263":1}}],["的数据结构",{"0":{"383":1},"2":{"154":2}}],["的数组",{"2":{"45":1}}],["的哪几种数据结构",{"2":{"154":1}}],["的心跳",{"2":{"133":1}}],["的排列",{"0":{"125":1}}],["的文件描述符",{"2":{"230":1}}],["的文件",{"0":{"124":1}}],["的文本文件",{"0":{"111":1}}],["的内存淘汰机制是对",{"2":{"202":1}}],["的内存淘汰机制",{"2":{"202":2}}],["的内存",{"0":{"124":1}}],["的内存地址就会变为",{"2":{"56":1}}],["的内存地址只需要用这个公式",{"2":{"56":1}}],["的如何查找",{"0":{"78":1}}],["的浮点数",{"0":{"61":1}}],["的墓碑机制是什么",{"2":{"59":1}}],["的",{"0":{"189":1,"336":1,"380":1},"2":{"59":1,"267":1,"390":1,"451":1,"466":1}}],["的位置",{"2":{"56":2}}],["的难度非常的大",{"2":{"45":1}}],["的概率和给定的相同",{"0":{"44":1}}],["写ｓｑｌ",{"2":{"587":1}}],["写入磁盘",{"2":{"583":1}}],["写个sql语句",{"0":{"573":1}}],["写操作",{"2":{"473":1}}],["写i",{"2":{"469":1}}],["写的时候加写锁",{"2":{"279":1}}],["写的时候会加写锁",{"2":{"279":1}}],["写表级排它锁直到事务结束释放",{"2":{"279":1}}],["写排它锁直到事务结束释放",{"2":{"279":1}}],["写锁",{"2":{"273":1,"279":1}}],["写",{"2":{"273":1,"279":1}}],["写时修改",{"0":{"266":1}}],["写出代",{"0":{"197":1}}],["写错代码题",{"0":{"161":1}}],["写一个单例模式",{"2":{"157":1}}],["写一个函数判断",{"0":{"125":1}}],["写一个接口来获取",{"0":{"44":1}}],["写完提交后面试官",{"2":{"58":1}}],["写爬虫系统时",{"0":{"27":1}}],["和返回的",{"2":{"572":1}}],["和异步",{"2":{"525":1}}],["和myisam的",{"0":{"478":1,"490":1}}],["和端口号",{"2":{"439":1}}],["和线程",{"2":{"397":2}}],["和数据库一致性怎么实现",{"0":{"362":1}}],["和在并发环境下的隔离做到一致性",{"2":{"303":1}}],["和互联网控制报文协议",{"2":{"172":1}}],["和用户数据报协议",{"2":{"172":1}}],["和amd64平台下的syscall",{"2":{"153":1}}],["和",{"0":{"125":1,"134":1,"160":1,"178":1,"217":1,"352":1,"487":1,"530":1,"539":1,"543":1,"575":1,"578":1},"2":{"59":2,"134":1,"202":2,"267":1,"397":2,"439":1,"442":1,"455":1,"525":1,"543":6,"572":6,"584":1,"587":1}}],["和命中概率",{"0":{"44":1}}],["和git",{"2":{"2":1}}],["o操作",{"2":{"473":1}}],["o的时间",{"2":{"469":1}}],["o设备",{"2":{"469":1}}],["o在很短的时间就可以完成",{"2":{"469":1}}],["optimal",{"2":{"449":1}}],["opt",{"2":{"449":2}}],["o多路复用机制",{"0":{"412":1}}],["of",{"2":{"403":1}}],["offset",{"2":{"56":1,"91":4}}],["os",{"0":{"513":1}}],["ospf",{"2":{"340":1}}],["osi",{"0":{"116":1,"129":1,"217":1},"1":{"129":1,"145":1,"159":1,"172":1,"184":1,"195":1,"206":1,"217":1,"225":1},"2":{"159":2,"172":5}}],["once的实现原理",{"0":{"318":1}}],["order",{"2":{"390":1}}],["oracle中默认使用读已提交",{"2":{"273":1}}],["orphan",{"2":{"229":2}}],["out吧",{"0":{"280":1}}],["out",{"2":{"179":1,"449":1}}],["ok",{"2":{"58":1,"153":1,"387":1}}],["o",{"0":{"43":1,"175":1,"311":1,"465":1,"473":1},"1":{"469":1,"473":1},"2":{"58":1,"69":1,"254":1,"357":1,"390":5,"469":1,"473":2}}],["海量数字",{"0":{"73":1}}],["海量数据处理",{"0":{"30":1}}],["海量日志查询某一段时间内的记录",{"0":{"38":1}}],["你来设",{"0":{"577":1}}],["你怎么做",{"0":{"567":1}}],["你怎么设计一个",{"2":{"525":1}}],["你最常用的系统是哪个",{"2":{"525":1}}],["你要着眼于",{"2":{"390":1}}],["你就知道",{"2":{"390":1}}],["你对",{"0":{"332":1}}],["你还向客户端发送报",{"0":{"328":1}}],["你给我讲一下三次握手的过程吧",{"2":{"274":1}}],["你也要掌握间隙锁",{"2":{"267":1}}],["你发现在使用",{"2":{"267":1}}],["你知道吗",{"2":{"240":1}}],["你说熟悉mysql事务",{"2":{"240":1}}],["你一定看出来了",{"2":{"580":1}}],["你一边打电话一边吃饭",{"2":{"212":1}}],["你一直到吃完了以后才去接",{"2":{"212":1}}],["你停了下来接了电话",{"2":{"212":1}}],["你吃饭吃到一半",{"2":{"212":3}}],["你的简历上有写",{"2":{"203":1}}],["你的这个方法有什么问题",{"2":{"178":1}}],["你了解xxxx么",{"0":{"203":1}}],["你可以从其他三个条件出发",{"2":{"401":1}}],["你可以讲的深入一点",{"2":{"181":1}}],["你可以每秒",{"2":{"29":1}}],["你如何解决了x",{"0":{"181":1}}],["你在",{"0":{"165":1}}],["你用了贪心法",{"0":{"68":1}}],["你觉得需要分库分表吗",{"2":{"59":1}}],["你会发现",{"2":{"35":1,"45":1}}],["只知道有个到阈值降一半然后线性增长",{"2":{"572":1}}],["只复制指向的对象的指针",{"2":{"500":1}}],["只会阻塞这个流",{"2":{"415":1}}],["只会保存主键的值",{"2":{"369":1}}],["只在叶子节点存储数据",{"2":{"390":1}}],["只支持statement格式",{"2":{"285":1}}],["只存在于内存中的文件",{"2":{"179":1}}],["只能在线程",{"2":{"401":1}}],["只能在父子进程中使用",{"2":{"179":1}}],["只能等待这个资源被线程",{"2":{"401":1}}],["只能逐一加载每一个磁盘页",{"2":{"375":1}}],["只能互斥等待",{"2":{"297":1}}],["只能排队等待",{"2":{"273":1}}],["只能用于亲缘关系的进程间通信",{"2":{"179":1}}],["只需要把线程a1的执行现场保存起来",{"2":{"153":1}}],["只关注切换过程",{"2":{"153":1}}],["只有25个关键字",{"2":{"546":1}}],["只有10可以插入成功",{"2":{"482":1}}],["只有一个索引",{"2":{"580":1}}],["只有一个程序在cpu上运行",{"2":{"212":1}}],["只有一方可以发送",{"2":{"274":1}}],["只有该隔离级别才会出现脏读",{"2":{"267":1}}],["只有在内核重启",{"2":{"179":1}}],["只有int编码的字符串对象和raw编码的字符串对象有这些程序",{"2":{"154":1}}],["只有获得cpu时间片的程序才可以运行",{"2":{"153":1}}],["只有标记为内核态时才可以访问内核空间",{"2":{"153":1}}],["只是在最后到叶子节点的时候才会保存一整行的记录",{"2":{"369":1}}],["只是在7层协议上去掉会话层与表示层",{"2":{"159":1}}],["只是因为在命令执行的时候是单线程的",{"2":{"222":1,"230":1}}],["只是单纯的查询或者删除操作的话",{"2":{"202":1}}],["只是为了提供内核应该提供的访问接口",{"2":{"153":1}}],["只是记录数据已经被删除",{"2":{"35":1}}],["只记得决出最快",{"0":{"70":1}}],["只要有一个报文丢包了",{"2":{"399":1}}],["只要缓冲区有未使用空间用于发送数据",{"2":{"235":1}}],["只要数组通过偏移计算得到的内存地址是可用的",{"2":{"45":1}}],["只要不是访问受限的内存",{"2":{"45":1}}],["只要讲思路",{"0":{"26":1}}],["gc",{"2":{"552":1}}],["gc稍微了解一点",{"2":{"203":1}}],["gin框架如何实现",{"0":{"531":1}}],["github",{"0":{"524":1},"2":{"549":2}}],["gdb",{"0":{"452":1}}],["gmp源码级别分析",{"0":{"432":1}}],["gmp",{"0":{"424":1}}],["gmp与垃圾回收",{"0":{"416":1},"1":{"420":1,"424":1,"428":1,"432":1,"436":1}}],["gmt",{"2":{"387":3}}],["gzip",{"2":{"387":1}}],["gzip等指定浏览器可以支持的web服务器返回的内容压缩编码类型",{"2":{"387":1}}],["gap",{"2":{"267":1}}],["get方法是安全和幂等的",{"2":{"503":1}}],["get方法是从服务器获取资源",{"2":{"503":1}}],["get与post的区别",{"0":{"503":1}}],["get和post",{"0":{"499":1}}],["get",{"0":{"296":1},"2":{"180":2,"387":2,"572":1}}],["geo",{"2":{"154":1}}],["groups的概念",{"2":{"154":1}}],["goleak",{"2":{"549":1}}],["golang有什么设计很巧妙的地方吗",{"0":{"504":1}}],["golang协程i",{"0":{"412":1}}],["golang",{"0":{"336":1,"366":1,"378":1,"396":1,"400":1,"444":1,"516":1},"2":{"543":3}}],["golang中哪些方式可以安全读写共享变量",{"0":{"300":1}}],["golang中channel调用问题",{"0":{"251":1}}],["golang中的",{"0":{"210":1}}],["golang相关的面试题",{"2":{"72":1}}],["go引用了plan9的代码",{"2":{"546":1}}],["go错误处理有什么优缺点",{"0":{"520":1}}],["go优缺点",{"0":{"520":1}}],["go相关知识点",{"0":{"520":1}}],["go相关的其他问题",{"0":{"480":1},"1":{"484":1,"488":1,"492":1,"496":1,"500":1,"504":1,"508":1,"512":1,"516":1,"520":1}}],["go语言中的坑",{"0":{"552":1}}],["go语言的运行环境",{"2":{"546":1}}],["go语言的性能的优劣",{"0":{"512":1}}],["go语言相关",{"0":{"72":1},"1":{"84":1,"96":1,"108":1,"120":1,"134":1,"150":1,"164":1,"176":1,"188":1,"199":1,"210":1,"219":1,"227":1,"235":1,"243":1,"251":1,"258":1,"264":1,"270":1,"276":1,"282":1,"288":1,"294":1,"300":1,"306":1,"312":1,"318":1,"324":1,"330":1,"336":1,"342":1,"348":1,"354":1,"360":1,"366":1,"372":1,"378":1,"383":1,"388":1,"392":1,"396":1,"400":1,"404":1,"408":1,"412":1,"416":1,"420":1,"424":1,"428":1,"432":1,"436":1,"440":1,"444":1,"448":1,"452":1,"456":1,"460":1,"464":1,"468":1,"472":1,"476":1,"480":1,"484":1,"488":1,"492":1,"496":1,"500":1,"504":1,"508":1,"512":1,"516":1,"520":1,"524":1,"528":1,"531":1,"534":1,"537":1,"540":1,"543":1,"546":1,"549":1,"552":1}}],["go怎么做深拷贝",{"0":{"500":1}}],["go怎样实现继承",{"0":{"484":1}}],["go垃圾回收",{"0":{"420":1}}],["go多线程",{"0":{"408":1}}],["go里面一个协程能保证绑定在一个内核线程上面的",{"0":{"404":1}}],["go的etcd",{"2":{"586":1}}],["go的协程可以只挂在一个线程上面吗",{"0":{"348":1}}],["go的协程可以不可以自己让出cpu",{"0":{"342":1}}],["go的channel",{"2":{"235":1}}],["go协程",{"0":{"312":1}}],["go并发为什么快",{"0":{"306":1}}],["go中导致内存泄漏的原因",{"0":{"276":1}}],["goroutines",{"2":{"549":1}}],["goroutine的量是否可控",{"2":{"549":1}}],["goroutine",{"2":{"270":2}}],["goroutine泄漏描述",{"2":{"270":1}}],["goroutine内存泄漏场景",{"0":{"270":1}}],["go",{"0":{"188":1,"258":1,"288":1,"388":1,"392":1,"424":1,"428":1,"436":1,"464":1,"524":2,"546":2,"549":1},"2":{"164":1,"549":2}}],["go数组和slice的区别",{"0":{"120":1}}],["gt",{"0":{"263":1,"311":2},"2":{"45":1,"72":1,"85":1,"96":1,"97":1,"103":1,"104":1,"108":1,"123":1,"138":1,"153":9,"154":2,"159":1,"172":1,"180":2,"195":3,"202":3,"206":1,"222":1,"235":1,"249":1,"255":1,"256":1,"261":1,"273":1,"274":1,"279":1,"285":2,"297":1,"303":1,"318":1,"345":4,"387":1,"463":1,"482":1}}],["g",{"2":{"35":2}}],["float",{"2":{"500":1}}],["font",{"2":{"451":2}}],["found",{"2":{"387":1}}],["forwards",{"2":{"387":1}}],["for",{"2":{"309":1,"482":1}}],["format改为row",{"2":{"285":1}}],["format",{"2":{"285":1}}],["fork之后的父子进程虚拟内存空间的相同与不同",{"0":{"277":1}}],["fork",{"0":{"260":1},"2":{"525":1}}],["fd限制+四元组ip",{"0":{"304":1}}],["fanguangdexiaoyuer",{"2":{"285":1}}],["false来告知服务器关闭请求",{"2":{"407":1}}],["false",{"2":{"91":1}}],["fred",{"2":{"387":1}}],["frequently",{"2":{"202":1,"449":1}}],["from=search",{"2":{"491":1}}],["from",{"2":{"1":2,"285":3,"434":2,"482":1}}],["fib数列",{"0":{"305":1}}],["first",{"2":{"179":2,"449":2}}],["fifo",{"0":{"86":1},"2":{"179":1,"449":1}}],["fpm的master",{"0":{"178":1}}],["ftp",{"2":{"172":1}}],["function",{"2":{"496":1}}],["func",{"0":{"549":1},"2":{"91":4,"134":1,"543":2}}],["fmt",{"2":{"91":5,"134":1}}],["f",{"2":{"35":2}}],["个值分别查一次索引",{"2":{"587":1}}],["个子进程",{"2":{"525":1}}],["个来源",{"2":{"451":1}}],["个步骤",{"2":{"451":1}}],["个请求会进入排队等待状态",{"2":{"439":1}}],["个请求发生",{"2":{"439":1}}],["个字节",{"2":{"580":3}}],["个字节的主键",{"2":{"390":1}}],["个字符建立索引",{"2":{"390":1}}],["个叶子节点的",{"2":{"390":1}}],["个点",{"0":{"359":1}}],["个人总结",{"2":{"345":1}}],["个节点的最近公共祖先",{"0":{"126":1}}],["个单",{"0":{"124":1}}],["个一组反转链表",{"0":{"117":1}}],["个跑道",{"0":{"70":1}}],["个数据",{"0":{"61":1}}],["个数据需要存储到数组中时",{"2":{"45":1}}],["个",{"2":{"56":1,"390":2,"439":1}}],["个元素",{"0":{"54":1},"2":{"35":1}}],["个位置的数据",{"2":{"35":1}}],["个位置",{"2":{"35":1}}],["8d",{"0":{"524":1}}],["88",{"0":{"524":1}}],["85",{"0":{"524":2},"2":{"577":1}}],["86",{"0":{"524":2}}],["80514340",{"2":{"551":1}}],["80端口建立一个",{"2":{"483":1}}],["80",{"2":{"439":1,"455":1}}],["80代表www",{"2":{"340":1}}],["8",{"0":{"70":2},"2":{"35":1,"91":7,"134":1,"154":1,"387":1,"580":1}}],["中发挥了什么作用",{"2":{"525":1}}],["中按下",{"2":{"525":1}}],["中函数传参仅有值传递一种方式",{"2":{"516":1}}],["中间元素包含介于两元素之间的元素",{"2":{"426":1}}],["中间件",{"0":{"48":1},"1":{"59":1}}],["中常见的场景",{"2":{"390":1}}],["中常见的基于范围的顺序查找",{"2":{"390":1}}],["中序遍历是有序的",{"2":{"345":1}}],["中",{"0":{"422":1},"2":{"248":1,"390":1}}],["中事务的实现",{"2":{"240":1}}],["中的数据",{"2":{"202":1}}],["中的一种",{"2":{"7":1}}],["中进行查表转发",{"2":{"195":1}}],["中使用",{"2":{"153":1,"167":1}}],["中存储了",{"2":{"35":1}}],["内部执行大概会经历下面五个步骤",{"2":{"583":1}}],["内部保存了引用数组的指针",{"2":{"516":1}}],["内部编码",{"2":{"7":1}}],["内置函数仅用作分配内存空间并初始化",{"2":{"543":1}}],["内置函数",{"2":{"496":1,"543":3}}],["内容与",{"2":{"525":1}}],["内容包含发出请求的用户信息",{"2":{"387":1}}],["内容1",{"2":{"308":1}}],["内容",{"2":{"279":1,"483":1}}],["内核就把孤儿进程的父进程设置为init",{"2":{"229":1}}],["内核态与用户态区别",{"2":{"525":1}}],["内核态线程和用户态线程的区别如何切换",{"0":{"265":1,"319":1}}],["内核态",{"2":{"153":1}}],["内核层共享",{"2":{"153":1}}],["内核空间由所有进程的地址空间共享",{"2":{"153":1}}],["内存上",{"2":{"583":1}}],["内存还是磁盘上保存的数据",{"2":{"583":1}}],["内存和磁盘都要涉及",{"0":{"513":1}}],["内存要好很多",{"2":{"473":1}}],["内存性能相对cpu要好很多",{"2":{"469":1}}],["内存每次从磁盘换页进来的效率很低",{"2":{"453":1,"525":1}}],["内存置换算法",{"0":{"445":1}}],["内存管理",{"0":{"445":1},"2":{"461":1}}],["内存分页的目的是什么",{"0":{"441":1}}],["内存分配",{"0":{"288":1,"520":1}}],["内存逃逸分析",{"0":{"436":1}}],["内存",{"0":{"429":1},"1":{"433":1,"437":1,"441":1,"445":1,"449":1,"453":1},"2":{"469":1,"473":1}}],["内存泄漏与内存溢出",{"0":{"477":1}}],["内存泄漏",{"0":{"264":1},"1":{"270":1,"276":1,"282":1,"288":1}}],["内存是只能存",{"0":{"263":1}}],["内存清理方面没有定时删除效果好",{"2":{"213":1}}],["内存淘汰策略共有八种",{"2":{"202":1}}],["内存淘汰机制",{"2":{"138":1}}],["内存满的时候会根据内存淘汰机制进行淘汰",{"2":{"191":1}}],["内存会逐渐飙升直到内存满为止",{"2":{"191":1}}],["内存系列",{"0":{"168":1},"1":{"180":1,"191":1,"202":1,"213":1}}],["内存就不连续了",{"2":{"35":1}}],["不了解",{"2":{"587":1}}],["不传入第二个参数",{"2":{"543":1}}],["不依赖于其他非主键",{"2":{"522":1}}],["不管其他进程的状态",{"2":{"485":1}}],["不管是在软件开发还是架构设计中",{"2":{"35":1}}],["不适合客户端和服务器端这样高频率的通信过程",{"2":{"463":1}}],["不适合建立索引或不适合排在联合索引列的靠前的位置",{"2":{"390":1}}],["不安全",{"2":{"455":1}}],["不再进行",{"2":{"443":1}}],["不存在同时写变量冲突",{"2":{"396":1}}],["不存放值",{"2":{"363":1}}],["不允许则返回405\\tallow",{"2":{"387":1}}],["不允许有重复数据",{"0":{"93":1}}],["不含有该关键字对应记录的存储地址",{"2":{"375":1}}],["不是通过主键",{"2":{"390":1}}],["不是名人",{"2":{"335":2}}],["不是两次和四次",{"2":{"256":1}}],["不认识",{"2":{"335":2}}],["不认识任何其他人",{"2":{"335":1}}],["不知道",{"0":{"328":1}}],["不提交",{"2":{"285":1}}],["不然就会一直重发",{"2":{"274":1}}],["不然中间就会出现空洞",{"2":{"35":1}}],["不仅仅是新增",{"2":{"267":1}}],["不可抢占",{"2":{"405":1}}],["不可剥夺",{"2":{"401":1}}],["不可重读",{"2":{"315":3}}],["不可重复读以及幻读",{"2":{"273":1,"279":1}}],["不可重复读的解决办法就是升级事务隔离级别",{"2":{"267":1}}],["不可重复读通常针对数据更新",{"2":{"267":1}}],["不可重复读",{"2":{"267":3}}],["不可以等于",{"0":{"162":1}}],["不一定",{"2":{"357":1}}],["不一定要同时",{"2":{"212":1}}],["不一致的状态",{"2":{"261":1}}],["不应该存在一个时刻",{"2":{"261":1}}],["不保证可靠交付",{"2":{"241":1}}],["不共享的有什么",{"0":{"221":1}}],["不主动删除过期键",{"2":{"213":1}}],["不友好",{"2":{"213":1}}],["不使用流量控制和拥塞控制",{"2":{"241":1}}],["不使用",{"2":{"202":1}}],["不淘汰任何数据",{"2":{"202":2}}],["不进行数据淘汰的策略",{"2":{"202":1}}],["不进行数据淘汰",{"2":{"202":1}}],["不需要进行三次握手",{"2":{"364":1}}],["不需要进行回表",{"2":{"345":1}}],["不需要重启",{"2":{"180":1}}],["不需要为进程或者应用程序提供服务",{"2":{"172":1}}],["不同",{"2":{"543":1}}],["不同值的个数除以表的总行数",{"2":{"390":1}}],["不同的事务看到的数据怎么就不一样了",{"0":{"327":1}}],["不同的系统中",{"2":{"201":1}}],["不同的是消息队列存放在内核中",{"2":{"179":1}}],["不同网络中的主机进行通信",{"2":{"195":1}}],["不同进程可以及时看到对方进程中对共享内存中数据的更新",{"2":{"179":1}}],["不能只有一个孩子",{"2":{"426":1}}],["不能再同时被线程",{"2":{"401":1}}],["不能被共享缓存处理",{"2":{"387":1}}],["不能写",{"2":{"285":1}}],["不能有一半成功一半失败的情况",{"2":{"261":1}}],["不能够太拉跨",{"2":{"203":1}}],["不能为每一个都分配一个中断号",{"2":{"153":1}}],["不能依赖相关指令",{"0":{"107":1}}],["不用来保存数据而是保存数据的索引",{"2":{"345":1}}],["不用",{"2":{"133":1}}],["不准用",{"0":{"98":1}}],["不区分大小写的",{"0":{"74":1}}],["不考虑空间复杂度",{"0":{"49":1}}],["不过与二叉排序树不同的是",{"2":{"426":1}}],["不过对gmp",{"2":{"203":1}}],["不过对xxxxx的a",{"2":{"203":1}}],["不过需要同步进程",{"2":{"179":1}}],["不过时间片轮转也只是触发进程或线程切换的多种场景之一",{"2":{"153":1}}],["不过",{"2":{"45":1}}],["不懂细节",{"0":{"31":1}}],["也不会触发叶子节点的分裂",{"2":{"580":1}}],["也不记录过去的请求",{"2":{"403":1}}],["也无法使用行锁",{"2":{"466":1}}],["也无法可靠的同步双方序列号",{"2":{"256":1}}],["也将退化为表锁",{"2":{"466":1}}],["也叫做avl树",{"2":{"426":1}}],["也想使用资源",{"2":{"401":1}}],["也能匹配上联合索引",{"2":{"390":1}}],["也能使接收端检测出所收到的帧有无差错",{"2":{"129":1}}],["也就减少了大量的",{"2":{"390":1}}],["也就是信息加密的等级",{"2":{"471":1}}],["也就是所谓的资源有序分配原则",{"2":{"401":1}}],["也就是资源的环形链",{"2":{"401":1}}],["也就是第一个请求没有传输完成无法开始传输第二个",{"2":{"399":1}}],["也就是按照最左优先的方式进行索引的匹配",{"2":{"390":1}}],["也就是描述了找到所需数据时使用的扫描方式是什么",{"2":{"390":1}}],["也就是struct中的内存对其那种",{"2":{"283":1}}],["也就是执行修改操作的时候去数据库里面查询最新的结果",{"2":{"240":1}}],["也就是直接复用之前的查询结果",{"2":{"240":1}}],["也就是说一次数据查询操作只需要做",{"2":{"390":1}}],["也就是说",{"2":{"235":1,"273":1,"580":1}}],["也就是说路由器是隔离广播域的",{"2":{"195":1}}],["也就是aof不写",{"2":{"213":1}}],["也就是",{"2":{"213":1}}],["也就是内存可以被尽快地释放",{"2":{"213":1}}],["也就是图中的路由器",{"2":{"195":1}}],["也就是少不了进行系统调用",{"2":{"153":1}}],["也就是首地址",{"2":{"56":1}}],["也要以重点参数为切入点",{"2":{"390":1}}],["也没有tcp的滑动窗口",{"2":{"364":1}}],["也需要定期维护",{"2":{"357":1}}],["也需要搬移数据",{"2":{"35":1}}],["也可能是因为程序是多线程实现因此屏蔽掉了等待i",{"2":{"469":1}}],["也可能是应用层协议",{"2":{"340":1}}],["也可",{"0":{"359":1}}],["也可以按消息的类型读取",{"2":{"179":1}}],["也可以直接使用数组",{"2":{"45":1}}],["也开启事务",{"2":{"285":1}}],["也插入了一行",{"2":{"267":1}}],["也是",{"2":{"267":1}}],["也是数据库并发控制的基本单位",{"2":{"255":1}}],["也同样读了一次",{"2":{"267":1}}],["也足够它执行很多很多的指令",{"2":{"153":1}}],["也即是说这个对象使用了什么数据结构作为对象的底层实现",{"2":{"7":1}}],["为无缓冲的",{"2":{"543":1}}],["为",{"2":{"543":1,"587":1}}],["为每个图层生成绘制列表",{"2":{"451":1}}],["为顶层节点的树状结构的",{"2":{"451":1}}],["为啥要用到这",{"2":{"345":1}}],["为任意值",{"0":{"287":1}}],["为此",{"2":{"267":1}}],["为某个区间的最小值乘上这个区间内所有元素的和",{"0":{"187":1}}],["为上层实体提供源端到对端主机的通信功能",{"2":{"172":1}}],["为什么选",{"2":{"587":1}}],["为什么自增主键效率高",{"0":{"580":1}}],["为什么会出现大量的",{"2":{"572":1}}],["为什么会有一个半关闭的状态",{"0":{"328":1}}],["为什么扫二维码可以实现登录",{"2":{"525":1}}],["为什么不能每次都直接发大的窗口",{"2":{"572":1}}],["为什么不一直用非对称加密",{"0":{"463":1},"1":{"467":1}}],["为什么不用搜索树",{"2":{"345":1}}],["为什么用",{"2":{"442":1}}],["为什么用单线程",{"2":{"222":1}}],["为什么",{"0":{"346":1,"364":1},"2":{"390":2,"525":1,"572":2}}],["为什么建立连接需要三次握手",{"0":{"322":1}}],["为什么我服务器端要单独发送自己的",{"0":{"316":1}}],["为什么读已提交产生不可重复读",{"2":{"279":1}}],["为什么是3次握手",{"2":{"274":1}}],["为什么是三次握手",{"2":{"256":1}}],["为什么需要握手",{"2":{"274":1}}],["为什么需要三次握手",{"0":{"274":1}}],["为什么挥手需要四次",{"2":{"256":1}}],["为什么单线程",{"2":{"222":1}}],["为什么单线程能这么快",{"2":{"222":1}}],["为什么有时候key已经过期了",{"2":{"213":1}}],["为什么redis定期删除策略不删除全部过期的key",{"2":{"213":1}}],["为什么要使用",{"0":{"546":1}}],["为什么要使用渐进式rehash",{"2":{"154":1}}],["为什么要叫这个名字",{"2":{"525":1}}],["为什么要有虚拟内存",{"0":{"433":1}}],["为什么要四次挥手",{"0":{"358":1}}],["为什么要",{"0":{"260":1}}],["为什么要分层",{"0":{"206":1}}],["为什么手动淘汰",{"2":{"202":1}}],["为什么它要用多进程",{"2":{"178":1}}],["为什么使用a",{"0":{"169":1}}],["为什么说派发系统调用呢",{"2":{"153":1}}],["为什么大多数编程语言中",{"2":{"56":1}}],["为的是不允许用户代码对其进行修改以保证安全",{"2":{"153":1}}],["为不同网络中的主机提供数据传输服务",{"2":{"129":1}}],["为进程提供通用数据传输服务",{"2":{"129":1}}],["为特定应用程序提供数据传输服务",{"2":{"129":1}}],["为了解决怎么问题",{"0":{"584":1}}],["为了解决不可重复读",{"2":{"279":1}}],["为了解决不知道快速重传该重传哪些",{"2":{"268":1}}],["为了更加方便地实现这些效果",{"2":{"451":1}}],["为了方便查找书中的内容",{"2":{"339":1}}],["为了克服这个缺点",{"2":{"179":1}}],["为了避免",{"2":{"35":1}}],["为了内存的连续性",{"2":{"35":1}}],["为对象设置多种不同的数据结构实现",{"2":{"6":1}}],["kv",{"2":{"580":1}}],["keepalive",{"2":{"483":1}}],["keep",{"2":{"387":1,"399":1,"439":1}}],["key锁解决幻读",{"2":{"584":1}}],["key锁防止幻读",{"2":{"584":1}}],["keys",{"2":{"390":1}}],["key",{"2":{"202":6,"213":14,"267":2,"390":2,"434":2,"584":2,"587":3}}],["kubernetes",{"2":{"59":2}}],["kafka",{"0":{"85":1},"2":{"59":2}}],["k",{"0":{"117":1,"209":1,"263":1,"317":1,"365":3},"2":{"35":1,"56":4}}],["技巧2",{"2":{"35":1}}],["技巧1",{"2":{"35":1}}],["b站的表同步好像就是订阅的binlog",{"2":{"584":1}}],["buffer",{"2":{"525":1,"587":1}}],["bug😂😂",{"2":{"365":1}}],["bug",{"0":{"119":1},"2":{"229":1,"572":1}}],["bss",{"2":{"525":1}}],["bss和",{"2":{"221":1}}],["bereborn",{"0":{"524":1}}],["begin",{"2":{"482":2}}],["bv11a4y1h7wf",{"2":{"491":1}}],["blue",{"2":{"451":1}}],["blob",{"0":{"524":1}}],["blog",{"2":{"229":1,"279":1,"285":1,"297":1,"303":1,"321":1,"551":1}}],["blocking",{"2":{"403":1}}],["block",{"2":{"153":1,"482":1,"525":1}}],["bound的程序一般在达到性能极限时",{"2":{"473":1}}],["bound的程序一般而言cpu占用率相当高",{"2":{"469":1}}],["bound的程序",{"2":{"469":1}}],["bound",{"0":{"465":2,"469":1,"473":1},"1":{"469":2,"473":2},"2":{"469":1}}],["bold",{"2":{"451":1}}],["book",{"2":{"104":1}}],["bool",{"2":{"91":1,"500":1}}],["by",{"2":{"390":1,"400":2,"525":1}}],["bytes",{"2":{"180":1,"387":2}}],["byte",{"2":{"91":2}}],["b树是一种平衡的多路查找树",{"2":{"426":1}}],["b树和b+树的共同优点",{"2":{"375":1}}],["b树则需要进行每一层的递归遍历",{"2":{"375":1}}],["b树的每一个节点都包含key和value",{"2":{"375":1}}],["b树的优点",{"2":{"375":1}}],["b树中每个节点",{"2":{"375":1}}],["b树中叶节点包含的关键字和其他节点包含的关键字是不重复的",{"2":{"375":1}}],["b树每个节点都存储数据",{"2":{"375":1}}],["b树与b+树的区别",{"2":{"375":1}}],["b树占用内存比较大",{"2":{"369":1}}],["b树同样也是一样的树高也可以做的很低呀",{"2":{"369":1}}],["b树",{"2":{"345":2,"375":1}}],["b树索引是mysql数据库中使用最频繁的索引类型",{"2":{"345":1}}],["b树索引",{"2":{"345":1}}],["btree",{"2":{"345":1}}],["b+区别",{"2":{"442":1}}],["b+数中有两个头指针",{"2":{"375":1}}],["b+tree",{"2":{"345":1,"390":23}}],["b+tree性质",{"2":{"345":1}}],["b+",{"2":{"345":2}}],["b+树参照",{"2":{"426":1}}],["b+树中查找",{"2":{"375":1}}],["b+树中每个节点",{"2":{"375":1}}],["b+树搜索经过路径中节点的时候",{"2":{"369":1}}],["b+树只有叶子节点存储数据",{"2":{"375":1}}],["b+树只是在叶子节点存放我们需要的数据",{"2":{"369":1}}],["b+树只需要使用o",{"2":{"363":1}}],["b+树的结构是怎么样的",{"0":{"406":1}}],["b+树的中间节点不保存数据",{"2":{"375":1}}],["b+树的优点",{"2":{"375":1}}],["b+树的索引项只包含对应子树的最大关键字和指向该子树的指针",{"2":{"375":1}}],["b+树的区别",{"0":{"375":1}}],["b+树的叶节点由一条链相连",{"2":{"363":1}}],["b+树的特点",{"2":{"345":1}}],["b+树的特性",{"2":{"345":1}}],["b+树有什么好处",{"0":{"363":1}}],["b+树有2个头指针",{"2":{"345":1}}],["b+树索引",{"2":{"345":2,"390":1}}],["b+树和二叉树有什么区别和优劣",{"2":{"587":1}}],["b+树和",{"2":{"345":1}}],["b+树",{"2":{"345":1,"375":1,"442":1}}],["b+树以及和b",{"0":{"345":1}}],["b=a",{"2":{"329":1}}],["balabala",{"2":{"525":1}}],["balancing",{"2":{"426":1}}],["basic",{"2":{"387":2}}],["based",{"2":{"297":1}}],["baidu",{"2":{"177":1,"551":1}}],["bigint",{"2":{"580":1}}],["bilibili",{"2":{"491":1}}],["binary",{"2":{"426":2}}],["binlog同步和恢复数据",{"2":{"584":1}}],["binlog解析器",{"0":{"559":1}}],["binlog",{"0":{"584":1},"2":{"285":1,"583":2,"584":2,"587":2}}],["bi",{"2":{"329":2}}],["bits",{"2":{"91":5}}],["bitmap",{"2":{"91":19,"154":1}}],["bgsave",{"0":{"260":1}}],["bbyte",{"2":{"134":1}}],["b",{"0":{"87":1,"375":1,"472":1},"2":{"35":3,"134":1,"180":1,"181":1,"203":1,"267":4,"273":1,"329":1,"345":1,"390":5,"397":5,"401":6,"442":1,"587":2}}],["赋值为x即可",{"2":{"35":1}}],["21",{"2":{"482":1}}],["21010",{"2":{"387":1}}],["27",{"2":{"387":1}}],["2种索引查询对比",{"2":{"345":1}}],["23代表telnet",{"2":{"340":1}}],["2次",{"0":{"303":1,"428":1},"2":{"345":1}}],["2个点",{"2":{"274":1}}],["2版本",{"2":{"213":1}}],["2版本之前",{"2":{"213":1}}],["2之前的从库读取的",{"2":{"213":1}}],["2之前不管有没有过期从库都是直接返回值",{"2":{"213":1}}],["2之后从库如果判断出是过期的key会直接返回null",{"2":{"213":1}}],["2之后",{"2":{"213":2}}],["2010",{"2":{"387":1}}],["200",{"2":{"387":1,"439":1}}],["2020",{"2":{"229":1,"387":2}}],["2021",{"2":{"134":1}}],["20",{"0":{"124":1},"2":{"482":6,"580":1}}],["2t",{"0":{"89":1}}],["26551754",{"0":{"82":1}}],["255",{"2":{"451":1}}],["25",{"0":{"36":1},"2":{"182":1}}],["2",{"0":{"89":2,"175":3,"334":1,"365":1},"2":{"35":1,"58":3,"87":1,"91":2,"134":1,"154":3,"184":4,"285":3,"308":1,"329":5,"375":2,"390":1,"397":3,"401":5,"426":5,"467":1,"503":1,"549":1,"551":1,"572":1,"583":2,"586":1}}],["5哪个",{"2":{"583":1}}],["500",{"2":{"572":1}}],["504",{"2":{"572":1}}],["503",{"2":{"572":2}}],["502",{"2":{"572":1}}],["5分钟",{"2":{"177":1}}],["5层协议",{"0":{"159":1}}],["5种基本数据结构",{"2":{"154":1}}],["5",{"0":{"175":4,"187":1,"347":1},"2":{"35":1,"45":1,"58":2,"96":1,"195":1,"267":1,"357":1,"387":1,"390":1,"525":1,"583":1}}],["xvwq3u",{"2":{"587":1}}],["xxx",{"2":{"387":4}}],["x列有一行数据",{"2":{"285":1}}],["x^2=n",{"0":{"275":1}}],["xargs",{"0":{"200":1}}],["x=4",{"0":{"187":1}}],["x2",{"0":{"125":2}}],["x26",{"2":{"91":1}}],["x1",{"0":{"125":2}}],["x",{"0":{"187":2,"275":1,"487":1},"2":{"35":2,"285":1}}],["降为o",{"2":{"35":1}}],["在提交事务和每秒都会将",{"2":{"587":1}}],["在语句方面上的优化",{"0":{"582":1}}],["在路由器上找的时候",{"0":{"570":1}}],["在阅读完上述内容后",{"2":{"543":1}}],["在设计数据库结构的时候",{"2":{"522":1}}],["在设置",{"2":{"213":1}}],["在设置了过期时间的键空间中",{"2":{"202":3}}],["在设置了过期时间的数据中进行淘汰",{"2":{"202":2}}],["在第二范式的基础上",{"2":{"522":1}}],["在第一范式的基础上",{"2":{"522":1}}],["在该时间内可以继续接收请求",{"2":{"483":1}}],["在该隔离级别下引入间隙锁",{"2":{"285":1}}],["在该隔离级别下每次",{"2":{"279":1}}],["在执行的过程当中绝大部份时间用在三角函数和开根号的计算",{"2":{"469":1}}],["在多重程序系统中",{"2":{"469":1}}],["在这段内容上加上协议合成合法的",{"2":{"435":1}}],["在这个过程中",{"2":{"172":1}}],["在自己使用完之前不能被其他线程",{"2":{"401":1}}],["在没有外力干预的情况下",{"2":{"397":1}}],["在已经获取到资源",{"2":{"397":2}}],["在索引",{"2":{"390":1}}],["在一些大字符串的字段作为索引时",{"2":{"390":1}}],["在一个事务的两次查询中数据笔数不一致",{"2":{"267":1}}],["在回答时",{"2":{"390":2}}],["在实际的应用当中",{"2":{"390":1}}],["在实现上",{"2":{"291":1}}],["在相同的磁盘",{"2":{"390":1}}],["在创建表时",{"2":{"390":1}}],["在创建线程时",{"2":{"153":1}}],["在mysql中使用较多的索引有hash索引",{"2":{"345":1}}],["在master上执行的顺序为先删后插",{"2":{"285":1}}],["在需要时",{"2":{"297":1}}],["在5秒之后重定向",{"2":{"387":1}}],["在5",{"2":{"285":1}}],["在每次select之间有其他事务",{"2":{"279":1}}],["在进程还未退出之前",{"2":{"229":1}}],["在物理层数据帧被封装成比特流",{"2":{"225":1}}],["在物理层和网络层之间",{"2":{"129":1}}],["在数据链路层数据包添加发送端",{"2":{"225":1}}],["在数组中",{"2":{"35":1}}],["在最简单的情况下",{"2":{"225":1}}],["在发送主机端",{"2":{"225":1}}],["在某些极端情况下",{"2":{"463":1}}],["在某些特殊场景下",{"2":{"35":1}}],["在某一函数中的",{"2":{"221":1}}],["在3",{"2":{"213":1}}],["在你设置的那个时间点之前",{"2":{"213":1}}],["在内存不紧张但",{"2":{"213":1}}],["在内存里存一张中断向量表",{"2":{"153":1}}],["在过期",{"2":{"213":1}}],["在操作系统中",{"2":{"212":1}}],["在linux下怎么查找一个日志文件一个方法返回的不同code码的个数",{"0":{"211":1}}],["在redis中表示设置了过期时间的key",{"2":{"202":1}}],["在键空间中",{"2":{"202":2}}],["在所有数据范围内进行淘汰",{"2":{"202":2}}],["在符合防火墙规定标准之下",{"2":{"184":1}}],["在工作方式有什么不一样的地方",{"2":{"178":1}}],["在什么时候",{"2":{"177":1}}],["在网际互联层",{"2":{"172":1}}],["在有序集合中的表现",{"2":{"154":1}}],["在有需要的时候",{"2":{"154":1}}],["在字典中的表现",{"2":{"154":1}}],["在列表中的表现",{"2":{"154":1}}],["在pcb中可以找到进程拥有的线程列表",{"2":{"153":1}}],["在两个相邻节点间的链路上传送帧",{"2":{"129":1}}],["在两个相邻节点之间传送数据时",{"2":{"129":1}}],["在应用层交互的数据单元我们称之为报文",{"2":{"129":1}}],["在细节上有一些问题",{"0":{"76":1}}],["在平时的业务开发中",{"2":{"69":1}}],["在生产中用过",{"2":{"59":1}}],["在",{"2":{"45":1,"248":1,"291":2,"455":2,"543":2,"583":1}}],["在部分情况下",{"2":{"35":1}}],["在服务器启用了maxmemory功能的情况下",{"2":{"6":1}}],["一条sql语句的执行过程",{"2":{"587":1}}],["一条",{"0":{"583":1},"2":{"583":1}}],["一范式为什么要列不可分割",{"0":{"526":1}}],["一道很简单的go题目",{"0":{"500":1}}],["一旦所有图块都被光栅化",{"2":{"451":1}}],["一旦某个请求发生丢包",{"2":{"415":1}}],["一旦发生死锁",{"2":{"405":1}}],["一次只能一个连接玩表",{"2":{"462":1}}],["一次读取",{"2":{"363":1}}],["一次同进程间的线程切换就算完成了",{"2":{"153":1}}],["一堆纸牌",{"0":{"353":1}}],["一级指针",{"2":{"345":1}}],["一样",{"2":{"345":1}}],["一瞬间大量该key的请求打到数据库上",{"2":{"320":1}}],["一顿猛吹",{"2":{"297":1}}],["一张表test有字段x并且是主键",{"2":{"285":1}}],["一致性",{"2":{"261":1,"303":1}}],["一致性consistency",{"2":{"261":1}}],["一致性哈希了解么",{"2":{"59":1}}],["一开始答的时候我竟然报了半天状态码还浑然不知",{"2":{"387":1}}],["一开始想到最小公倍数去了",{"2":{"329":1}}],["一开始直接就说",{"2":{"254":1}}],["一开始没思路",{"2":{"29":1}}],["一对多",{"2":{"241":1}}],["一周一根金条",{"0":{"216":1}}],["一直准备了",{"2":{"483":1}}],["一直没有被访问",{"2":{"213":1}}],["一直不敢下笔",{"2":{"58":1}}],["一些",{"0":{"200":1}}],["一些疑问",{"0":{"56":1}}],["一部分寄存器的值会通过硬件机制保存起来",{"2":{"153":1}}],["一般作为衡量其他置换算法的方法",{"2":{"449":1}}],["一般没有特别好的方法",{"2":{"401":1}}],["一般查询返回结果集小于表中记录数的30",{"2":{"357":1}}],["一般是传输层协议",{"2":{"340":1}}],["一般是由父进程或者操作系统创建的",{"2":{"153":1}}],["一般常见于黑客攻击",{"2":{"320":1}}],["一般都是由主线程创建的",{"2":{"153":1}}],["一般都会出现莫名其妙的逻辑错误",{"2":{"45":1}}],["一行命令将大文件切成小文件",{"0":{"121":1}}],["一棵二叉树",{"2":{"63":1}}],["一千万条数据找最大的前",{"0":{"61":1}}],["一千万个0",{"0":{"49":1}}],["一个表",{"0":{"579":1}}],["一个教务系统",{"0":{"577":1}}],["一个水果",{"2":{"525":1}}],["一个子进程",{"2":{"525":1}}],["一个go源码级别的仓库讲解",{"0":{"524":1}}],["一个响应由状态行",{"2":{"483":1}}],["一个请求报文由请求行",{"2":{"483":1}}],["一个大型游戏",{"2":{"453":1}}],["一个网页的请求过程",{"0":{"431":1},"1":{"435":1,"439":1,"443":1,"447":1,"451":1}}],["一个4节点要么没有孩子",{"2":{"426":1}}],["一个4节点包含小中大三个元素和四个孩子",{"2":{"426":1}}],["一个3节点要么没有孩子",{"2":{"426":1}}],["一个3节点包含一小一大两个元素和三个孩子",{"2":{"426":1}}],["一个2节点包含一个元素和两个孩子",{"2":{"426":1}}],["一个指向根节点",{"2":{"375":1}}],["一个环上有",{"0":{"359":1}}],["一个协程挂起换入另外一个协程是什么过程",{"0":{"354":1}}],["一个是最小关键码的叶节点",{"2":{"345":1}}],["一个是树的根节点",{"2":{"345":1}}],["一个项目可以分为如下3个阶段",{"2":{"320":1}}],["一个线程是如何被挂起的",{"0":{"289":1}}],["一个线程获得的时间片用完时",{"2":{"153":1}}],["一个tcp程序的具体步骤",{"0":{"286":1}}],["一个事务被提交之后",{"2":{"261":1}}],["一个没有了父进程的子进程就是一个孤儿进程",{"2":{"229":1}}],["一个文件中去重后的ip地址数目",{"0":{"228":1}}],["一个应用层报文被传送到运输层",{"2":{"225":1}}],["一个让人更加容易理解的例子",{"2":{"212":1}}],["一个cpu处理a线程",{"2":{"212":1}}],["一个单链表",{"0":{"197":1}}],["一个服务写一个服务读怎么保证没有脏数据",{"2":{"185":1}}],["一个数组",{"0":{"162":1}}],["一个进程",{"2":{"525":1}}],["一个进程执行一半要求另一个进程终止",{"2":{"525":1}}],["一个进程是如何被挂起的",{"0":{"295":1}}],["一个进程来做",{"0":{"260":1}}],["一个进程包含若干个线程",{"2":{"167":1}}],["一个进程中至少要有一个线程",{"2":{"153":1}}],["一个进程可以有多个线程",{"2":{"153":1}}],["一个链表",{"0":{"147":1}}],["一个上",{"0":{"111":1}}],["一个",{"2":{"29":1}}],["一个对象用作键值对的键",{"2":{"7":1}}],["点头",{"0":{"436":1}}],["点有多少种不同的走法",{"0":{"359":1}}],["点出发",{"0":{"359":1}}],["点到为止",{"2":{"213":1}}],["点分十进制",{"0":{"34":1}}],["点",{"2":{"29":1}}],["点击下载的msi进行安装",{"2":{"4":1}}],["但面试官也没接着说",{"2":{"587":1}}],["但也有一个限度",{"2":{"473":1}}],["但也可能是网络层协议",{"2":{"340":1}}],["但由于人们目前无法预知进程在内存下的若千页面中哪个是未来最长时间内不再被访问的",{"2":{"449":1}}],["但如果从一个页面打开了另一个新页面",{"2":{"443":1}}],["但如果你是做一些非常底层的开发",{"2":{"45":1}}],["但同时又请求获取资源",{"2":{"401":2}}],["但它在等待资源",{"2":{"401":1}}],["但这里是3次为什么呢",{"2":{"274":1}}],["但幻读仍有可能发生",{"2":{"273":1,"279":1}}],["但并没有符合预期的退出",{"2":{"270":1}}],["但并不是所有的引擎都支持事务",{"2":{"248":1}}],["但redis的其他功能",{"2":{"222":1}}],["但在任意一个时间点上",{"2":{"212":1}}],["但在操作系统中仍然保留着一个记录",{"2":{"190":1}}],["但进程所需资源尚未分配",{"2":{"190":1}}],["但插入",{"2":{"69":1}}],["但是很细节",{"0":{"570":1}}],["但是它们初始化变量的方式不同",{"2":{"543":1}}],["但是我只记得个名字了",{"2":{"525":1}}],["但是我们也必须注意到它的代价",{"2":{"357":1}}],["但是我们一般把redis称为单线程高性能",{"2":{"222":1}}],["但是任务越多花在任务切换时间越多",{"2":{"473":1}}],["但是运算效率低",{"2":{"467":1}}],["但是页面还是呈现前一个页面",{"2":{"435":1}}],["但是基于udp的quic协议可以实现类似tcp的可靠传输",{"2":{"415":1}}],["但是资源",{"2":{"401":1}}],["但是一个长连接上传输多个请求",{"2":{"399":1}}],["但是不安全",{"2":{"467":1}}],["但是不能乱",{"2":{"399":1}}],["但是不建议真的排序后再输出",{"2":{"365":1}}],["但是并没有讲它产生的原因以及怎么避免",{"2":{"397":1}}],["但是如果传入第三个参数",{"2":{"543":1}}],["但是如果浏览器或者服务器在http头部加上",{"2":{"439":1}}],["但是如果查询条件是",{"2":{"390":1}}],["但是如果没用数据写入的话",{"2":{"202":1}}],["但是写的有点",{"2":{"365":1}}],["但是非聚簇索引是每一个叶子节点都保留对应的主键值",{"2":{"345":1}}],["但是此时在从",{"2":{"285":1}}],["但是幻读或不可重复读仍有可能发生",{"2":{"273":1,"279":1}}],["但是没有去网上找过最",{"0":{"257":1}}],["但是这只是对数据修改的操作",{"2":{"240":1}}],["但是现在我们要修改的时候去查询",{"2":{"240":1}}],["但是memcache是各自的线程执行各自的命令",{"2":{"230":1}}],["但是其实还有一个组件叫做套接字队列",{"2":{"230":1}}],["但是其存放位置和全局变量一样",{"2":{"221":1}}],["但是在系统进程表中还为它保留了一些退出状态的信息",{"2":{"229":1}}],["但是在没有强烈要求的情况下",{"2":{"35":1}}],["但是命令的执行还是单线程的",{"2":{"222":1,"230":1}}],["但是还能读取到数据",{"2":{"213":1}}],["但是注意不会删除哦",{"2":{"213":1}}],["但是依然不会删除",{"2":{"213":1}}],["但是需要注意即便是在3",{"2":{"213":1}}],["但是当读请求打到从服务器上的时候",{"2":{"213":1}}],["但是后面我们需要在两张表查",{"2":{"154":1}}],["但是用户程序不能直接访问内核空间",{"2":{"153":1}}],["但是为了进一步保障系统运行安全",{"2":{"153":1}}],["但是进程通信需要借助ipc",{"2":{"153":1}}],["但是两个不同进程中的线程切换会引起进程切换",{"2":{"153":1}}],["但是序列化empty",{"2":{"134":1}}],["但是列表内没有任何值",{"2":{"134":2}}],["但是第一次面试还是不太习惯orz",{"2":{"63":1}}],["但是时间复杂度不限",{"2":{"58":1}}],["但是",{"2":{"56":1,"69":1,"229":1,"235":1,"335":1,"390":2,"584":1}}],["但是底层数据结构",{"2":{"7":1}}],["但你不知道速度和方向",{"2":{"29":1}}],["速度是固定的",{"2":{"29":1}}],["虫子在正负",{"2":{"29":1}}],["伴随而来的便是一个杀手级的特性",{"2":{"28":1}}],["图解redis介绍",{"2":{"385":1}}],["图来自于",{"2":{"154":1}}],["图例",{"2":{"154":1}}],["图",{"2":{"28":1}}],["堆里面如何控制并发安全",{"0":{"80":1}}],["堆排序",{"0":{"317":1}}],["堆排序实现",{"0":{"32":1}}],["堆排序是怎么样的",{"0":{"24":1}}],["堆",{"0":{"489":1},"2":{"28":1,"221":1}}],["顾名思义",{"2":{"28":1}}],["awesome",{"2":{"549":1}}],["awk",{"0":{"200":1}}],["ants",{"2":{"549":1}}],["and",{"2":{"229":1,"390":1,"587":2}}],["ad",{"0":{"524":1}}],["address",{"2":{"387":1}}],["add",{"2":{"0":2,"2":1}}],["amp",{"2":{"491":1}}],["a和b能不能执行到",{"0":{"472":1}}],["after",{"2":{"387":1}}],["after\\t如果实体暂时不可取",{"2":{"387":1}}],["age=20",{"2":{"482":1}}],["age=1",{"2":{"434":2}}],["age=3600",{"2":{"387":1}}],["age",{"0":{"576":1},"2":{"434":3,"482":5,"576":1}}],["age\\t从原始服务器到代理缓存形成的估算时间",{"2":{"387":1}}],["agent",{"2":{"387":1}}],["authenticate\\t表明客户端请求实体应该使用的授权方案\\twww",{"2":{"387":1}}],["authenticate\\t它指出认证方案和可应用到代理的该url上的参数\\tproxy",{"2":{"387":1}}],["authenticate",{"2":{"387":3}}],["authorization",{"2":{"387":2}}],["author",{"2":{"134":1}}],["all",{"2":{"390":1}}],["allow\\t对某网络资源的有效的请求行为",{"2":{"387":1}}],["allkeys",{"2":{"180":1,"202":3}}],["alive保持http连接不断卡",{"2":{"407":1}}],["alive",{"2":{"387":1,"399":1,"439":1}}],["ai+1",{"2":{"329":1}}],["ai",{"2":{"329":3}}],["a=1",{"2":{"329":2}}],["accept",{"2":{"387":4}}],["acknowledgment",{"2":{"268":1}}],["ack",{"2":{"268":3,"572":4}}],["acid",{"2":{"261":2}}],["aof就是压缩合并",{"2":{"213":1}}],["at",{"0":{"200":1}}],["a的特点",{"2":{"169":1}}],["avl树或者红黑树",{"0":{"142":1}}],["abyte",{"2":{"134":1}}],["abcc",{"2":{"87":1}}],["abc",{"0":{"87":1,"99":1},"2":{"87":1}}],["apache",{"2":{"387":2}}],["api",{"2":{"133":1}}],["append时会自动扩容",{"2":{"120":1}}],["arp协议",{"0":{"554":1}}],["article",{"2":{"177":1,"279":1,"285":1,"297":1,"303":1,"321":1,"551":1}}],["arm",{"0":{"107":1}}],["arraylist",{"2":{"45":8}}],["arraylist等容器",{"2":{"45":1}}],["array",{"2":{"28":1,"45":2,"500":1}}],["a",{"0":{"87":1,"162":2,"311":4,"472":1},"2":{"35":4,"56":5,"96":1,"108":1,"134":2,"180":1,"229":1,"267":4,"273":1,"329":1,"335":3,"397":5,"401":8,"552":2,"587":3}}],["放弃处理机而自行阻塞",{"2":{"190":1}}],["放到数组最后",{"2":{"58":1}}],["放",{"0":{"27":1},"2":{"221":1,"572":1}}],["如一些复杂的",{"2":{"451":1}}],["如数组为",{"0":{"187":1}}],["如互斥锁和信号量等",{"2":{"179":1}}],["如",{"0":{"175":1},"2":{"329":3,"390":2,"572":1}}],["如下图所示",{"2":{"153":3}}],["如var",{"2":{"108":1}}],["如读写分离",{"2":{"103":1}}],["如何提高",{"0":{"582":1}}],["如何提高索引的速度",{"0":{"394":1}}],["如何处理",{"2":{"572":1}}],["如何对接收到的数据包进行组装",{"2":{"572":1}}],["如何改进",{"2":{"572":1}}],["如何做到的呢",{"2":{"546":1}}],["如何建立索引",{"2":{"576":1}}],["如何建索引",{"0":{"529":1}}],["如何建表",{"0":{"529":1}}],["如何防止密码被",{"2":{"525":1}}],["如何操作",{"2":{"525":1}}],["如何优化",{"2":{"453":1,"587":1}}],["如何创建索引",{"0":{"410":1}}],["如何引导",{"2":{"230":1}}],["如何解决",{"0":{"370":1}}],["如何解决孤儿进程的出现",{"0":{"229":1}}],["如何解决redis从库key过期依然返回数据的问题",{"2":{"213":1}}],["如何保证高可用等等",{"0":{"585":1}}],["如何保证数据不丢失",{"0":{"585":1}}],["如何保证的",{"0":{"303":1}}],["如何保证多个服务器的数据一致性",{"0":{"302":1,"586":1}}],["如何保证redis与数据库的数据一致性",{"2":{"222":1}}],["如何保证操作的成功",{"2":{"222":1}}],["如何查看数据库表结构",{"0":{"581":1}}],["如何查看内存和",{"2":{"525":1}}],["如何查看某个进程占用的内存大小",{"0":{"220":1}}],["如何查看cpu负载情况",{"0":{"177":1}}],["如何使用",{"2":{"160":1}}],["如何并发安全",{"0":{"157":1}}],["如何整体排成升序",{"0":{"147":1}}],["如何实现长连接",{"2":{"572":1}}],["如何实现事务",{"2":{"297":1}}],["如何实现参考极客时间课程mysql实战45讲与https",{"2":{"279":1,"297":1,"321":1}}],["如何实现一个锁",{"0":{"237":1}}],["如何实现的",{"0":{"78":1}}],["如何实时查看日志",{"0":{"135":1}}],["如何设计数据结构节省内存空间",{"0":{"86":1}}],["如何设计一个",{"0":{"42":1}}],["如何判断拥塞何时发生",{"2":{"268":1}}],["如何判断一棵树是否为bst",{"0":{"63":1}}],["如何判定该",{"0":{"27":1}}],["如果事务出错",{"2":{"583":1}}],["如果事先能确定需要存储的数据大小",{"2":{"45":1}}],["如果滑动窗口为",{"2":{"572":1}}],["如果要用",{"2":{"572":1}}],["如果为零或忽略大小",{"2":{"543":1}}],["如果不传入第三个参数",{"2":{"543":1}}],["如果不遵守",{"2":{"522":1}}],["如果不限方向怎么做",{"0":{"19":1}}],["如果查询21呢",{"2":{"482":1}}],["如果查询没有命中索引",{"2":{"466":1}}],["如果查询条件是",{"2":{"390":1}}],["如果需要传递参数",{"2":{"439":1}}],["如果需要全双工",{"2":{"179":1}}],["如果当前请求数量少于6个",{"2":{"439":1}}],["如果在同一个域名下同时有",{"2":{"439":1}}],["如果在redis3",{"2":{"213":1}}],["如果有两个进程",{"2":{"525":1}}],["如果有索引",{"2":{"462":1}}],["如果有则拦截请求",{"2":{"439":1}}],["如果有的话",{"2":{"320":1}}],["如果某个4节点有孩子的话",{"2":{"426":1}}],["如果某个3节点有孩子的话",{"2":{"426":1}}],["如果某个请求没有收到响应则会阻塞",{"2":{"407":1}}],["如果某种符号的数字多余",{"2":{"58":1}}],["如果客户端想关闭http连接",{"2":{"407":1}}],["如果申请不到",{"2":{"401":1}}],["如果线程",{"2":{"401":2}}],["如果这道题回答道对头阻塞应该就不会延展了",{"2":{"399":1}}],["如果字段的值是一个closed表明是一个短链接",{"2":{"399":1}}],["如果索引中存在这些数据",{"2":{"390":1}}],["如果表没有定义主键",{"2":{"390":1}}],["如果redis为空的话",{"2":{"320":1}}],["如果没有索引",{"2":{"462":1}}],["如果没有指定端口号",{"2":{"439":1}}],["如果没有mvcc",{"2":{"297":1}}],["如果没有同时准备好的话",{"2":{"235":1}}],["如果条件列未命中索引会引起锁表",{"2":{"285":1}}],["如果存在间隙锁",{"2":{"285":1}}],["如果",{"2":{"273":1,"583":1}}],["如果通知到子协程也结束",{"0":{"245":1}}],["如果通道里没有数据的话",{"2":{"235":1}}],["如果给定了一个缓冲区容量",{"2":{"235":1}}],["如果缓冲区空",{"2":{"235":1}}],["如果容量满了",{"2":{"235":1}}],["如果发生hash碰撞",{"2":{"345":1}}],["如果发送的话",{"2":{"235":1}}],["如果发现差错",{"2":{"129":1}}],["如果系统进程表被僵尸进程耗尽的话",{"2":{"229":1}}],["如果父进程一直不取得这些退出信息的话",{"2":{"229":1}}],["如果父进程没有这么做的话",{"2":{"229":1}}],["如果主服务器发现这个key过期就会删除这个key",{"2":{"213":1}}],["如果执行的太少",{"2":{"213":1}}],["如果执行的太频繁",{"2":{"213":1}}],["如果一个表查询",{"0":{"567":1}}],["如果一个索引包含或者说覆盖所有需要查询的字段的值",{"2":{"434":1}}],["如果一个长连接上传输一个文件是没有问题的",{"2":{"399":1}}],["如果一个通道被关闭了",{"2":{"235":1}}],["如果一个",{"2":{"213":1}}],["如果一个字符串对象保存的是整数值",{"2":{"154":1}}],["如果过期则删除该",{"2":{"213":1}}],["如果真的了解过",{"2":{"203":1}}],["如果面试官问到",{"0":{"203":1}}],["如果只有一个cpu可用",{"2":{"201":1}}],["如果得到的结果等于路由表中的目的网络的地址则转发到对应路由表条目中的下一跳",{"2":{"195":1}}],["如果淘汰之后依然是满的将会拒绝写入",{"2":{"191":1}}],["如果安全策略是代理策略",{"2":{"184":1}}],["如果是长整型",{"2":{"580":1}}],["如果是长连接将会是connection",{"2":{"399":1}}],["如果是的话",{"2":{"546":1}}],["如果是字节流类型",{"2":{"443":1}}],["如果是",{"2":{"439":2,"443":1}}],["如果是搜索内容",{"2":{"435":1}}],["如果是单体应用",{"2":{"320":1}}],["如果是在3",{"2":{"213":1}}],["如果是内推的话",{"2":{"181":1}}],["如果是特别底层的开发",{"2":{"69":1}}],["如果接下来要执行进程a中的线程a1",{"2":{"153":1}}],["如果问到为什么进程切换开销大",{"2":{"153":1}}],["如果用身份证号做主键",{"2":{"580":1}}],["如果用户输入的内容符合",{"2":{"435":1}}],["如果用",{"2":{"56":1}}],["如果数组自己内部有重复",{"2":{"329":1}}],["如果数组从",{"2":{"56":1}}],["如果数据库系统运行中发生故障",{"2":{"261":1}}],["如果数据大小事先已知",{"2":{"45":1}}],["如果数特别大怎么办",{"0":{"12":1}}],["如果使用",{"2":{"45":1}}],["如果你写的go代码不包含cgo",{"2":{"546":1}}],["如果你被问到",{"2":{"390":1}}],["如果你用商品编码查询商品",{"2":{"390":1}}],["如果你当前查询数据时候",{"2":{"390":1}}],["如果你启动了一个",{"2":{"270":1}}],["如果你细心留意",{"2":{"35":1}}],["如果你了解",{"2":{"35":1}}],["如果我们申请了大小为",{"2":{"45":1}}],["如果我们将多次删除操作集中在一起执行",{"2":{"35":1}}],["如果我们要删除第",{"2":{"35":1}}],["如果想要插入元素",{"2":{"35":1}}],["很多时候只能重启应用",{"2":{"401":1}}],["很多时候我们并不是要去死记硬背某个数据结构或者算法",{"2":{"35":1}}],["很多大厂公司招聘",{"2":{"390":1}}],["很多计算机病毒也正是利用到了代码中的数组越界可以访问非法地址的漏洞",{"2":{"45":1}}],["很多人了解redis主要从数据结构着手",{"2":{"6":1}}],["很简单的",{"0":{"26":1}}],["大家一般用哪个级别",{"2":{"584":1}}],["大部分的状况是cpu在等i",{"2":{"473":1}}],["大部分情况下都需要在插入前将插入位置以及后面的元素向后挪动一个位置",{"2":{"35":1}}],["大部份时间用来做计算",{"2":{"469":1}}],["大话数据结构",{"2":{"426":1}}],["大量的redis缓存在同一时间内过期",{"2":{"308":1}}],["大量等待调度的进程",{"2":{"177":1}}],["大明哥钉钉直播回放以及github仓库的八股文",{"2":{"240":1}}],["大的数字",{"0":{"263":1,"317":1}}],["大的",{"0":{"209":1}}],["大概用了什么技术",{"2":{"185":1}}],["大概讲了讲",{"0":{"31":1}}],["大大提高了防火墙技术在应用实践中的灵活性和安全性",{"2":{"184":1}}],["大",{"0":{"26":1}}],["大数相加",{"0":{"14":1}}],["求平均分大于85的学生的姓名",{"0":{"573":1}}],["求有多少种可能性",{"0":{"347":1}}],["求出重复的部分",{"2":{"329":1}}],["求出其含有",{"0":{"87":1}}],["求这个序列的波峰",{"0":{"311":1}}],["求在小于",{"0":{"311":1}}],["求分位数",{"0":{"293":1}}],["求二叉树是否存在和为",{"0":{"254":1}}],["求二叉树的最长路径",{"0":{"247":1}}],["求彼此区间的交集",{"0":{"234":1}}],["求最大的",{"0":{"187":1}}],["求最小成本是",{"0":{"19":1}}],["求",{"0":{"175":1,"359":1}}],["求数组的中位数",{"0":{"175":1}}],["求快速排序的算法复杂度的那个递推关系式",{"0":{"89":1}}],["求树的最大高度",{"0":{"75":1}}],["求能返回最大数",{"0":{"9":1}}],["最合适的语言就是开发效率最高",{"2":{"473":1}}],["最近最久未使用页面置换算法",{"2":{"449":1}}],["最近最少使用",{"2":{"202":1}}],["最佳",{"2":{"449":1}}],["最佳页面置换算法",{"2":{"449":1}}],["最左匹配原则等等",{"0":{"450":1}}],["最左匹配原则",{"2":{"406":1}}],["最好是规避死锁",{"2":{"401":1}}],["最好的方法",{"2":{"320":1}}],["最好在创建",{"2":{"45":1}}],["最高的隔离级别",{"2":{"273":1,"279":1}}],["最低的隔离级别",{"2":{"273":1,"279":1}}],["最大限度减少系统不可用时间",{"2":{"320":1}}],["最大有60字节",{"2":{"241":1}}],["最大的优势在于查询效率",{"2":{"390":1}}],["最大的优势就是可以将很多数组操作的细节封装起来",{"2":{"45":1}}],["最大的特点就是支持随机访问",{"2":{"69":1}}],["最有用的mysql面试题",{"2":{"240":1}}],["最常用",{"2":{"202":1}}],["最久未使用的键值",{"2":{"202":1}}],["最少使用页面置换算法",{"2":{"449":1}}],["最少使用的键值",{"2":{"202":1}}],["最少频率使用",{"2":{"202":1}}],["最少裕度法",{"2":{"201":1}}],["最少跑多少趟就可以筛选出前三匹最快的马",{"0":{"46":1}}],["最短进程优先",{"2":{"201":1}}],["最短剩余时间优先",{"2":{"201":1}}],["最短作业有限",{"2":{"201":1}}],["最短路径",{"0":{"10":1}}],["最初系统调用是通过软中断触发的",{"2":{"153":1}}],["最长不重复子串",{"0":{"112":1}}],["最长回文子串",{"0":{"15":1}}],["最差时间复杂度以及优化",{"0":{"61":1}}],["最确切的定义应该是",{"2":{"56":1}}],["最后用的递归",{"2":{"365":1}}],["最后返回哥哥手中牌的分数之和与妹妹手中牌的总和的差",{"0":{"353":1}}],["最后才想出来用两个堆实现",{"0":{"257":1}}],["最后发现漏了一种情况",{"0":{"209":1}}],["最后回到根节点",{"0":{"100":1}}],["最后测试的时候要自己",{"2":{"63":1}}],["最后问了下面试官",{"2":{"58":1}}],["最后没绕出去",{"0":{"55":1}}],["最后",{"2":{"35":1,"439":1}}],["最小通路",{"0":{"16":1}}],["算法了解么",{"2":{"572":1}}],["算法不是很难",{"2":{"58":1}}],["算法是给一个很大的数字",{"0":{"26":1}}],["算法题",{"0":{"16":1,"61":1,"86":1,"112":1,"131":1,"182":1,"218":1,"226":1,"353":1,"371":1,"377":1}}],["算法",{"0":{"10":1,"49":1,"186":1,"223":1,"234":1,"250":1,"323":1},"2":{"552":1}}],["last",{"2":{"387":1}}],["language\\t响应体的语言\\tcontent",{"2":{"387":1}}],["language",{"2":{"387":2}}],["label1",{"2":{"285":1}}],["lbcc",{"2":{"297":1}}],["lfu",{"2":{"202":3,"449":1}}],["lfu设计与实现",{"0":{"25":1}}],["learn",{"0":{"524":1},"2":{"229":1}}],["least",{"2":{"202":2,"449":2}}],["less",{"0":{"200":1}}],["length\\t响应体的长度\\tcontent",{"2":{"387":1}}],["length",{"2":{"329":1,"387":2}}],["len",{"2":{"91":2,"390":1}}],["leetcode",{"0":{"9":1},"2":{"104":1}}],["loading并不高",{"2":{"473":1}}],["loading很高",{"2":{"469":1}}],["loading",{"2":{"435":1,"469":1}}],["locaiton",{"2":{"439":1}}],["location\\t用来重定向接收方到非请求url的位置来完成请求或标识新的资源\\tlocation",{"2":{"387":1}}],["location\\t请求资源可替代的备用的另一地址\\tcontent",{"2":{"387":1}}],["location",{"2":{"387":1}}],["lock解决了幻读",{"2":{"584":1}}],["lock已经解决了幻读问题",{"2":{"267":1}}],["lock",{"2":{"267":2,"297":1,"584":1,"587":1}}],["locking",{"2":{"103":1}}],["logdn",{"2":{"390":1}}],["logn",{"2":{"363":1,"390":1}}],["log恢复",{"2":{"303":1}}],["log刷盘",{"2":{"303":1}}],["log记录这次操作",{"2":{"303":1}}],["log来保证",{"2":{"303":1}}],["log里面",{"2":{"267":1}}],["log里面存储的数据都是我们操作的反向数据",{"2":{"267":1}}],["log",{"2":{"81":1,"254":1,"279":1,"297":1,"303":1,"583":4,"587":5}}],["long",{"2":{"45":2}}],["lru算法赋予每个页面一个访问字段",{"2":{"449":1}}],["lru",{"2":{"77":1,"180":1,"202":3,"449":1,"587":1}}],["lru设计与实现",{"0":{"18":1}}],["lsm",{"2":{"59":1}}],["lt",{"0":{"365":2},"2":{"45":1,"154":2,"180":2}}],["link",{"2":{"451":1}}],["linked",{"2":{"587":1}}],["linkedhashmap",{"2":{"77":1}}],["linkedlist",{"2":{"7":1}}],["line",{"2":{"403":1}}],["line3",{"2":{"308":1}}],["linear",{"2":{"28":1}}],["linux下如何查看一个服务的连接数目",{"2":{"572":1}}],["linuxio",{"0":{"517":1},"2":{"525":1}}],["linux内核了解多少",{"0":{"244":1}}],["linux",{"0":{"97":1,"165":1,"189":1,"200":1,"236":1},"1":{"109":1,"121":1,"135":1,"151":1,"165":1,"177":1,"189":1,"200":1,"211":1,"220":1,"228":1,"236":1,"244":2},"2":{"97":1,"229":1,"387":1,"525":1}}],["list",{"0":{"208":1},"2":{"7":1,"28":1,"154":1,"587":1}}],["我乱猜了",{"2":{"587":1}}],["我能想到的思路是从分布式出发",{"2":{"586":1}}],["我看互联网都是rc",{"2":{"584":1}}],["我总结了一下",{"2":{"549":1}}],["我总结了几点自己的经验",{"2":{"45":1}}],["我相信读者朋友们应该已经了解了二者的区别",{"2":{"543":1}}],["我就随便答了下",{"2":{"525":1}}],["我就回答了mvcc",{"2":{"297":1}}],["我回答成了进程之间的",{"2":{"525":1}}],["我回答的是cookie和session",{"2":{"523":1}}],["我回答b+树",{"2":{"345":1}}],["我在",{"2":{"397":1}}],["我答成503了",{"2":{"382":1}}],["我的思路就是大力出奇迹",{"2":{"335":1}}],["我的业务",{"2":{"169":1,"181":1}}],["我运行不出来",{"2":{"318":1}}],["我写出了一大半",{"2":{"318":1}}],["我写成了",{"0":{"107":1}}],["我可以直接在",{"0":{"316":1}}],["我也会把redis称为单线程模式",{"2":{"222":1}}],["我用一个栈来装入偶数位",{"0":{"186":1}}],["我只答了那个",{"2":{"178":1}}],["我说",{"2":{"587":1}}],["我说了",{"2":{"587":1}}],["我说了排序",{"2":{"154":1}}],["我说不太记得了",{"2":{"572":1}}],["我说用go内置的net",{"0":{"531":1}}],["我说能不能把数据库主从复制一样同步一下session",{"2":{"519":1}}],["我说使用一个代理保存所有session",{"2":{"519":1}}],["我说降低io次数",{"2":{"345":1}}],["我说没用过",{"0":{"324":1}}],["我说应该是time",{"0":{"280":1}}],["我说完了以后问可以优化吗最后思考了一下优化了空间",{"2":{"174":1}}],["我现在要做一个限流功能",{"0":{"133":1}}],["我万万没想到会出这个",{"0":{"99":1}}],["我当时脑子短路了",{"0":{"55":1}}],["我觉得",{"0":{"9":1}}],["我们可能会考虑当这8kb的栈空间被用完的时候该怎么办",{"2":{"546":1}}],["我们可以简述为",{"2":{"543":1}}],["我们可以一次性申请所有的资源",{"2":{"401":1}}],["我们可以建立一个组合索引",{"2":{"390":1}}],["我们可以回答对golang了解",{"2":{"203":1}}],["我们可以将路由器的其中一个接口的ip地址指定到该网络中所有主机的默认网关",{"2":{"195":1}}],["我们可以将插入位置的元素放到最后一个元素的下一个元素",{"2":{"35":1}}],["我们可以直接使用编程语言提供的容器类",{"2":{"69":1}}],["我们可以先记录下已经删除的数据",{"2":{"35":1}}],["我们还可以从存储空间的角度来看",{"2":{"580":1}}],["我们还可以接收通道里的数据",{"2":{"235":1}}],["我们还是以user举例",{"2":{"482":1}}],["我们再增加一个name字段",{"2":{"434":1}}],["我们再触发执行一次真正的删除操作",{"2":{"35":1}}],["我们只需要explain",{"2":{"434":1}}],["我们只需要将c放入到a",{"2":{"35":1}}],["我们称为3节点",{"2":{"426":1}}],["我们称为2节点",{"2":{"426":1}}],["我们知道范围查询是",{"2":{"390":1}}],["我们知道现代操作系统中",{"2":{"153":1}}],["我们刚刚已经讲了",{"2":{"390":1}}],["我们把热点的key放到不同的节点上去",{"2":{"320":1}}],["我们设置缓存的时候可以随机初始化它的失效时间",{"2":{"320":1}}],["我们在副本中打的怪和掉的装备",{"2":{"261":1}}],["我们一般说redis是单线程",{"2":{"222":1,"230":1}}],["我们通常说",{"2":{"222":1}}],["我们已经了解了进程和线程的结构",{"2":{"153":1}}],["我们暂不展开线程调度的问题",{"2":{"153":1}}],["我们不难发现",{"2":{"56":1}}],["我们看下面这几行代码",{"2":{"45":1}}],["我们就称之为覆盖索引",{"2":{"434":1}}],["我们就在这个数据库请求这一步上锁",{"2":{"320":1}}],["我们就不能往这个通道里发送数据了",{"2":{"235":1}}],["我们就完全不需要关心底层的扩容逻辑",{"2":{"45":1}}],["我们就需要重新分配一块更大的空间",{"2":{"45":1}}],["我们要依次删除",{"2":{"35":1}}],["我们继续来看例子",{"2":{"35":1}}],["我们并不一定非得追求数组中数据的连续性",{"2":{"35":1}}],["我们现在需要将元素",{"2":{"35":1}}],["我们指的是",{"2":{"7":2}}],["我们至少会创建两个对象",{"2":{"7":1}}],["乱写的",{"0":{"9":1}}],["数",{"2":{"572":1}}],["数字签名",{"0":{"539":1}}],["数字必须在",{"0":{"323":1}}],["数字越小优先级越高",{"2":{"192":1}}],["数字不记得了",{"0":{"9":1}}],["数组内打印三个数",{"0":{"250":1}}],["数组由一个升序数组翻转形成",{"0":{"175":1}}],["数组也可以进行切片",{"2":{"120":1}}],["数组和slice之间不能相互赋值",{"2":{"120":1}}],["数组和链表的区别",{"2":{"28":1}}],["数组定长",{"2":{"120":1}}],["数组未初始化能不能求len",{"0":{"96":1}}],["数组用一块连续的内存空间",{"2":{"69":1}}],["数组中的正负数相互间隔",{"2":{"58":1}}],["数组中的元素如下",{"2":{"35":1}}],["数组它按照下面的规则重排列后的数组",{"2":{"58":1}}],["数组选择了从",{"2":{"56":1}}],["数组作为非常基础的数据结构",{"2":{"56":1}}],["数组要从0开始编号",{"2":{"56":1}}],["数组本身在定义的时候需要预先指定大小",{"2":{"45":1}}],["数组越界在",{"2":{"45":1}}],["数组长度为n",{"2":{"35":1}}],["数组插入的时间复杂度可以由o",{"2":{"35":1}}],["数组插入和删除技巧",{"0":{"35":1}}],["数组拥有连续的内存空间以及相同类型的数据",{"2":{"28":1}}],["数组",{"2":{"28":1,"35":1,"188":1}}],["数组基本概念",{"0":{"21":1},"1":{"28":1,"35":1,"45":1,"56":1,"69":1}}],["数据从两端一来一回",{"2":{"572":1}}],["数据表设计遵循的原则",{"0":{"518":1}}],["数据就存放在报文的body里面",{"2":{"503":1}}],["数据传输完成",{"2":{"439":1}}],["数据缓存服务中查找是否缓存过当前域名信息",{"2":{"439":1}}],["数据流指定的优先级越高会优先响应",{"2":{"411":1}}],["数据流的中位数",{"0":{"257":1}}],["数据对象的插入和删除仅在叶节点上进行",{"2":{"345":1}}],["数据",{"2":{"267":1,"268":1}}],["数据已经发过来或者我准备写数据了",{"2":{"230":1}}],["数据的封装过程",{"2":{"225":1}}],["数据如何在各层之间传输",{"2":{"225":1}}],["数据返回怎么做",{"2":{"196":1}}],["数据移动",{"2":{"154":1}}],["数据资源等",{"2":{"153":1}}],["数据报组装成帧",{"2":{"129":1}}],["数据链路层能够简单的丢弃掉这个帧",{"2":{"129":1}}],["数据链路层将网络层交下来的",{"2":{"129":1}}],["数据链路层通常也叫做链路层",{"2":{"129":1}}],["数据链路层把网络层传下来的分组封装成帧",{"2":{"129":1}}],["数据链路层",{"2":{"129":1,"184":1}}],["数据单位为用户数据报",{"2":{"129":1}}],["数据单位为报文段",{"2":{"129":1}}],["数据加密以及数据描述",{"2":{"129":1}}],["数据库事务回滚方法",{"2":{"587":1}}],["数据库优化+缓存",{"0":{"559":1}}],["数据库中有两个关联列",{"0":{"547":1}}],["数据库中数据很多的时候如何处理",{"0":{"351":1}}],["数据库完整性的实现",{"0":{"538":1}}],["数据库表是如何设计的",{"0":{"532":1}}],["数据库表如何设计",{"2":{"59":1}}],["数据库三大范式",{"0":{"522":1}}],["数据库聚集索引和辅助索引",{"0":{"438":1}}],["数据库覆盖索引",{"0":{"434":1}}],["数据库的主从备份",{"0":{"585":1}}],["数据库的部署怎么做",{"0":{"555":1}}],["数据库的索引",{"0":{"414":1,"430":1}}],["数据库的应用开发中",{"2":{"309":1}}],["数据库使用b+树的好处",{"2":{"345":1}}],["数据库索引是存储在磁盘上的",{"2":{"375":1}}],["数据库索引结构是什么样的",{"2":{"345":1}}],["数据库索引",{"2":{"339":1}}],["数据库里面会创建一个视图",{"2":{"291":1}}],["数据库用的是什么",{"2":{"261":1}}],["数据库考点",{"2":{"240":1}}],["数据库设计",{"0":{"232":1}}],["数据库设计基础",{"2":{"103":1}}],["数据库语句",{"0":{"216":1}}],["数据库架构设计",{"2":{"103":1}}],["数据库隔离级别",{"2":{"103":1}}],["数据中的相同值",{"0":{"98":1}}],["数据+",{"0":{"86":1}}],["数据结构",{"2":{"154":1}}],["数据结构系列",{"0":{"154":1}}],["数据结构和算法的魅力就在于此",{"2":{"35":1}}],["数据结构具体实现",{"0":{"11":1}}],["数据之间并不是简单的前后关系",{"2":{"28":1}}],["数据集合",{"2":{"8":1}}],["37964071",{"2":{"551":1}}],["3d",{"2":{"451":1}}],["3树是3阶b树",{"2":{"426":1}}],["3树与2",{"2":{"426":1}}],["3版本",{"2":{"415":1}}],["3~4",{"2":{"390":2}}],["31",{"2":{"387":1}}],["39524574",{"2":{"303":1}}],["3种高级数据结构",{"2":{"154":1}}],["3g",{"2":{"153":1}}],["302",{"0":{"533":1},"2":{"572":1}}],["301",{"0":{"533":1},"2":{"439":1,"572":1}}],["304",{"2":{"382":1}}],["30",{"2":{"91":2,"482":5}}],["36匹马",{"0":{"46":1}}],["3",{"0":{"126":1,"175":3,"187":1,"263":1,"347":1,"365":1},"2":{"35":1,"58":3,"91":1,"180":2,"184":1,"195":1,"202":2,"213":2,"267":4,"285":2,"308":1,"329":5,"387":1,"426":3,"451":2,"525":2,"549":1,"583":2,"586":1,"587":1}}],["32",{"0":{"34":1}}],["348",{"2":{"387":1}}],["34",{"0":{"9":1}}],["33",{"0":{"9":1}}],["1的主要问题在于",{"2":{"415":1}}],["1的数据",{"2":{"320":1}}],["1增加connection字段",{"2":{"407":1}}],["1会遇到的问题",{"2":{"399":1}}],["199",{"2":{"387":1}}],["1e9",{"0":{"365":1}}],["140876416",{"2":{"363":1}}],["14048326",{"2":{"222":1}}],["13",{"0":{"341":1}}],["133期",{"2":{"240":1}}],["17",{"2":{"340":1}}],["1a2b3c1d2a3b",{"2":{"329":1}}],["1版本开始才引入的",{"2":{"285":1}}],["1→2→3",{"2":{"182":1}}],["120",{"2":{"387":1}}],["12",{"2":{"387":3}}],["127",{"2":{"180":4}}],["1232212134343",{"0":{"323":1}}],["12322121343434",{"0":{"323":1}}],["123",{"2":{"7":1,"81":1,"134":4,"154":1,"182":1}}],["1分钟",{"2":{"177":1}}],["16位平台上分全局堆和局部堆",{"2":{"221":1}}],["16",{"2":{"134":1,"387":1}}],["15分钟",{"2":{"177":1}}],["15",{"2":{"91":3}}],["1～10000",{"0":{"73":1}}],["111693947",{"2":{"303":1}}],["11323248",{"2":{"285":1}}],["11",{"2":{"45":1,"434":2,"482":1}}],["10807289",{"2":{"491":1}}],["10w",{"0":{"380":1}}],["106916092",{"2":{"285":1}}],["100组",{"0":{"139":1}}],["100g",{"0":{"124":1}}],["100ms",{"2":{"572":1}}],["100mb",{"2":{"180":1}}],["100m",{"0":{"124":1}}],["100",{"0":{"55":1,"61":2},"2":{"469":1}}],["1000",{"0":{"53":1}}],["10000",{"2":{"45":1}}],["100之间的浮点数",{"0":{"49":1}}],["10",{"0":{"359":1},"2":{"35":1,"45":1,"233":1,"439":1,"482":4,"525":1,"543":5}}],["1t大文件",{"0":{"30":1}}],["1",{"0":{"9":1,"43":1,"94":1,"175":3,"187":1,"263":1,"287":1,"311":2,"316":1,"341":1,"365":1,"399":1,"407":1},"1":{"403":1,"407":1,"411":1,"415":1},"2":{"28":1,"35":1,"45":1,"56":3,"58":5,"180":4,"184":1,"267":2,"285":3,"329":3,"335":1,"375":2,"387":6,"397":3,"399":1,"401":6,"467":1,"503":1,"549":1,"551":1,"552":1,"583":3,"586":1,"587":1}}],["dict",{"2":{"587":1}}],["draft",{"2":{"482":2}}],["drawquad",{"2":{"451":1}}],["drity",{"2":{"267":1}}],["dsack",{"2":{"268":1}}],["data",{"2":{"482":4}}],["datagram",{"2":{"241":1}}],["data段",{"2":{"221":1}}],["date\\t原始服务器消息发出的时间\\tdate",{"2":{"387":1}}],["date",{"2":{"134":1}}],["dd",{"0":{"200":1}}],["df",{"0":{"200":1}}],["dfs和bfs的区别",{"0":{"40":1}}],["du",{"0":{"200":1}}],["d的特点",{"2":{"169":1}}],["document",{"2":{"451":1}}],["docker",{"2":{"59":1}}],["dom",{"2":{"451":5}}],["don",{"2":{"400":1}}],["double类型表示的浮点数在redis中也是作为字符串值来保存的",{"2":{"154":1}}],["dbyte",{"2":{"134":1}}],["dns的工作流程",{"2":{"560":1}}],["dns协议",{"0":{"558":1}}],["dns",{"0":{"560":2,"570":1},"2":{"129":1,"172":1,"439":3,"560":5}}],["d",{"2":{"35":3,"134":1,"195":1,"329":1,"390":3}}],["dp",{"0":{"12":1,"26":1}}],["dynamic",{"0":{"9":1}}],["de",{"2":{"578":1}}],["deep",{"2":{"500":1}}],["dec",{"2":{"387":1}}],["details",{"2":{"279":1,"285":1,"297":1,"303":1,"321":1,"551":1}}],["delete",{"2":{"240":1,"285":1,"357":1}}],["desc",{"2":{"134":1}}],["description",{"2":{"7":1}}],["debug",{"2":{"45":1}}],["defer的执行顺序",{"0":{"468":1}}],["defer",{"0":{"460":1,"464":1,"472":3,"476":1}}],["default",{"2":{"1":1}}],["defineuserconfig",{"2":{"1":2}}],["第2步调用引擎接口将数据写到哪里",{"2":{"583":1}}],["第三个参数是可选参数",{"2":{"543":1}}],["第三范式",{"2":{"522":1}}],["第三子树包含大于第二元素",{"2":{"426":1}}],["第",{"0":{"365":1}}],["第二轮就难很多",{"2":{"587":1}}],["第二个参数是",{"2":{"543":1}}],["第二范式",{"2":{"522":1}}],["第二子树包含大于最小元素",{"2":{"426":1}}],["第二种",{"2":{"203":1}}],["第二题是特别简单的",{"0":{"9":1}}],["第一个参数是类型",{"2":{"543":3}}],["第一范式",{"2":{"522":1}}],["第一道原题",{"0":{"257":1}}],["第一题",{"0":{"247":1}}],["第一种",{"2":{"203":1}}],["第一是线性表",{"2":{"28":1}}],["第一次初始化时一定要先使用git",{"2":{"2":1}}],["压缩列表",{"2":{"8":1}}],["字段名与",{"2":{"587":1}}],["字段中加上重定向的地址信息",{"2":{"439":1}}],["字段",{"0":{"579":1},"2":{"390":1}}],["字段表示实际用的索引",{"2":{"390":1}}],["字段表示可能用到的索引",{"2":{"390":1}}],["字段里加一个",{"2":{"268":1}}],["字段加版本号",{"2":{"185":1}}],["字型打印二叉树",{"0":{"193":1}}],["字符的子串数",{"0":{"87":1}}],["字符串的前几个字符建立索引",{"2":{"390":1}}],["字符串对象",{"2":{"154":4}}],["字符串逆置",{"0":{"99":1}}],["字符串中只有",{"0":{"87":1}}],["字符串比较",{"0":{"74":1}}],["字符串匹配算法",{"0":{"31":1}}],["字符串数组的公共最长前缀",{"0":{"23":1}}],["字符串键",{"2":{"7":1}}],["字典",{"2":{"8":1}}],["列表键",{"2":{"7":1}}],["列表对象",{"2":{"6":2,"7":1}}],["时候通过redo",{"2":{"303":1}}],["时候再做处理",{"2":{"87":1}}],["时间事件",{"0":{"368":1}}],["时间找到最小的一个节点",{"2":{"363":1}}],["时间处理器",{"2":{"230":1}}],["时间最友好",{"2":{"213":1}}],["时间用于删除和当前任务无关的过期键上",{"2":{"213":1}}],["时间紧张的情况下",{"2":{"213":1}}],["时间",{"2":{"213":1}}],["时间片轮转调度算法",{"2":{"201":1}}],["时序型数据库的存储结构是怎么样的",{"2":{"59":1}}],["时",{"2":{"7":2,"213":1,"587":1}}],["当创建一个goroutine的时候",{"2":{"546":1}}],["当有消息返回式系统会通知进程进行处理",{"2":{"485":1}}],["当须淘汰一个页面时",{"2":{"449":1}}],["当时只回答了递归解析和迭代解析",{"2":{"560":1}}],["当时问到这个回答的很简略",{"2":{"483":1}}],["当时答的时候也只答了",{"2":{"400":1}}],["当时间到达时",{"2":{"213":1}}],["当线程",{"2":{"397":1,"401":1}}],["当索引数据结构",{"2":{"390":1}}],["当客户端访问受口令保护时",{"2":{"387":1}}],["当数据量大时",{"2":{"375":1}}],["当数组没有更多空间存储数据时",{"2":{"35":1}}],["当需要进行一次全数据遍历的时候",{"2":{"363":1}}],["当",{"2":{"329":1}}],["当查询到数据之后直接将数据缓存到redis里面",{"2":{"320":1}}],["当想要读取的数据被其他事务用排它锁锁住时",{"2":{"297":1}}],["当sessiona执行delete时",{"2":{"285":1}}],["当出现读写锁冲突的时候",{"2":{"273":1,"279":1}}],["当超过慢启动门限之后就开始拥塞避免算法",{"2":{"268":1}}],["当一个孤儿进程",{"2":{"229":1}}],["当一个进程完成它的工作终止之后",{"2":{"229":1}}],["当操作系统有多个cpu时",{"2":{"212":1}}],["当内存不足以容纳新写入数据时",{"2":{"202":5}}],["当两个或两个以上的进程",{"2":{"201":1}}],["当主机a给另一个网络发送广播时",{"2":{"195":1}}],["当前读产生的结果",{"2":{"240":1}}],["当前登录用户数",{"2":{"177":1}}],["当前执行用户空间的程序指令",{"2":{"153":1}}],["当场去世",{"2":{"254":1,"587":2}}],["当场翻车",{"0":{"161":1}}],["当场算没算",{"0":{"70":1}}],["当cpu执行到这些指令时就会陷入内核态",{"2":{"153":1}}],["当然这只是简略模拟图",{"2":{"345":1}}],["当然",{"2":{"267":1}}],["当然slice有自己的copy函数",{"2":{"120":1}}],["当然不是",{"2":{"45":1}}],["当要表示多维数组时",{"2":{"45":1}}],["当第",{"2":{"45":1}}],["当我们执行",{"2":{"482":1}}],["当我们在mysql中用哈希索引时",{"2":{"345":1}}],["当我们寻求如何消灭系统中大量的僵尸进程时",{"2":{"229":1}}],["当我们给路由器的接口配置ip地址和子网掩码的时候",{"2":{"195":1}}],["当我们对embstr编码的字符串对象执行任何修改命令时",{"2":{"154":1}}],["当我们对一个数据库键执行type命令时",{"2":{"7":1}}],["当我们使用json序列化nil",{"2":{"134":1}}],["当我们查询或者处理一个空的列表的时候",{"2":{"134":2}}],["当我们称呼一个键为",{"2":{"7":1}}],["当我们称呼一个数据库键为",{"2":{"7":1}}],["当程序不再使用某个对象的时候",{"2":{"6":1}}],["●",{"2":{"7":3}}],["zjtyypbbnuhgahtf1zxfrq",{"2":{"584":1}}],["zh",{"2":{"387":1}}],["zhuanlan",{"2":{"363":1}}],["zhihu",{"0":{"82":1},"2":{"363":1}}],["zombie",{"2":{"229":2}}],["ziyoung",{"2":{"222":1}}],["ziplist和hashtable之间区别",{"2":{"154":1}}],["ziplist是如何实现的",{"2":{"154":1}}],["ziplist",{"2":{"7":1}}],["z",{"0":{"193":1},"2":{"451":3}}],["zrange命令",{"2":{"154":1}}],["zk",{"2":{"133":1}}],["zset的时间复杂度",{"2":{"154":1}}],["zset如何实现有序",{"2":{"154":1}}],["zset实现原理",{"2":{"154":1}}],["zset",{"2":{"7":1,"154":2}}],["hat",{"2":{"387":1}}],["hashtable",{"2":{"587":1}}],["hashtable实现",{"2":{"154":1}}],["hash索引",{"2":{"390":1}}],["hash索引的优缺点以及实现",{"0":{"345":1}}],["hash表的扩容",{"0":{"66":1}}],["hash表是如何实现的",{"0":{"66":1}}],["hashmap",{"0":{"42":1}}],["hash",{"0":{"98":1},"2":{"7":1,"154":1,"390":4,"525":1,"587":1}}],["heading",{"2":{"491":1}}],["head",{"2":{"387":1,"403":1,"451":1}}],["header中的connection字段",{"2":{"399":1}}],["header\\t解释\\t示例",{"2":{"387":1}}],["header",{"2":{"7":1}}],["host",{"2":{"387":1,"560":1}}],["hyperloglog",{"2":{"154":1}}],["h",{"2":{"35":2}}],["htm",{"2":{"387":1}}],["html",{"2":{"177":1,"222":1,"285":1,"387":3,"439":1,"443":2,"451":1,"483":1,"491":1}}],["http断点续传",{"0":{"542":1}}],["http包实现的",{"0":{"531":1}}],["http中的请求方法",{"2":{"475":1}}],["http中的请求方法有哪些",{"0":{"391":1}}],["http是基于tcp的",{"2":{"399":1}}],["http3",{"0":{"399":1,"415":1},"1":{"403":1,"407":1,"411":1,"415":1}}],["http302",{"2":{"382":1}}],["http2主要问题在于多个请求复用",{"2":{"415":1}}],["http2",{"0":{"399":1,"411":1,"487":1},"1":{"403":1,"407":1,"411":1,"415":1}}],["http1",{"0":{"399":2,"403":1,"407":1,"487":1},"1":{"403":2,"407":2,"411":2,"415":2},"2":{"399":2,"407":1,"415":1}}],["http请求头有什么内容",{"0":{"527":1}}],["http请求报文格式",{"0":{"395":1}}],["http请求发送时",{"2":{"387":1}}],["http常见字段有哪些",{"0":{"387":1}}],["http响应状态码",{"2":{"382":1}}],["http状态码",{"0":{"382":1}}],["http和https在建立连接的时候的区别与联系",{"0":{"471":1}}],["http和https",{"0":{"376":1},"1":{"382":1,"387":1,"391":1,"395":1,"399":1,"403":1,"407":1,"411":1,"415":1,"419":1,"423":1,"427":1,"431":1,"435":1,"439":1,"443":1,"447":1,"451":1,"455":1,"459":1,"463":1,"467":1,"471":1,"475":1,"479":1,"483":1,"487":1,"491":1,"495":1,"499":1,"503":1,"507":1,"511":1,"515":1,"519":1,"523":1,"527":1,"530":1,"533":1,"536":1,"539":1,"542":1}}],["http",{"0":{"479":1,"483":1,"491":1,"530":1,"539":1,"572":1},"2":{"129":1,"387":2,"439":3,"455":6,"479":1,"483":3,"572":8}}],["https中的s指的是什么",{"0":{"471":1}}],["https中ssl的握手过程",{"0":{"463":1},"1":{"467":1}}],["https采用混合的加密机制",{"2":{"467":1}}],["https为什么要对称加密",{"0":{"459":1}}],["https和http区别",{"0":{"455":1}}],["https要建立一个连接由之前的六次握手合并成三次",{"2":{"415":1}}],["https",{"0":{"82":1,"419":1,"524":1,"539":1},"2":{"177":1,"222":1,"229":1,"285":2,"303":1,"363":1,"439":2,"455":4,"483":1,"491":3,"549":3,"551":1,"572":1,"584":3,"587":1}}],["ht",{"2":{"7":1}}],["s",{"2":{"543":1,"584":3,"587":1}}],["symbol",{"2":{"525":1}}],["sync",{"0":{"318":1,"330":1}}],["syntax",{"2":{"7":1}}],["shell",{"2":{"525":2}}],["shallow",{"2":{"500":1}}],["share",{"2":{"400":1}}],["shared",{"2":{"179":1}}],["sharing",{"2":{"400":1}}],["ssl",{"0":{"423":1,"539":1},"2":{"455":2}}],["scan",{"2":{"357":1}}],["scheduler",{"2":{"201":1}}],["slot",{"0":{"296":1}}],["slave",{"2":{"285":2}}],["slice与map都不是线程安全的",{"2":{"199":1}}],["slice的底层原理",{"2":{"150":1}}],["slice的时候将会序列化后才能一个",{"2":{"134":1}}],["slice的时候将会序列化成null",{"2":{"134":1}}],["slice底层实现",{"0":{"150":1}}],["slice是不同的东西",{"2":{"134":1}}],["slice用法",{"2":{"134":2}}],["slice区别",{"0":{"134":1}}],["slice",{"0":{"134":1,"199":1,"210":1},"2":{"120":2,"134":1,"500":1,"516":5,"543":8}}],["slice赋值和指针一样",{"2":{"120":1}}],["sanyuesan0000",{"2":{"279":1,"297":1,"321":1}}],["sack",{"2":{"268":5,"572":1}}],["signal",{"2":{"179":1,"525":2}}],["size=",{"2":{"482":1}}],["size",{"0":{"91":1},"2":{"56":1,"543":1}}],["seid=84378165225275780",{"2":{"491":1}}],["search",{"2":{"426":1}}],["self",{"2":{"426":1}}],["select语句什么时候行锁什么时候变表锁",{"0":{"466":1}}],["select",{"0":{"389":1},"2":{"285":2,"309":1,"434":2,"466":1,"482":1,"576":1,"587":2}}],["select的时候新生成一个版本号",{"2":{"279":1}}],["selective",{"2":{"268":1}}],["seq",{"0":{"316":5}}],["session",{"0":{"530":1},"2":{"572":1}}],["session机制来做身份认证和状态记录",{"2":{"403":1}}],["sessionb执行insert时就会阻塞",{"2":{"285":1}}],["sessionb执行commit",{"2":{"285":1}}],["sessionb执行",{"2":{"285":1}}],["sessionb设置隔离级别为rc",{"2":{"285":1}}],["sessiona执行",{"2":{"285":1}}],["sessiona设置隔离级别为rc",{"2":{"285":1}}],["session的关系",{"0":{"160":1}}],["semi",{"2":{"285":1}}],["semaphores",{"2":{"179":1}}],["serializable",{"2":{"273":1,"279":1}}],["server\\tweb服务器软件名称\\tserver",{"2":{"387":1}}],["servercron",{"0":{"368":1,"374":1}}],["server",{"2":{"233":1,"584":1}}],["sed",{"0":{"200":1}}],["set",{"0":{"296":1},"2":{"7":1,"91":4,"154":1,"180":2,"387":1}}],["style=",{"2":{"482":1}}],["stylesheets",{"2":{"451":1}}],["style",{"2":{"451":2}}],["status",{"2":{"387":1}}],["started",{"2":{"525":1}}],["starttime",{"0":{"377":1}}],["start",{"2":{"154":1}}],["stop",{"2":{"154":1}}],["student",{"2":{"134":3}}],["streams底层的数据结构是radix",{"2":{"154":1}}],["streams也有consumer",{"2":{"154":1}}],["streams",{"2":{"154":1}}],["string",{"2":{"7":1,"134":5,"154":2,"500":1,"552":2}}],["struct结构体",{"2":{"153":1}}],["struct",{"2":{"7":1,"91":1,"134":1,"500":1,"552":1}}],["smtp",{"2":{"129":1,"172":1}}],["sql慢查询",{"0":{"565":1}}],["sql语句看extra的结果是否是",{"2":{"434":1}}],["sql语句",{"0":{"205":1,"571":1,"574":1},"1":{"216":1}}],["sql",{"0":{"579":1,"582":1,"583":1},"2":{"103":4,"273":2,"291":1,"390":4,"466":1,"578":1,"587":1}}],["socket的概念",{"0":{"497":1}}],["socket",{"0":{"492":1}}],["sockets",{"2":{"179":1}}],["sort",{"2":{"426":1}}],["so",{"0":{"26":1}}],["substring",{"0":{"26":1}}],["sds",{"2":{"8":1}}],["skiplist的其中一个",{"2":{"7":1}}],["该索引必须是唯一索引",{"2":{"580":1}}],["该",{"2":{"525":1}}],["该置换算法选择在之前时期使用最少的页面作为淘汰页",{"2":{"449":1}}],["该导航流程结束",{"2":{"443":1}}],["该主键索引就是聚簇索引",{"2":{"390":1}}],["该级别可以防止脏读",{"2":{"273":1,"279":1}}],["该数据报接下来被传递给链路层",{"2":{"225":1}}],["该信息让接收端能够判断报文中的比特是否在途中已被改变",{"2":{"225":1}}],["该信息可以用于计算数据库键的空转时长",{"2":{"6":1}}],["该首部将被接收端的运输层使用",{"2":{"225":1}}],["该消息队列才会被真正的删除",{"2":{"179":1}}],["该协议实现两个基本功能",{"2":{"172":1}}],["该层另外两个主要协议是互联网组管理协议",{"2":{"172":1}}],["该层对应于",{"2":{"172":1}}],["该层提供了数据交换的定界和同步功能",{"2":{"129":1}}],["该层提供的服务主要包括数据压缩",{"2":{"129":1}}],["该算法效率高",{"2":{"154":1}}],["该服务并不针对某一特定的应用",{"2":{"129":1}}],["该结构中和保存数据有关的三个属性分别是type属性",{"2":{"7":1}}],["rr下会产生幻读",{"2":{"584":1}}],["rr没幻读",{"2":{"584":1}}],["rr有next",{"2":{"584":1}}],["rr通过next",{"2":{"584":1}}],["rr级别通过",{"2":{"584":1}}],["rr级别有",{"2":{"584":1}}],["rmqymgfgyfllo69l6sbblq",{"2":{"584":1}}],["rtt",{"2":{"572":1}}],["runtime",{"2":{"546":1}}],["rsa",{"0":{"539":1}}],["rgb",{"2":{"451":1}}],["rc读取已提交",{"2":{"279":1}}],["rdb不读",{"2":{"213":1}}],["rdb就是将我们所有的k",{"2":{"213":1}}],["range\\t在整个返回体中本部分的字节位置\\tcontent",{"2":{"387":1}}],["ranges",{"2":{"387":1}}],["ranges\\t表明服务器是否支持指定范围请求及哪种类型的分段请求\\taccept",{"2":{"387":1}}],["range",{"2":{"357":1,"387":1,"390":1}}],["random",{"0":{"287":3},"2":{"202":2}}],["raw",{"2":{"7":1}}],["rpc",{"0":{"540":1},"2":{"179":1}}],["rekmg6hngkrncng",{"2":{"587":1}}],["response",{"2":{"572":1}}],["restful",{"2":{"572":1}}],["recover",{"0":{"460":1,"476":1}}],["recently",{"2":{"202":1}}],["redo持久性",{"2":{"584":1}}],["redolog",{"0":{"584":1},"2":{"584":2}}],["redo",{"2":{"583":3,"587":5}}],["red",{"2":{"387":1}}],["redis集群",{"2":{"320":1}}],["redis一般都是集群部署",{"2":{"320":1}}],["redis一定是单线程么",{"2":{"230":1}}],["redis一定是单线程的么",{"2":{"222":1,"230":1}}],["redis这种模型的瓶颈在于从套接字中读写数据",{"2":{"230":1}}],["redis采用的是io多路复用模型",{"2":{"230":1}}],["redis缓存系列",{"2":{"222":1}}],["redis缓存过期处理与内存淘汰机制",{"2":{"213":1}}],["redis更新后线程挂掉了怎么办",{"2":{"222":1}}],["redis所有事情都只有一个单线程么",{"2":{"222":1}}],["redis单线程模型为什么可以那么快",{"2":{"222":1}}],["redis如何保证高性能",{"2":{"222":1,"230":1}}],["redis为什么那么高效",{"2":{"222":1}}],["redis为什么引入多线程模型",{"2":{"222":1,"230":1}}],["redis为什么不直接使用c字符串",{"2":{"154":1}}],["redis并不是单线程",{"2":{"222":1}}],["redis并没有直接使用数据结构来实现键值对数据库",{"2":{"6":1}}],["redis是单线程模型还是多线程模型",{"2":{"222":1}}],["redis是单线程",{"2":{"222":1}}],["redis过期之后",{"2":{"213":1}}],["redis过期处理两种方式",{"2":{"213":1}}],["redis过期处理方式",{"0":{"213":1}}],["redis中选择",{"2":{"213":1}}],["redis中的hashtable介绍",{"2":{"154":1}}],["redis中的每个对象都由一个redisobject结构表示",{"2":{"7":1}}],["redis内存淘汰机制",{"0":{"202":1}}],["redis内存满了怎么办",{"0":{"180":1}}],["redis未设置过期时间会怎么样",{"0":{"191":1}}],["redis设计与实现",{"2":{"154":1}}],["redis5",{"2":{"154":1}}],["redis的事件分发",{"0":{"350":1}}],["redis的读更新和写更新",{"2":{"222":1}}],["redis的io模型",{"0":{"230":1},"2":{"222":1}}],["redis的定时删除策略是怎样的",{"2":{"213":1}}],["redis的淘汰算法实际实现上并非针对所有key",{"2":{"202":1}}],["redis的数据类型",{"2":{"154":1}}],["redis的整数集合是什么",{"2":{"154":1}}],["redis的哈希表如何扩容",{"2":{"154":1}}],["redis的哈希表扩容有什么特色",{"2":{"154":1}}],["redis的hash",{"2":{"154":1}}],["redis的对象带有访问时间记录信息",{"2":{"6":1}}],["redis的对象系统还实现了基于引用计数技术的内存回收机制",{"2":{"6":1}}],["redis使用的字符串有什么特点",{"2":{"154":1}}],["redis使用对象来表示数据库中的键和值",{"2":{"7":1}}],["redis数据结构的两种表现形式",{"2":{"154":1}}],["redis面试题整理",{"0":{"138":1},"1":{"154":1,"168":1,"180":1,"191":1,"202":1,"213":1,"222":1,"230":1,"238":1,"246":1,"253":1,"260":1,"266":1,"272":1,"278":1,"284":1,"290":1,"296":1,"302":1,"308":1,"314":1,"320":1,"326":1,"332":1,"338":1,"344":1,"350":1,"356":1,"362":1,"368":1,"374":1,"380":1,"385":1}}],["redis主要数据结构一览",{"0":{"8":1}}],["redis",{"0":{"246":2,"253":1,"278":1,"284":1,"332":1,"338":1,"362":1,"380":1,"553":1},"2":{"7":12,"138":1,"154":8,"180":4,"202":9,"213":1,"222":1,"385":2}}],["redisobject",{"2":{"7":1}}],["redis对象系统介绍",{"0":{"7":1}}],["redis还通过引用计数技术实现了对象共享机制",{"2":{"6":1}}],["redis可以在执行命令之前",{"2":{"6":1}}],["retry",{"2":{"387":1}}],["return",{"2":{"91":4}}],["ref",{"2":{"390":2}}],["refresh\\t应用于重定向或一个新的资源被创造",{"2":{"387":1}}],["referer",{"2":{"387":1}}],["remote",{"2":{"387":1}}],["request",{"2":{"387":2,"572":1}}],["repeatable",{"2":{"267":1,"273":1,"279":1}}],["read",{"2":{"267":3,"273":3,"279":4}}],["rehash过程",{"2":{"154":1}}],["rows",{"2":{"390":1}}],["row",{"2":{"267":1,"482":1}}],["rocksdb",{"2":{"59":1}}],["robj",{"2":{"7":1}}],["video",{"2":{"491":1}}],["via\\t告知代理客户端响应是通过哪里发送的\\tvia",{"2":{"387":1}}],["view",{"2":{"279":1}}],["version=1",{"2":{"387":1}}],["verson",{"2":{"297":1}}],["v",{"2":{"213":1}}],["v写入到数据库中",{"2":{"213":1}}],["volatile在英文中表示易挥发",{"2":{"202":1}}],["volatile",{"2":{"202":4}}],["void",{"2":{"7":1}}],["varchar",{"0":{"578":1}}],["vary\\t告诉下游代理是使用缓存响应还是从原始服务器请求\\tvary",{"2":{"387":1}}],["var",{"2":{"96":1,"552":2}}],["values",{"2":{"482":5}}],["value",{"2":{"202":1}}],["val",{"0":{"91":2},"2":{"552":2}}],["vue",{"2":{"0":1}}],["vuepress",{"2":{"0":6,"1":4}}],["eb95fghyvlthof9uhqyvdg",{"2":{"584":1}}],["etcd",{"0":{"537":1}}],["etag\\t请求变量的实体标签的当前值\\tetag",{"2":{"387":1}}],["e9",{"0":{"524":1}}],["e5",{"0":{"524":3}}],["eq",{"2":{"390":1}}],["epoll",{"0":{"389":1,"393":1}}],["epoll的底层实现",{"0":{"373":1}}],["explain",{"2":{"434":2}}],["expires\\t响应过期的日期和时间\\texpires",{"2":{"387":1}}],["export",{"2":{"1":1}}],["en",{"2":{"387":1}}],["endtime",{"0":{"377":1}}],["encoding\\t文件传输编码\\ttransfer",{"2":{"387":1}}],["encoding\\tweb服务器支持的返回内容压缩编码类型",{"2":{"387":1}}],["encoding属性记录了对象所使用的编码",{"2":{"7":1}}],["encoding属性和ptr属性",{"2":{"7":1}}],["encoding",{"2":{"7":9,"134":1,"387":3}}],["eviction是驱逐的意思",{"2":{"202":1}}],["empty",{"0":{"134":1},"2":{"134":3}}],["embstr编码的字符串对象在执行修改命令之后",{"2":{"154":1}}],["embstr",{"2":{"7":1}}],["e",{"2":{"35":3,"482":1}}],["easy",{"0":{"9":1}}],["443",{"2":{"439":1,"455":1}}],["4树是4阶b树",{"2":{"426":1}}],["4树都是b树的特例",{"2":{"426":1}}],["4树包含了4节点的使用",{"2":{"426":1}}],["4次",{"0":{"424":1}}],["47022",{"2":{"387":1}}],["47021",{"2":{"387":1}}],["404",{"2":{"387":1}}],["42144277",{"2":{"285":1}}],["4层协议",{"0":{"172":1}}],["4g",{"2":{"153":1}}],["46",{"2":{"134":1}}],["4",{"0":{"9":1,"70":1,"175":3,"187":1,"323":1},"2":{"7":2,"58":2,"180":2,"195":1,"202":2,"267":1,"285":3,"308":1,"439":1,"525":1,"572":2,"580":1,"583":2,"586":1}}],["对称密钥加密",{"2":{"467":2}}],["对称密钥为什么速度快",{"0":{"427":1}}],["对索引效率也有很大影响",{"2":{"390":1}}],["对丢包率要求不是那么高",{"2":{"364":1}}],["对时延要求比较高",{"2":{"364":1}}],["对参数进行合法性校验",{"2":{"320":1}}],["对数据加锁",{"2":{"309":1}}],["对同一字段的多次读取结果都是一致的",{"2":{"273":1,"279":1}}],["对",{"2":{"233":1,"525":1}}],["对cpu不友好",{"2":{"213":1}}],["对面用的如果和你一样的技术",{"2":{"181":1}}],["对代码进行优化",{"2":{"180":1}}],["对比一下golang的rehash过程",{"2":{"154":1}}],["对比两个公式",{"2":{"56":1}}],["对线程的调用有一个大致了解",{"2":{"153":1}}],["对应索引树的节点",{"2":{"375":1}}],["对应用层发送的报文段直接添加首部并传送到ip",{"2":{"241":1}}],["对应的问题",{"0":{"273":1}}],["对应的隔离级别是",{"2":{"267":1}}],["对应的中断处理程序",{"2":{"153":1}}],["对应的处理程序就是用来派发系统调用的",{"2":{"153":1}}],["对应8种",{"2":{"7":1}}],["对一个二维数组按照成绩实现快排",{"0":{"114":1}}],["对于io密集型任务",{"2":{"473":2}}],["对于执行计划",{"2":{"390":1}}],["对于有",{"2":{"390":1}}],["对于单个用户的整个或部分响应消息",{"2":{"387":1}}],["对于树来说",{"2":{"375":1}}],["对于数据结构里面",{"2":{"375":1}}],["对于哈希索引来说",{"2":{"345":1}}],["对于不合法参数直接过滤掉",{"2":{"320":1}}],["对于不在同一个网络中的主机",{"2":{"195":1}}],["对于同一行记录",{"2":{"273":1,"279":1}}],["对于修改操作",{"2":{"240":1}}],["对于",{"2":{"56":1}}],["对于业务开发",{"2":{"45":1}}],["对于redis数据库保存的键值对来说",{"2":{"7":1}}],["对象详解",{"2":{"7":1}}],["对象编码",{"2":{"7":1}}],["对象类型有5种",{"2":{"7":1}}],["对象类型",{"2":{"7":1,"154":1}}],["键对象",{"2":{"7":1}}],["键总是一个字符串对象",{"2":{"7":1}}],["而如果用整型做主键",{"2":{"580":1}}],["而有业务逻辑的字段做主键",{"2":{"580":1}}],["而内置函数",{"2":{"543":1}}],["而post方法不是安全和幂等的",{"2":{"503":1}}],["而post则是向uri指定的资源提交数据",{"2":{"503":1}}],["而pipeline做得不是很好",{"2":{"473":1}}],["而cpu还有许多运算要处理",{"2":{"469":1}}],["而锁住一些行",{"2":{"462":1}}],["而视口很局限",{"2":{"451":1}}],["而视频传输对带宽的需求比较大",{"2":{"364":1}}],["而新页面和当前页面属于同一站点的话",{"2":{"443":1}}],["而要确定一个查询是否是覆盖索引",{"2":{"434":1}}],["而后需要保持平衡特性所以就叫做平衡二叉树",{"2":{"426":1}}],["而tcp的连接释放过程又是比较费事的",{"2":{"403":1}}],["而不能是依赖于主键的一部分",{"2":{"522":1}}],["而不再需要回表查询",{"2":{"434":1}}],["而不需要通过聚簇索引查询获得",{"2":{"390":1}}],["而不是给每个goroutine分配固定大小的内存空间",{"2":{"546":1}}],["而不是指向它的指针",{"2":{"543":1}}],["而不是值",{"2":{"543":2}}],["而不是锁在物理行记录上",{"2":{"466":1}}],["而不是",{"2":{"267":1}}],["而不是从",{"2":{"56":1}}],["而不是从1开始",{"2":{"56":1}}],["而不是键对象的类型",{"2":{"7":1}}],["而二叉树的每个父节点的儿子节点个数只能是",{"2":{"390":1}}],["而二级索引树的每个节点只会存储索引字段值和主键id",{"2":{"345":1}}],["而创建的主键索引默认使用的是",{"2":{"390":1}}],["而b树则需要对树的每一层进行遍历甚至有可能需要回旋查找",{"2":{"363":1}}],["而我们经常使用的innodb存储引擎的默认索引实现为",{"2":{"345":1}}],["而",{"2":{"291":1,"375":1,"390":3,"455":1}}],["而此时binlog为statement格式",{"2":{"285":1}}],["而另一个事务却在此时插入了新的几列数据",{"2":{"267":1}}],["而服务端还有可能还有数据要处理和发送",{"2":{"256":1}}],["而对于修改的操作依旧存在幻读问题",{"2":{"240":1}}],["而轮询与命令的执行都是主线程",{"2":{"230":1}}],["而init进程会循环地wait",{"2":{"229":1}}],["而这时mvcc可以通过提供历史版本从而实现读取被锁的数据的历史版本",{"2":{"297":1}}],["而这个",{"2":{"213":1}}],["而这些较小的局部问题就便于研究和处理",{"2":{"206":1}}],["而这些数据结构由对象的encoding属性决定",{"2":{"7":1}}],["而红包池的机制是对",{"2":{"202":1}}],["而一些不安全的因素则会被防火墙过滤",{"2":{"184":1}}],["而系统调用的派发程序会根据指定的系统调用编号",{"2":{"153":1}}],["而硬件层面",{"2":{"153":1}}],["而目前线程a1处于用户态",{"2":{"153":1}}],["而虚拟内存分配",{"2":{"153":1}}],["而进程中的其他线程",{"2":{"153":1}}],["而在linux中只使用了一个task",{"2":{"153":1}}],["而在cpu密集型的任务中",{"2":{"153":1,"167":1}}],["而线程是共享所在进程的虚拟地址空间的",{"2":{"153":1}}],["而主机之间可以有很多链路",{"2":{"129":1}}],["而传输层协议是为主机中的进程提供数据传输服务",{"2":{"129":1}}],["而数组的长度是数组类型的一部分",{"2":{"120":1}}],["而用容器的话则需要这样定义",{"2":{"45":1}}],["而autoboxing",{"2":{"45":1}}],["而是继续执行下面的操作",{"2":{"485":1}}],["而是用商品编码查询商品",{"2":{"390":1}}],["而是通过对比数据的时间戳或者版本号",{"2":{"309":1}}],["而是解决了读数据情况下的幻读问题",{"2":{"240":1}}],["而是抽样一部分并且从中选出被淘汰的key",{"2":{"202":1}}],["而是要学习它背后的思想和处理技巧",{"2":{"35":1}}],["而是基于数据结构创建了一个对象系统",{"2":{"6":1}}],["而且自我感觉回收算法不够好",{"0":{"119":1}}],["而且",{"2":{"45":1,"154":1,"222":1}}],["而且也挺有意思",{"0":{"27":1}}],["而且不要求写题",{"0":{"26":1}}],["而值则可以是字符串对象",{"2":{"7":1}}],["每隔k分钟检测一次",{"2":{"405":1}}],["每隔一段时间",{"2":{"213":1}}],["每步可以顺时针到下一个点",{"0":{"359":1}}],["每当有资源请求就去检测",{"2":{"405":1}}],["每当有记录在表中增减或索引列被修改时",{"2":{"357":1}}],["每当出现一个孤儿进程的时候",{"2":{"229":1}}],["每组前100条拿出来",{"0":{"139":1}}],["每行只有一个单词",{"0":{"124":1}}],["每个表包含哪些字段",{"2":{"587":1}}],["每个列都不可以再拆分",{"2":{"522":1}}],["每个线程去取值难道不一样吗",{"2":{"221":1}}],["每个线性表上的数据最多只有前和后两个方向",{"2":{"28":1}}],["每个位置的值对应下标",{"0":{"162":1}}],["每个进程都有自己的虚拟地址空间",{"2":{"153":1}}],["每个数据都是",{"0":{"61":1}}],["每次插入一条新记录",{"2":{"580":1}}],["每次发送请求",{"2":{"403":1}}],["每次请求服务器不跟踪也每个客户单",{"2":{"403":1}}],["每次都是一条从根节点到叶节点的路径",{"2":{"375":1}}],["每次都是线性增长",{"2":{"268":1}}],["每次翻倍增加",{"2":{"268":1}}],["每次从数据库访问",{"2":{"213":1}}],["每次随机访问数组元素都多了一次减法运算",{"2":{"56":1}}],["每次存储空间不够的时候",{"2":{"45":1}}],["每次的删除操作并不是真正地搬移数据",{"2":{"35":1}}],["每次当我们在redis的数据库中新创建一个键值对时",{"2":{"7":1}}],["每一条从根节点到叶子节点的路径都可以",{"0":{"182":1}}],["每一帧包括数据和必要的控制信息",{"2":{"129":1}}],["每一行是一个单词",{"0":{"30":1}}],["每一个redis数据结构都是有雨",{"2":{"7":1}}],["每一种对象底层对应了多种不同数据结构",{"2":{"6":1}}],["每种对象都用到了多种数据结构",{"2":{"6":1}}],["这题回答的时候以为有引用传递",{"2":{"516":1}}],["这题面试的时候没有答到第三点",{"2":{"396":1}}],["这类任务的特点是cpu消耗很少",{"2":{"473":1}}],["这类字段就比较适合做索引或排在联合索引列的靠前的位置",{"2":{"390":1}}],["这可能是因为任务本身需要大量i",{"2":{"473":1}}],["这可能是因为任务本身不太需要访问i",{"2":{"469":1}}],["这其中需要你重点关注",{"2":{"390":1}}],["这已经比",{"2":{"390":1}}],["这四种树你能谈一下你的理解么",{"2":{"375":1}}],["这会需要更多的内存置换次数",{"2":{"363":1}}],["这意味着每条记录的insert",{"2":{"357":1}}],["这跟",{"2":{"279":1}}],["这是因为新页面的响应数据还没有获得",{"2":{"435":1}}],["这是tcp所不允许的",{"2":{"274":1}}],["这是redis5",{"2":{"154":1}}],["这时候我们就要优先考虑上一段提到的",{"2":{"580":1}}],["这时候对数据库压力比较小",{"2":{"320":1}}],["这时",{"2":{"267":1}}],["这时数据库就处于一种不正确的状态",{"2":{"261":1}}],["这时如果有新的数据写入",{"2":{"202":1}}],["这道题有点吃亏",{"0":{"257":1}}],["这些日志的实现原理",{"0":{"584":1}}],["这些锁的出现主要是用来解决哪些问题",{"0":{"482":1}}],["这些元素对于布局是丝毫没用的",{"2":{"451":1}}],["这些请求就会出现串行请求",{"2":{"399":1}}],["这些未完成事务对数据库所做的修改有一部分已写入物理数据库",{"2":{"261":1}}],["这些已经",{"2":{"229":1}}],["这些孤儿进程",{"2":{"229":1}}],["这些孤儿进程会被init进程接管",{"2":{"229":1}}],["这些占着茅坑不拉屎的子进程就成为",{"2":{"229":1}}],["这些进程表项就将一直被占用",{"2":{"229":1}}],["这些东西才是最有价值的",{"2":{"35":1}}],["这也是",{"2":{"248":1,"390":1}}],["这也是redis对外提供键值存储服务的主要流程",{"2":{"222":1}}],["这也会促使你紧接着提问",{"2":{"222":1}}],["这说明你支持并行",{"2":{"212":1}}],["这说明你支持并发",{"2":{"212":1}}],["这就是典型的",{"2":{"580":1}}],["这就是不依赖系统的信息",{"2":{"546":1}}],["这就会形成一个线程和资源请求等待的环形图",{"2":{"401":1}}],["这就说明你不支持并发也不支持并行",{"2":{"212":1}}],["这就需要使用专门的链路层协议",{"2":{"129":1}}],["这两类策略",{"2":{"202":1}}],["这两个关联列会怎样",{"0":{"547":1}}],["这两个线程同属于进程a",{"2":{"153":1}}],["这两个命令后才会出现master分支",{"2":{"2":1}}],["这一行所在的数据页本来就在内存中",{"2":{"583":1}}],["这一行数据",{"2":{"583":1}}],["这一类策略",{"2":{"202":1}}],["这一机制可以在适当的条件下",{"2":{"6":1}}],["这八种策略大体分为",{"2":{"202":1}}],["这种无连接的特性会使得网络的利用率变低",{"2":{"403":1}}],["这种无状态性可以借助cookie",{"2":{"403":1}}],["这种无缓冲的通道我们也称之为同步通道",{"2":{"235":1}}],["这种数据直接穿透缓存",{"2":{"320":1}}],["这种格式在rc隔离级别下有bug",{"2":{"285":1}}],["这种情况就产生了死锁",{"2":{"397":1}}],["这种情况就是",{"2":{"270":1}}],["这种情况下",{"2":{"45":1}}],["这种现象就像是让事务",{"2":{"267":1}}],["这种结果告诉我们其实在mysql可重复读的隔离级别中并不是完全解决了幻读的问题",{"2":{"240":1}}],["这种类型的通道在接收前没有能力保存任何值",{"2":{"235":1}}],["这种问题",{"2":{"230":1}}],["这种方式成为并行",{"2":{"212":1}}],["这种方式需要依靠某种同步操作",{"2":{"179":1}}],["这种方式能够在不同的进程中间提供全双工通信连接",{"2":{"179":1}}],["这种通信方式主要用于解决与同步相关的问题并避免竞争条件",{"2":{"179":1}}],["这被称为从",{"2":{"153":1}}],["这被称为它的主线程",{"2":{"153":1}}],["这被称为线程栈",{"2":{"153":1}}],["这样写数据成本相对较高",{"2":{"580":1}}],["这样可以提高执行的效率",{"2":{"485":1}}],["这样可以保证获得最低的缺页率",{"2":{"449":1}}],["这样的线性化操作就自然就不存在循环了",{"2":{"401":1}}],["这样的话就形成了一个高可用的集群",{"2":{"320":1}}],["这样不可剥夺这个条件就破坏掉了",{"2":{"401":1}}],["这样区分度大的字段越有可能被更多的",{"2":{"390":1}}],["这样事务之间就完全不可能产生干扰",{"2":{"273":1,"279":1}}],["这样发送方就可以知道哪些数据收到了",{"2":{"268":1}}],["这样来看",{"2":{"229":1}}],["这样",{"2":{"229":3}}],["这样显得",{"2":{"222":1}}],["这样主机d就可以收到转发来的数据报了",{"2":{"195":1}}],["这样当本网络中的主机与其他网络中的主机进行通信的时候本网络中的主机会将ip数据报栓送给默认网关",{"2":{"195":1}}],["这样就避免了需要程序员来决定栈的大小",{"2":{"546":1}}],["这样就不存在等待了",{"2":{"401":1}}],["这样就保证了",{"2":{"390":1}}],["这样就产生主从不一致的问题",{"2":{"285":1}}],["这样就完成了一次系统调用",{"2":{"153":1}}],["这样就大大减少了删除操作导致的数据搬移",{"2":{"35":1}}],["这样应用程序才能通过这些空间来和内核交互",{"2":{"153":1}}],["这几个线程共享进程内的资源",{"2":{"153":1}}],["这几个数据会被搬移三次",{"2":{"35":1}}],["这非常有用",{"2":{"134":2}}],["这使得应用程序不必担心在各台计算机中表示和存储的内部格式差异",{"2":{"129":1}}],["这里推荐下潘少的",{"2":{"549":1}}],["这里答得有点混乱",{"2":{"525":1}}],["这里有点疑问",{"2":{"587":1}}],["这里有",{"2":{"451":1}}],["这里的查询参考上面",{"2":{"390":1}}],["这里主要探讨的是如何处理redis中过期的key",{"2":{"213":1}}],["这里主要记录kafka相关面试题",{"2":{"85":1}}],["这里我理解了合并有序链表",{"0":{"161":1}}],["这里我一开始思路出错了",{"2":{"87":1}}],["这里除了页目录以外还能找到很多重要的内容",{"2":{"153":1}}],["这里没有初始化的意思就是没有赋值",{"2":{"96":1}}],["这里需要注意一点",{"2":{"45":1}}],["这不就是",{"2":{"35":1}}],["这个协议他位于网络的第几层知道吧",{"0":{"562":1}}],["这个2节点要么没有孩子",{"2":{"426":1}}],["这个过程叫回表",{"2":{"390":1}}],["这个问题一面也问了",{"2":{"572":1}}],["这个问题其实比较容易回答",{"2":{"390":1}}],["这个问题会涉及到mysql的存储数据结构",{"2":{"345":1}}],["这个问题很开",{"0":{"27":1}}],["这个数据没传输完指的什么",{"0":{"334":1}}],["这个数据库键所对应的值为列表对象",{"2":{"7":1}}],["这个数据库键所对应的值为字符串对象",{"2":{"7":1}}],["这个很简单的",{"2":{"329":1}}],["这个视图是在每个",{"2":{"291":1}}],["这个视图是在事务启动时创建的",{"2":{"291":1}}],["这个bug大致是这样",{"2":{"285":1}}],["这个现象就是",{"2":{"267":1}}],["这个有点儿像我们打网游中的副本",{"2":{"261":1}}],["这个图看懂了",{"2":{"230":1}}],["这个子进程需要做的事情很少",{"2":{"229":1}}],["这个重任就落到了init进程身上",{"2":{"229":1}}],["这个可能会误解",{"2":{"221":1}}],["这个是共享的",{"2":{"221":1}}],["这个是为了平衡我们的效率",{"2":{"213":1}}],["这个时候就要区分",{"2":{"213":1}}],["这个时候就应该主动告诉面试官自己知道",{"2":{"154":1}}],["这个时候数组就会优于容器",{"2":{"45":1}}],["这个限流要做成分布式的",{"2":{"133":1}}],["这个同步原语",{"0":{"107":1}}],["这个简单",{"0":{"89":1}}],["这个查了下有个专门的算法",{"0":{"82":1}}],["这个我把自己绕进去了",{"0":{"55":1}}],["这个属性的值可以是redis",{"2":{"7":1}}],["这个对象所占用的内存就会被自动释放",{"2":{"6":1}}],["这个系统包含字符串对象",{"2":{"6":1}}],["背景",{"0":{"6":1},"2":{"201":1}}],["贡献者",{"0":{"5":1}}],["uber",{"2":{"549":1}}],["uri",{"2":{"439":1}}],["url=http",{"2":{"387":1}}],["url",{"0":{"27":1,"98":1,"536":1,"570":1},"2":{"387":1,"435":6,"439":2,"447":1,"572":1}}],["using",{"2":{"434":1}}],["userid",{"0":{"579":1},"2":{"578":1}}],["userid=johndoe",{"2":{"387":1}}],["username=2",{"2":{"390":2}}],["username",{"0":{"579":1},"2":{"390":1}}],["userpin=1",{"2":{"390":2}}],["userpin",{"2":{"390":1}}],["user",{"0":{"576":1,"579":1},"2":{"241":1,"387":1,"434":3,"482":6}}],["used",{"2":{"202":2,"449":2}}],["uuid",{"2":{"390":1}}],["update将为此多付出4",{"2":{"357":1}}],["update",{"2":{"240":1,"267":1,"309":1,"482":1,"583":1}}],["uptime",{"2":{"177":1}}],["udp有什么缺点",{"0":{"370":1}}],["udp是面向无连接的传输协议",{"2":{"364":1}}],["udp是传输层协议",{"2":{"340":1}}],["udp模块的报文根据端口号确定送给哪个应用程序处理",{"2":{"340":1}}],["udp的端口号用来说明是哪种上层应用",{"2":{"340":1}}],["udp和tcp",{"0":{"241":1}}],["udp",{"0":{"352":1},"2":{"129":2,"172":2,"241":1,"340":3,"572":8}}],["uint",{"2":{"91":2}}],["unix",{"2":{"387":1}}],["unix进程模型中",{"2":{"229":1}}],["uncommitted",{"2":{"273":1,"279":1}}],["undo原子性",{"2":{"584":1}}],["undolog",{"0":{"584":1},"2":{"584":2}}],["undo",{"2":{"267":1,"303":1}}],["unordered",{"0":{"78":1}}],["unboxing",{"2":{"45":1}}],["unsigned",{"2":{"7":2}}],["u",{"2":{"4":1}}],["city",{"0":{"579":1}}],["cyan",{"2":{"549":1}}],["ctrl+c",{"2":{"525":1}}],["c语言最差",{"2":{"473":1}}],["css",{"2":{"451":2}}],["csdn",{"2":{"279":1,"285":1,"297":1,"303":1,"321":1,"551":1}}],["create",{"2":{"434":1}}],["crotab",{"0":{"200":1}}],["currently",{"2":{"449":1}}],["curd的时间复杂度都是logn",{"2":{"345":1}}],["cugxuan",{"2":{"229":1}}],["close",{"2":{"483":1,"572":1}}],["close不能完全关闭",{"0":{"310":1}}],["clustered",{"2":{"390":1}}],["client",{"0":{"344":1}}],["client依然可以发送消息",{"2":{"274":1}}],["cn",{"2":{"229":1,"491":1}}],["cnblogs",{"2":{"222":1,"285":1,"491":1}}],["c比较了解一点",{"2":{"203":1}}],["c三种方案",{"2":{"181":1}}],["cbyte",{"2":{"134":1}}],["cba",{"0":{"99":1}}],["cacahe",{"2":{"525":1}}],["cache",{"2":{"387":6}}],["ca机构",{"0":{"459":1}}],["ca",{"0":{"539":1},"2":{"455":1}}],["ca00d56cbbdf27a99eebcf94",{"2":{"177":1}}],["cases",{"2":{"572":1}}],["cas",{"0":{"107":1},"2":{"185":1,"309":1}}],["cassandra",{"2":{"59":2}}],["capacity+7",{"2":{"91":1}}],["capacity",{"2":{"91":1}}],["cap",{"0":{"77":1},"1":{"90":1,"102":1},"2":{"185":1,"586":1}}],["cdn",{"0":{"59":1}}],["cpu负载过高了怎么办",{"0":{"505":1}}],["cpu效率越高",{"2":{"473":1}}],["cpu执行任务的效率越低",{"2":{"473":1}}],["cpu占用率仍然较低",{"2":{"473":1}}],["cpu要读",{"2":{"469":1}}],["cpu密集型任务使用多进程",{"2":{"473":1}}],["cpu密集型也叫计算密集型",{"2":{"469":1}}],["cpu密集型",{"0":{"465":1,"469":1},"1":{"469":1,"473":1},"2":{"177":1}}],["cpu这里保存的页目录地址要切换到进程b",{"2":{"153":1}}],["cpu硬件时钟会触发一次时钟中断",{"2":{"153":1}}],["cpu的执行权被划分为不同的时间片",{"2":{"153":1}}],["cpu的指令指针就会指向线程的执行入口",{"2":{"153":1}}],["cpu有一个中断控制器",{"2":{"153":1}}],["cpu中会有一个特权级标志",{"2":{"153":1}}],["cpu面向的是某个线程",{"2":{"153":1}}],["cpu上真正运行的是线程",{"2":{"153":1,"167":1}}],["cpu",{"0":{"465":1,"469":1,"513":1},"1":{"469":1,"473":1},"2":{"56":1,"177":1,"213":6,"469":2,"525":4}}],["c",{"0":{"74":1,"87":1,"524":1},"2":{"35":3,"45":2,"134":1,"169":1,"329":1,"401":1,"543":1}}],["chrome",{"2":{"439":1}}],["chunked",{"2":{"387":1}}],["char",{"0":{"578":1}}],["charset=utf",{"2":{"387":1}}],["chan",{"2":{"543":4}}],["channel的实现",{"0":{"258":1}}],["channel是线程安全的",{"2":{"227":1}}],["channel",{"0":{"227":1,"235":1},"1":{"235":1,"243":1,"251":1,"258":1},"2":{"400":2,"516":2,"543":4}}],["changelog",{"2":{"3":1}}],["check",{"0":{"91":1},"2":{"29":1,"91":5}}],["copy",{"2":{"500":2,"587":2}}],["copy是操作符还是内置函数",{"0":{"496":1}}],["collision",{"2":{"587":1}}],["color",{"2":{"451":2}}],["column",{"2":{"308":1,"390":1}}],["code",{"2":{"387":1}}],["cookie与session区别",{"0":{"515":1}}],["cookie传输",{"0":{"511":1}}],["cookie\\tset",{"2":{"387":1}}],["cookie\\t设置http",{"2":{"387":1}}],["cookie",{"0":{"160":1,"530":1},"2":{"387":3,"439":2,"572":1}}],["commmit",{"2":{"587":1}}],["communicating",{"2":{"400":1}}],["communication",{"2":{"179":1}}],["communicate",{"2":{"400":1}}],["committed",{"2":{"273":1,"279":2}}],["commit",{"2":{"2":1,"583":1,"587":1}}],["com",{"0":{"82":1,"524":1},"2":{"177":1,"222":1,"285":1,"363":1,"387":3,"491":2,"549":3,"584":3,"587":1}}],["connection",{"2":{"387":1,"439":1,"483":1}}],["concurrent",{"2":{"297":2}}],["context",{"0":{"378":1,"383":1}}],["context包有没有用过",{"0":{"324":1}}],["content",{"2":{"154":3,"308":1,"387":9,"443":1}}],["control\\t告诉所有的缓存机制是否可以缓存及哪种类型\\tcache",{"2":{"387":1}}],["control",{"2":{"153":1,"241":1,"297":2,"387":3}}],["consult",{"2":{"586":1}}],["consumergroup",{"2":{"59":1}}],["const",{"2":{"390":1}}],["constructor",{"0":{"91":1}}],["consistent",{"2":{"285":1}}],["console",{"2":{"81":1}}],["config",{"2":{"1":3,"180":4}}],["mutex",{"2":{"587":1}}],["multi",{"2":{"297":1}}],["mp",{"2":{"584":3,"587":1}}],["mmu有了解吗",{"0":{"437":1}}],["miscellaneous",{"2":{"387":1}}],["mongo",{"0":{"575":1}}],["mongodb",{"0":{"575":2}}],["modified",{"2":{"387":1}}],["modified\\t请求资源的最后修改时间\\tlast",{"2":{"387":1}}],["more",{"0":{"200":1}}],["md5",{"2":{"387":1}}],["md5\\t返回资源的md5校验值\\tcontent",{"2":{"387":1}}],["m的大小取决于磁盘页的大小",{"2":{"375":1}}],["mvvc机制以及undo",{"2":{"279":1,"297":1}}],["mvvc",{"2":{"279":1}}],["mvcc是解决不可重复读",{"2":{"584":1}}],["mvcc只有rc",{"2":{"584":1}}],["mvcc只有rr和rc才会有",{"2":{"240":1}}],["mvccc",{"2":{"584":1}}],["mvcc中的涉及到锁的笔记",{"2":{"458":1}}],["mvcc原理",{"2":{"267":1}}],["mvcc",{"0":{"327":1},"2":{"103":1,"267":1,"297":1,"584":1}}],["myisam",{"2":{"248":2,"587":1}}],["mysql把邮戳转化为日常格式时间的函数",{"0":{"563":1}}],["mysql怎么存储时间",{"0":{"561":1}}],["mysql怎么去查询的",{"0":{"550":1}}],["mysql了解什么",{"0":{"553":1}}],["mysql的存储引擎",{"0":{"510":1}}],["mysql的锁",{"0":{"470":1}}],["mysql的锁类型",{"0":{"458":1}}],["mysql中innodb引擎",{"0":{"494":1}}],["mysql中默认使用可重读",{"2":{"273":1}}],["mysql一律打印btree",{"2":{"345":1}}],["mysql通过存储引擎取数据",{"2":{"345":1}}],["mysql索引",{"0":{"418":1}}],["mysql索引类型有哪些",{"0":{"390":1}}],["mysql索引结构",{"2":{"345":1}}],["mysql索引的数据结构以及分类",{"0":{"345":1}}],["mysql修改数据同时在内存和redo",{"2":{"303":1}}],["mysql将默认的隔离级别设为rr可重复读",{"2":{"285":1}}],["mysql主从复制是基于binlog",{"2":{"285":1}}],["mysql默认rr隔离级别是有历史原因的",{"2":{"285":1}}],["mysql默认使用哪个隔离",{"0":{"285":1}}],["mysql事务的隔离级别以及分别如何实现",{"0":{"279":1}}],["mysql事务隔离级别对应的问题",{"0":{"267":1}}],["mysql事务隔离级别和实现原理",{"2":{"240":1}}],["mysql是一个支持多引擎的系统",{"2":{"248":1}}],["mysql日志系统",{"2":{"240":1}}],["mysql实战45讲",{"2":{"240":1}}],["mysql面试题重点围绕事务",{"2":{"103":1}}],["mysql",{"0":{"103":1,"309":1,"422":1,"442":1,"569":1,"575":2,"580":1},"1":{"115":1,"128":1,"144":1,"158":1,"171":1,"183":1,"194":1,"205":1,"216":1,"224":1,"232":1,"240":1,"248":1,"255":1,"261":1,"267":1,"273":1,"279":1,"285":1,"291":1,"297":1,"303":1,"309":1,"315":1,"321":1,"327":1,"333":1,"339":1,"345":1,"351":1,"357":1,"363":1,"369":1,"375":1,"381":1,"386":1,"390":1,"394":1,"398":1,"402":1,"406":1,"410":1,"414":1,"418":1,"422":1,"426":1,"430":1,"434":1,"438":1,"442":1,"446":1,"450":1,"454":1,"458":1,"462":1,"466":1,"470":1,"474":1,"478":1,"482":1,"486":1,"490":1,"494":1,"498":1,"502":1,"506":1,"510":1,"514":1,"518":1,"522":1,"526":1,"529":1,"532":1,"535":1,"538":1,"541":1,"544":1,"547":1,"550":1,"553":1,"555":1,"557":1,"559":1,"561":1,"563":1,"565":1,"567":1,"569":1,"571":1,"573":1,"574":1,"575":1,"576":1,"577":1,"578":1,"579":1,"580":1,"581":1,"582":1,"583":1,"584":1,"585":1,"586":1,"587":1},"2":{"103":1,"185":1,"240":3,"248":1,"267":2,"273":2,"279":1,"309":1,"345":1,"390":4,"583":1,"586":1,"587":6}}],["mr",{"2":{"222":1}}],["method",{"2":{"387":1}}],["memcache的acceptor线程监听到套接字事件之后",{"2":{"230":1}}],["memcache的io模型",{"2":{"230":1}}],["memcache中的io多路复用是多线程的",{"2":{"230":1}}],["memory",{"2":{"179":1,"400":2}}],["message",{"2":{"179":1}}],["max",{"2":{"387":2}}],["maxmemory",{"2":{"180":6}}],["master",{"0":{"524":1},"2":{"285":1,"587":1}}],["mac",{"2":{"225":2,"572":1}}],["marshal",{"2":{"134":4}}],["make区别",{"0":{"543":1}}],["make",{"2":{"91":1,"543":18}}],["map都是安全的吗",{"0":{"199":1}}],["map不是线程安全的",{"2":{"176":1}}],["map是线程安全的吗",{"0":{"176":1}}],["map结构实现",{"2":{"164":1}}],["map的底层原理",{"0":{"164":1}}],["map",{"0":{"78":3,"210":1,"330":1},"2":{"176":1,"500":1,"516":2,"543":8,"552":2}}],["main",{"2":{"63":1,"91":2,"134":2}}],["m",{"0":{"287":2,"371":1},"2":{"2":1,"375":2,"543":1}}],["i",{"0":{"465":1,"473":1},"1":{"469":1,"473":1},"2":{"335":9,"390":4,"469":1,"473":1}}],["io是短板",{"2":{"473":1}}],["io是多线程的",{"2":{"222":1,"230":1}}],["io多路复用的类别",{"0":{"379":1}}],["io多路复用会挑出准备好",{"2":{"230":1}}],["io次数就是树的高度",{"2":{"375":1}}],["io和多路复用",{"0":{"367":1}}],["io模型本质上是多路复用",{"2":{"230":1}}],["io模型",{"0":{"361":1,"384":1},"1":{"367":1,"373":1,"379":1,"384":1,"389":1,"393":1,"397":1,"401":1,"405":1,"409":1,"413":1,"417":1,"421":1,"425":1},"2":{"222":1}}],["io",{"0":{"517":1},"2":{"185":1,"525":2}}],["io密集型任务使用多线程",{"2":{"473":1}}],["io密集型任务执行期间",{"2":{"473":1}}],["io密集型指的是系统的cpu性能相对硬盘",{"2":{"473":1}}],["io密集型",{"0":{"465":1,"473":1},"1":{"469":1,"473":1},"2":{"177":1,"473":1}}],["icmp",{"0":{"551":1,"562":1},"2":{"172":1,"340":2}}],["igmp",{"2":{"172":1}}],["if",{"2":{"91":2}}],["id=2",{"2":{"583":2}}],["id",{"0":{"149":1,"576":1},"2":{"59":1,"134":2,"267":6,"390":2,"434":3,"576":1,"578":3}}],["ipc",{"2":{"439":1}}],["ip地址",{"2":{"387":1,"548":1}}],["ip头中的协议号用来说明ip报文中承载的是哪种协议",{"2":{"340":1}}],["ip是网络层协议",{"2":{"340":1}}],["ip",{"0":{"34":1,"44":3,"217":1},"2":{"129":1,"172":6,"179":1,"439":1,"560":1}}],["infinity",{"2":{"482":2}}],["index",{"2":{"357":1,"387":1,"390":2,"434":1,"451":2}}],["innodb和xtradb通过mvcc解决幻读了",{"2":{"584":1}}],["innodb与myisam的区别",{"0":{"506":1}}],["innodb二级索引流程",{"0":{"381":1}}],["innodb的一些特性",{"0":{"478":1,"490":1}}],["innodb的索引有哪些",{"0":{"398":1}}],["innodb的索引类型目前只有两种",{"2":{"345":1}}],["innodb的主键索引树的叶子节点上存储行数据",{"2":{"345":1}}],["innodb引擎中分主键",{"2":{"345":1}}],["innodb数据表上的索引是表空间的一个组成部分",{"2":{"339":1}}],["innodb采用的mvcc实现方式是",{"2":{"297":1}}],["innodb",{"2":{"248":1,"267":2,"390":2,"466":4,"583":1,"587":4}}],["insert",{"2":{"240":1,"267":1,"285":1,"482":5}}],["install",{"2":{"0":1}}],["init进程会wait",{"2":{"229":1}}],["init进程就会代表党和政府出面处理它的一切善后工作",{"2":{"229":1}}],["init进程就好像是一个民政局",{"2":{"229":1}}],["in",{"2":{"179":1,"449":1,"587":5}}],["into",{"2":{"285":1,"482":5}}],["interrupt",{"2":{"525":3}}],["inter",{"2":{"179":1}}],["integertype",{"2":{"543":1}}],["integer",{"2":{"45":1}}],["int编码的字符串对象和embstr编码的字符串对象在条件满足的情况下",{"2":{"154":1}}],["intset",{"2":{"7":1}}],["int",{"0":{"91":3},"2":{"7":1,"45":1,"91":3,"96":1,"108":1,"134":4,"154":1,"434":2,"500":1,"552":1}}],["import",{"2":{"1":2,"91":1,"134":1}}],["tugenhua0707",{"2":{"491":1}}],["tue",{"2":{"387":2}}],["tls",{"2":{"439":1,"455":2}}],["tls升级到了1",{"2":{"415":1}}],["tye字段以及extra字段",{"0":{"422":1}}],["type=",{"2":{"482":1}}],["type\\t返回内容的mime类型\\tcontent",{"2":{"387":1}}],["type命令的实现方式也与此类似",{"2":{"7":1}}],["type命令返回数据库键对应的值对象的类型",{"2":{"7":1}}],["type属性记录了对象的类型",{"2":{"7":1}}],["type",{"2":{"7":1,"56":1,"91":1,"134":1,"387":2,"390":2,"443":1,"543":4,"552":1}}],["typedef",{"2":{"7":1}}],["tab",{"2":{"443":1}}],["table",{"2":{"434":1,"482":1}}],["table是如何实现的",{"2":{"154":1}}],["ta",{"2":{"335":2}}],["transfer",{"2":{"387":1}}],["transmission",{"2":{"241":1}}],["trailer\\t指出头域在分块传输编码的尾部存在\\ttrailer",{"2":{"387":1}}],["tree",{"2":{"154":1,"345":1,"426":2}}],["timewait2",{"2":{"572":2}}],["time",{"0":{"292":3},"2":{"292":2,"572":1}}],["tips",{"2":{"202":3}}],["title",{"2":{"7":1,"308":1}}],["ttl",{"2":{"202":1}}],["to",{"2":{"229":1}}],["top命令了解么",{"0":{"189":1}}],["top命令查看",{"2":{"177":1}}],["top或者uptime",{"2":{"177":1}}],["todo",{"2":{"154":1}}],["test",{"2":{"285":4,"552":3}}],["tee",{"0":{"200":1}}],["telnet",{"2":{"172":1}}],["text索引",{"2":{"390":1}}],["text",{"2":{"7":1,"387":1,"443":1}}],["tcp是字符流协议",{"2":{"399":1}}],["tcp在网络拥塞的情况下会进行tcp全局同步",{"2":{"364":1}}],["tcp需要进行三次握手",{"2":{"364":1}}],["tcp最多有几个连接",{"0":{"304":1}}],["tcp相关的关闭连接",{"0":{"298":1}}],["tcp访问一个主机如果主机端口不存在返回什么信息",{"0":{"280":1}}],["tcp一个重要特性便是可靠性",{"2":{"274":1}}],["tcp三次握手",{"0":{"256":1}}],["tcp可靠性的实现方式",{"0":{"249":1}}],["tcp和udp",{"0":{"233":1},"1":{"241":1,"249":1,"256":1,"262":1,"268":1,"274":1,"280":1,"286":1,"292":1,"298":1,"304":1,"310":1,"316":1,"322":1,"328":1,"334":1,"340":1,"346":1,"352":1,"358":1,"364":1,"370":1}}],["tcp主要提",{"2":{"129":1}}],["tcp",{"0":{"217":1,"340":1,"346":1,"352":1,"358":1,"572":1},"2":{"129":1,"172":4,"179":1,"233":1,"241":1,"249":1,"268":2,"274":1,"340":5,"439":9,"455":3,"479":1,"483":5,"572":15}}],["t",{"0":{"89":1,"111":1},"2":{"400":1,"449":2,"543":5}}],["thread",{"2":{"587":1}}],["thu",{"2":{"387":1}}],["that",{"0":{"26":1}}],["theme",{"2":{"0":3,"1":3}}],["ts",{"2":{"1":1}}],["配置全局流量",{"2":{"133":1}}],["配置",{"0":{"1":1}}],["pv",{"2":{"525":1}}],["p352",{"2":{"426":1}}],["public",{"2":{"387":1}}],["put",{"0":{"91":1},"2":{"77":1}}],["phantom",{"2":{"267":1}}],["php",{"0":{"178":1}}],["p",{"2":{"222":1,"285":1,"363":1,"491":1}}],["pool",{"2":{"549":1}}],["port限制",{"0":{"304":1}}],["policy",{"2":{"180":4}}],["positive",{"2":{"482":1}}],["possible",{"2":{"390":1}}],["post",{"2":{"387":1,"491":1,"572":1}}],["pos",{"2":{"91":4}}],["pipes",{"2":{"179":2}}],["prepare",{"2":{"583":1,"587":2}}],["pragma\\t包括实现特定的指令",{"2":{"387":1}}],["primary",{"2":{"434":1}}],["private",{"2":{"387":1}}],["println",{"2":{"91":4,"134":4}}],["profile",{"0":{"444":1}}],["proxy",{"2":{"387":1}}],["protocol",{"2":{"241":2}}],["process",{"2":{"153":1,"179":1}}],["programming",{"0":{"9":1}}],["panjf2000",{"2":{"549":1}}],["panic",{"0":{"472":1,"476":1}}],["package",{"2":{"91":1,"134":1}}],["paragraph",{"2":{"7":1}}],["ptr指针指向对象的底层实现数据结构",{"2":{"7":1}}],["ptr",{"2":{"7":1}}],["plumetheme",{"2":{"1":2}}],["plume",{"2":{"0":3,"1":1}}],["pnpm",{"2":{"0":2}}],["nio",{"2":{"587":1}}],["nil",{"0":{"134":1},"2":{"134":1}}],["nagle",{"2":{"572":1}}],["name=",{"2":{"576":1}}],["names",{"2":{"179":1}}],["name",{"0":{"576":1},"2":{"134":2,"576":1}}],["n+1",{"2":{"375":1,"583":1}}],["n棵子tree的节点包含n个关键字",{"2":{"345":1}}],["node",{"2":{"552":3}}],["node=",{"2":{"482":1}}],["normal",{"2":{"482":2}}],["nowhere",{"2":{"387":1}}],["nov",{"2":{"387":2}}],["no",{"2":{"387":3}}],["not",{"2":{"387":1,"434":2}}],["non",{"2":{"267":1}}],["noeviction",{"2":{"180":1,"202":1}}],["null",{"2":{"134":2,"434":2}}],["num",{"2":{"91":8}}],["nginx的master",{"0":{"178":1}}],["nginx",{"0":{"110":1},"1":{"122":1,"136":1,"152":1,"166":1,"178":1},"2":{"178":4}}],["negative",{"2":{"482":1}}],["netstat",{"2":{"572":1}}],["net",{"2":{"279":1,"285":1,"297":1,"303":1,"321":1,"551":1}}],["newbitmap",{"2":{"91":2}}],["new",{"0":{"543":1},"2":{"63":1,"543":14}}],["next",{"2":{"0":3,"267":2,"584":2}}],["nlp",{"0":{"62":1}}],["n",{"0":{"47":1,"54":1,"89":3,"175":1,"254":1,"287":3,"311":3,"314":1,"359":1,"365":4,"371":1,"377":1},"2":{"35":1,"69":1,"154":1,"195":1,"254":2,"335":2,"363":1,"375":1,"390":1,"583":1,"587":1}}],["npm",{"2":{"0":2}}]],"serializationVersion":2}';export{t as default};
